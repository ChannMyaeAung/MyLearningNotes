# Using the fork system call

```c
pid_t fork(void);
```



```c
#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <alloca.h>
#include <malloc.h>
#include <sys/capability.h>
#include <errno.h>
#include "hello.h"

int main()
{
    if (fork() == -1)
    {
        perror("fork");
        exit(1);
    }
    printf("Hello, fork.\n");

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Hello, fork.
Hello, fork.
```

- The `printf` have been executed twice. 
- Once by the parent process, and once by the new child process.
- Why? The job of the fork is to create a copy of the parent, the child. 
- Once done, both processes must now return to user space from kernel mode. Thus, fork is called once but returns twice; once in the parent and once in the child process context.

---

## Fork rule #1

**Fork rule #1**: After a successful fork, execution in both the parent and child process continues at the instruction following the fork.



### Why does it happen this way?

- The job of fork is to make a identical copy of the parent in the child. 
  - This includes the hardware context, which of course includes the **Instruction Pointer (IP)** register (sometimes called the **Program Counter (PC)**) iteself.
- Hence, the child process too will execute the user mode code at the same location as the parent.
- As the fork is successful, control will not go the error handling code.
- Instead it will go to the `printf`.
- **The key point is this will happen in both the (original) parent and the (new) child process.**

```c
#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <alloca.h>
#include <malloc.h>
#include <sys/capability.h>
#include <errno.h>
#include "hello.h"

int main()
{
    if (fork() == -1)
    {
        perror("fork");
        exit(1);
    }
    printf("PID: %d: Hello, fork.\n", getpid());

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
PID: 25745: Hello, fork.
PID: 25746: Hello, fork.
```

- The PID 25745 is the parent process and the other of course is the child.
- After this, the program exits and thus both processes die.

---

## Fork rule #2 - the return

**Fork rule #2**: To determine whether you are running in the parent or child process, use the fork return value. It's always 0 in the child and the PID of the child in the parent.

### Code

```c
#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <alloca.h>
#include <malloc.h>
#include <sys/capability.h>
#include <errno.h>
#include "hello.h"

static void foo(unsigned int sec)
{
    printf(" %s:%s :: will take a nap for %us ...\n", __FILE__, __FUNCTION__, sec);
    sleep(sec);
}

static void bar(unsigned int sec)
{
    printf(" %s:%s :: will take a nap for %us ...\n", __FILE__, __FUNCTION__, sec);
    sleep(sec);
}

int main(int argc, char *argv[])
{
    pid_t ret;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s {child-alive-sec} {parent-alive-sec}\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    switch (ret = fork())
    {
    case -1:
        perror("fork failed, aborting!\n");
        exit(EXIT_FAILURE);
    case 0: // child
        printf("Child process, PID %d:\n"
               " return %d from fork()\n",
               getpid(), ret);
        foo(atoi(argv[1]));
        printf("Child process (%d) done, exiting...\n", getpid());
        exit(EXIT_SUCCESS);
    default: // parent
        printf("Parent process, PID %d:\n"
               " return %d from fork()\n",
               getpid(), ret);
        bar(atoi(argv[2]));
    }
    printf("Parent process (%d) done, exiting...\n", getpid());
    return 0;
}
```

- As we learned in rule 2, fork returns 0 in the child and the PID of the child in the parent. We use this knowledge to distinguish between the child and parent in the code.
- When the child process ID is done, we do not have it call `break`. Instead we have it exit.
- The reason is for clarity. Have the child do whatever it requires within its business logic (`foo()`), and then simply have it go away.
- If we did use a break, we would require another `if` condition after the `switch` statement. This would be ugly and harder to understand.
- The parent process falls through the switch-case, it just emits a print and exits.

```sh
chan@CMA:~/C_Programming/test$ ./final
Usage: ./final {child-alive-sec} {parent-alive-sec}
chan@CMA:~/C_Programming/test$ ./final 3 7
Parent process, PID 27469:
 return 27470 from fork()
 main.c:bar :: will take a nap for 7s ...
Child process, PID 27470:
 return 0 from fork()
 main.c:foo :: will take a nap for 3s ...
Child process (27470) done, exiting...
Parent process (27469) done, exiting...
```

