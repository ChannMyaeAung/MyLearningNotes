# Virtual Memory

![memory_pyramid](/home/chan/github.com/MyLearningNotes/Linux/SystemProgramming/Virtual Memory/Imgs/memory_pyramid.png)

- Toward the apex of the pyramid, we gain in **Speed** at the cost of size; toward the bottom of the pyramid, it's inverted: **Size** at the cost of speed. 
- We could consider CPU registers to be at the very apex of the pyramid.
- **Swap** is a filesystem type - a raw disk partition is formatted as swap upon system installation. It's treated as second-level RAM by the OS. When the OS runs out of RAM, it uses swap.



- Every single process that is alive will occupy the entire available **virtual address space (VAS)**. Thus, each process overlaps with every other process in terms of VAS.

**Virtual Address Space** : VAS

Virtual page within the process VAS: page

Physical page in RAM: **page frame (pf)**

Does NOT work: **virtual address (va)** -> **physical address (pa)** (maintaining va-to-pa translation entry per address per process is too expensive).

Does Work: (virtual) page -> page frame

- As a rule of thumb, the size of a page is 4 KB (4096 bytes). It's the processor **Memory Management Unit (MMU)** that dictates the page size.
- The mapping process (virtual) page -> page frame is done by the OS on a per-process basis.
- Thus each process has its own mapping table that translates pages to page frames at runtime; it's commonly called the **Paging Table (PT)**.

### Paging Table 

| (Virtual) page | (Physical) page frame |
| -------------- | --------------------- |
| 0              | 3                     |
| 1              | 2                     |
| 2              | 5                     |
| [....]         | [...]                 |
| 15             | 6                     |

- Every process will not use every available page for code or data or whatever; several regions of the virtual address space will remain empty (sparse),
- Even if we do require it, we have a way. When we're out of RAM, we use swap.

| (Virtual) page | (Physical) page frame |
| -------------- | --------------------- |
| 0              | 3                     |
| 1              | 2                     |
| 2              | 5                     |
| [....]         | [...]                 |
| 13             | `<swap-address>`      |
| 14             | `<swap-address>`      |
| 15             | 6                     |

- Each time a process refers to a virtual address, the system must translate the virtual address to the corresponding physical address based on the PTs for that process.



### Address-translation

- At runtime, the process looks up a virtual address which is 9192 bytes from 0, that is, its virtual address: `va = 9192 = 0x000023E8`.

  - If each page is 4096 bytes in size, this implies the va address is on the third page, at an offset of 1000 bytes from the start of that page.
  - With one level of indirection, we have: `va = (page, offset) = (2, 1000)`.
  - The OS sees that the process wants an address in page 2. It does a lookup on the PT for that process, and fins that page 2 maps to page frame 5.

  ```css
  pa = (pf * PAGE_SIZE) + offset
     =  (5 * 4096) + 1000
     =  21480 = 0x000053E8
  ```

  - The system now places the physical address on the bus and the CPU performs its work as usual.

- Another advantage gained by the paging schema is the OS only needs to store a page-to-page-frame mapping.
- The address lookup and translation is done by silicon - the hardware **Memory Management Unit (MMU)** within the CPU!
- The OS is responsible for creating and maintaining PTs for each process.
- The MMU is responsible for performing runtime address-translation (using the OS PTs).

### VM

Virtual Machines (VMs) are a key concept in system programming and virtualization technology. 

- **Software-Based Emulation:**
  A VM is essentially a software emulation of a physical computer. It provides an isolated environment in which a full operating system (known as the guest OS) can run as if it were on dedicated hardware.
- **Hypervisor Role:**
  The virtualization layer, called the hypervisor (or Virtual Machine Monitor, VMM), manages VMs. There are two types of hypervisors:
  - **Type 1 (Bare-Metal):** Runs directly on the host's hardware (e.g., VMware ESXi, Microsoft Hyper-V, Xen).
  - **Type 2 (Hosted):** Runs on top of a host operating system (e.g., VirtualBox, VMware Workstation).
- **Resource Virtualization:**
  The hypervisor virtualizes hardware components such as:
  - **CPU:** Each VM gets virtual CPUs that share the physical CPU resources.
  - **Memory:** VMs receive isolated memory spaces, often with mechanisms like paging or ballooning to manage physical memory efficiently.
  - **I/O Devices and Network:** Virtual devices emulate or paravirtualize disk, network, and other peripherals.
- **Interrupt Virtualization:**
  In a physical system, hardware interrupts signal the CPU to respond to events (like I/O requests). In a VM environment:
  - **Physical Interrupt Handling:** The hypervisor first receives the physical interrupts.
  - **Virtual Interrupt Injection:** It then translates and routes these interrupts as virtual interrupts to the appropriate guest OS.
    This extra layer ensures that each VM handles its own interrupts without interfering with others, though it can add some overhead.
- **Hardware Assistance:**
  Modern processors include virtualization extensions (like Intel VT-x and AMD-V) that help the hypervisor run guest operating systems more efficiently by reducing the performance penalties of virtualization.

### Benefits of VMs

At first glance, the sheer overhead introduced due to virtual memory and the associated address-translation would seem to warrant not using it.

The overhead is high, but the reality is:

- Modern hardware-acceleration (via TLBs/CPU caches/prefetching) mitigates this overhead and provides decent enough performance.
- The benefits one derives from VM outweigh the performance issues.

On a VM-based system, we get the following benefits:

- Process-isolation
- The programmer need not worry about physical memory
- Memory-region protection

## Process-isolation

- With virtual memory, every process runs inside a sandbox which is the extent of its VAS. It cannot look outside the box.