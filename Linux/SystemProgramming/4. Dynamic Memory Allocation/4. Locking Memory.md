# Locking memory

- On a virtual memory-based OS, such as Linux, a usermode page can be swapped at any point in time. The Linux kernel memory management code makes these decisions.
- To the regular application process, this should not matter.
  - Any time it attempts to access (read, write or execute) the page content, the kernel will page it back into RAM, and allow it to use it as though nothing had occurred.
  - This handling is generally called **servicing a page fault** and is completely transparent to the usermode application process.
- However, there are some situations where memory pages being paged - written from RAM to swap and vice-versa - is undesireable.
  - Realtime applications
  - Cryptography (security) applications
- Imagine that the **real-time process is executing a critical code path** and a data page has to be paged in from the swap partition at that moment, the latency introduced could ruin the application's characteristics, resulting in dismal failure.
  - In these cases, developers need a way to guarantee that said pages of memory can guaranteed to be resident in RAM, thus avoiding any page faulting.
- In some types of **security** applications, they would likely store some secrets in memory (a password, a key).
  - If the memory pages containing these are written out to disk (swap), there is always the possibility that it remains on disk well after the application exits, resulting in what;s called **information leakage**, which is a bug attackers are just waiting to pounce upon.
  - The need of the hour is to guarantee that those pages cannot be swapped out.

---

## `mlock(2)`

- The `mlock(2)` (`mlock2` and `mlockall`) system calls; the express purpose of these APIs is to lock memory pages withing the calling process's virtual address space.

```c
int mlock(const void *addr, size_t len);
```

- `addr` is a pointer to the (virtual) memory region to lock.
- `len` is the number of bytes to lock into RAM.

#### Code

```c
int main()
{
    size_t size = getpagesize();
    char *buffer = malloc(size);
    if (!buffer)
    {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    if (mlock(buffer, size) != 0)
    {
        perror("mlock");
        free(buffer);
        exit(EXIT_FAILURE);
    }

    printf("Memory locked.\n");

    // Unlock the memory before exit
    if (munlock(buffer, size) != 0)
    {
        perror("munlock");
    }

    free(buffer);
    return 0;
}
```

#### Output

```sh
chan@CMA:~/C_Programming/test$ make valgrind
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./final
==14862== Memcheck, a memory error detector
==14862== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==14862== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==14862== Command: ./final
==14862== 
Memory locked.
==14862== 
==14862== HEAP SUMMARY:
==14862==     in use at exit: 0 bytes in 0 blocks
==14862==   total heap usage: 2 allocs, 2 frees, 5,120 bytes allocated
==14862== 
==14862== All heap blocks were freed -- no leaks are possible
==14862== 
==14862== For lists of detected and suppressed errors, rerun with: -s
==14862== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

---

