# The malloc(3) API



```c
struct sbar
{
    int a[10], b[10];
    char buf[512];
} *psbar;

int main()
{
    psbar = malloc(sizeof(struct sbar));
    if (!psbar)
    {
        fprintf(stderr, "malloc failed\n");
        exit(1);
    }
    free(psbar);
    return 0;
}
```



- `ltrace` is used to display all library APIs in the process-execution path. Similarly, we can use `strace` to trace all system calls.

```sh
chan@CMA:~/C_Programming/test$ ltrace ./final
malloc(592)                                      = 0x5fa5e1e882a0
free(0x5fa5e1e882a0)                             = <void>
+++ exited (status 0) +++

```

- We cal clearly see `malloc(3)` (and the fact that the structure we used took up 592 bytes on an x86_64), and its return value.
- It's important to understand that the **content** of the memory chunk allocated by `malloc(3)` is considered to be random.
- This, it's the programmer's responsibility to initialize the memory before reading from it.
- If we fail to do so, it results in a bug called **Uninitialized Memory Read (UMR)**.
- `malloc(3)` always returns a memory region that is aligned on a 8-byte boundary.



## malloc(3) - some FAQs

1. How much memory can `malloc(3)` allocate with a single call?

   - The parameter to `malloc(3)` is an integer value of the `size_t` data type, so logically, the maximum number we can pass as a parameter to `malloc(3)` is the maximum value a `size_t` can take on the platform.

   - On a 64-bit Linux, `size_t` will be 8 bytes, which in bits is 8 * 8 = 64. 

   - Therefore, the maximum amount of memory that can be allocated in a single `malloc(3)` call is 2<sup>64</sup>.

   - The amount of memory that can be allocated is limited by the amount of free memory contiguously available on the heap.

2. What if I pass `malloc(3)` a negative argument?

   - The data type of the parameter to `malloc(3), size_t`, is an unsigned integer quantity - it cannot be negative.

     ```c
     num = qa * qb;
     ```

   - What if `num` is declared as a signed integer variable and `qa` and `qb` are large enough that the result of the multiplication operation causes an overflow?

   - The `num` result will then wrap around and become negative!

   - `malloc(3)` should fail. However, if the `num` variable is declared as `size_t`, the negative quantity will turn into some positive quantity.

3.  What if I use `malloc(0)`?

   - Depending on the implementation, `malloc(3)` will return NULL, or, a non-NULL pointer that can be passed to free.
   - Even if the pointer is non-NULL, there is no memory, so best not attempt to use it.

4. What if I use `malloc(2048)` and attempt to read/write beyond 2048 bytes?

   - This is a bug - an out-of-bounds memory access bug, further defined as a read or write buffer overflow.



## The free API

```c
void free(void *ptr);
```

- It accepts one parameter: the pointer to the memory chunk to be freed. `ptr` must be a pointer returned by one of the `malloc(3)` family routines: `malloc(3)`, `calloc` , or `realloc[array]`.
- Once a memory chunk is freed, we obviously cannot attempt to use any part of that memory chunk again; doing so will result in a bug or what's called **UB - undefined behavior**.
- Calling `free(ptr)` does not set `ptr` to `NULL`.



## The calloc API

- Almost identical to `malloc(3)`, differing in two main aspects:
  - It initializes the memory chunk it allocates to the zero value (that is, ASCII 0 or NULL, not number 0).
  - It accepts two parameters, not one.

```c
void *calloc(size_t nmemb, size_t size);
```

- `nmemb` is n members.
- `size` is the size of each member.
- `calloc(3)` allocates a memory chunk of (`nmemb * size`) bytes.
- So if we want to allocate memory for an array of 1000 integers, we can do like this:

```c
int *ptr;
ptr = calloc(1000, sizeof(int));
```

- Assuming the size of an integer is 4 bytes, we would have allocated a total of (1000 * 4) = 4000 bytes.
- Whenever we require memory for an array of items (a frequent use case in applications is an array of structures), `calloc` is a convenient way to both **allocate and simultaneously initialize the memory**.



## The realloc API

- Is used to resize an existing memory chunk to grow or shrink it.
- This resizing can only be performed on a piece of memory previously allocated with one of the `malloc(3)` family of APIs.

```c
void *realloc(void *ptr, size_t size);
```

- `ptr` is a pointer to a chunk of memory previously allocated with one of the `malloc(3)` family of APIs.
- `size` is the new size of the memory chunk.
- It can be larger or smaller than the original, thus growing and shrinking the memory chunk.

```c
int main()
{
    void *ptr, *newptr;
    ptr = calloc(100, sizeof(char));
    assert(ptr != NULL);
    newptr = realloc(ptr, 150);
    if (!newptr)
    {
        fprintf(stderr, "realloc failed!\n");
        free(ptr);
        exit(1);
    }
    free(newptr);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ make valgrind
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./final
==13936== Memcheck, a memory error detector
==13936== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==13936== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==13936== Command: ./final
==13936== 
==13936== 
==13936== HEAP SUMMARY:
==13936==     in use at exit: 0 bytes in 0 blocks
==13936==   total heap usage: 2 allocs, 2 frees, 250 bytes allocated
==13936== 
==13936== All heap blocks were freed -- no leaks are possible
==13936== 
==13936== For lists of detected and suppressed errors, rerun with: -s
==13936== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

- The pointer returned by `realloc` is the pointer to the newly resized chunk of memory.
- It may or may not be the same address as the original `ptr`.
- If it fails, the return value is NULL, and the original memory chunk is left untouched.
- The pointer returned by `realloc(3)`, `newptr`, is the one that must be subsequently freed, not the original pointer (`ptr`) to the (now resized) memory chunk.
- One should not attempt to free both pointers, as that to is a bug.



## The reallocarray API

- We allocate memory for an array using `calloc(3)`, later we want to resize it to be a lot larger.

```c
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500 * sizeof(struct sbar));
```

- There's easier way using `reallocarray(3)`.

```c
void *reallocarray(void *ptr, size_t nmemb, size_t size);
```

The code becomes simpler

```c
newptr = reallocarray(ptr, 500, sizeof(struct sbar));
```

- `reallocarray` has one real advantage over `realloc` - safety.
- Unlike `realloc()` call, `reallocarray()` fails safely in the case where the multiplication would overflow. If such an overflow occurs, `reallocarray()` returns NULL, sets `errno` to `ENOMEM`, and leaves the original block of memory unchanged.



## The program break

- When a process or thread wants memory, it invokes one of the dynamic memory routines - usually `malloc(3)` or `calloc(3)`; this memory is (usually) comes from the **heap segment**.
- The heap is a dynamic segment - it can grow toward higher virtual addresses.
- At any given point in time, the heap has an end point or top beyond which memory cannot be taken,
- This endpoint - the last legally reference-able location on the heap - is called the **program break**.