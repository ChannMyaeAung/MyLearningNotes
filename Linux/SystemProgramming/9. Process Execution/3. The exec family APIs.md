# The exec family APIs

- We have to include the header file `unistd.h`.
- The exec family of functions (such as execl, execv, execle, execve, and execvp) are used in system programming to replace the current process image with a new program.
- Unlike `fork()`, which creates a new process, an exec call completely replaces the current process with the specified program. This is especially useful for executing a different program within the same process context.

---

## Key Points

- **Process Replacement:**
  - When an exec function is called, the current process’s code, data, and stack are replaced. 
  - If successful, the new program starts execution from its main() function, and the original code does not resume.

- **Variants:**

  - **execl/execlp:** Accept a list of arguments.

  - **execv/execvp:** Accept an array (vector) of arguments.

  - **execle/execve:** Also allow us to specify an environment array.

  - The difference between functions ending in *p* and those that don’t is that the *p* variants search the PATH for the executable.

- **Underlying System Call:**
  - All exec functions eventually call execve(), the underlying system call provided by the kernel.

- **Error Handling:**
  - If an exec call fails, it returns -1 and sets errno, because on success the call never returns.

---

## `execl`

```c
int execl(const char *path, const char *arg, ...)
```

- The 1st parameter is the path name to the application we would like to execute.

- From the 2nd parameter onward, the `varargs`, the argument(s) to pass to the successor process are inclusive of `argv[0]`.

- How will the compiler know that we are done passing along arguments?

  - We must null terminate the argument list

    ```c
    execl(const char *pathname_to_successor_program, const char *argv0, const char *argv1, ..., const char *argvn, (char *) 0);
    ```

  - Now it makes sense why it's named `execl`. Of course it performs an `exec`. The last letter `l` implies long format. Each argument of the successor process is passed to it.

### Code Example

```c
#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <alloca.h>
#include <malloc.h>
#include <sys/capability.h>
#include "hello.h"

int main(int argc, char *argv[])
{
    if (argc < 2)
    {
        printf("Usage: %s <name>\n", argv[0]);
        return 1;
    }
    if (execl("/bin/uname", "uname", argv[1], (char *)0) == -1)
    {
        perror("execl");
        return 1;
    }
    printf("This should never get executed!\n");
    return 0;
}
```

- If we just attempt to null-terminate with a single `0`, the compiler complains, with a warning.
- To eliminate the warning, we must typecast the 0 with `(char *)`.
- We use a `printf()` to demonstrate that control will never reach it.
- Because either the `execl` succeeds; thus the successor process (`uname`) takes over.
- Or the `execl` fails; the perror  performs error reporting and terminates the predecessor.

```sh
chan@CMA:~/C_Programming/test$ ./final
Usage: ./final <name>
chan@CMA:~/C_Programming/test$ ./final -r
6.8.0-53-generic
chan@CMA:~/C_Programming/test$ ./final -a
Linux CMA 6.8.0-53-generic #55-Ubuntu SMP PREEMPT_DYNAMIC Fri Jan 17 15:37:52 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux
chan@CMA:~/C_Programming/test$ ./final -eww
uname: invalid option -- 'e'
Try 'uname --help' for more information.
```

- When we supply an argument (like "-r" or "-a"), that argument is passed directly to uname.
- Running with "-r" calls `/bin/uname -r`, which prints the kernel release.
- Running with "-a" calls `/bin/uname -a`, which prints all system information.
- Running an invalid option like "-eww" makes uname output its error message and suggestions.
- Since `execl()` replaces our process, the output we see comes directly from `uname`'s behavior.

---

## The `execlp` API

- The `p` implies that the environment variable `PATH` is searched for the program to execute.

```c
int execlp(const char *file, const char *arg, ...);
```

```sh
chan@CMA:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin

```

- The `PATH` environment variable consists of a set of colon-delimited (:) directories to search for the program file to run. The first match is the program that is executed.
- Thus, if we execute a process via the `execlp` , we need not give the absolute or full path name as the first parameter, but just the program name.

```c
execl("/bin/uname", "uname", argv[1], (char *)0);
execlp("uname", "uname", argv[1], (char *)0);
```

- With the `execl`, we have to specify the full path name to `uname`; with the `execlp`, we need not. The library routine will perform the work of looking up the PATH and figuring out the match to `uname`!

```sh
chan@CMA:~$ which uname
/usr/bin/uname
```

---

## The `execle` API

```c
int execle(const char *path, const char *arg, ..., char * const envp[]);
```

- `e` implies that we can pass along an array of environment variables to the successor process.