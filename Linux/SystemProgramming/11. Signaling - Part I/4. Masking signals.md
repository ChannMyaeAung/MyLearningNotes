# Masking signals

- Signal masking in Linux refers to the mechanism by which a process (or thread) can temporarily **block the delivery of specific signals**. 
- Each process has a signal mask—a set of signals that are currently blocked. 
- When a signal is masked, if it is generated, it remains pending and will not be delivered until it is unblocked. 
- **Useful** in critical sections of code where asynchronous signal handling might lead to inconsistencies or race conditions.
- We can modify a process's signal mask using system calls like `sigprocmask()` (or `pthread_sigmask()` in multi-threaded programs).
  - For example, before entering a critical section, a program might block certain signals, then restore the previous mask forward, ensuring that signals are only handled at safe points.

```c
int sigprocmask(int how, const sigset *set, sigset_t *oldset);
```

- The set is the new set of signals to mask, while `oldset` is actually a return value or the previous value of the signal mask.
- The `how` param determines the behavior and can take these values:
  - `SIG_BLOCK`, `SIG_UNBLOCK`, and `SIG_SETMASK`.

## Code

The following program illustrates how to block (mask) the SIGINT signal typically generated by Ctrl + C, wait for 10 seconds during which `SIGINT` remains blocked and then unmask it so that any pending `SIGINT` is delivered:

```c
#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <strings.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <alloca.h>
#include <malloc.h>
#include <fcntl.h>
#include <sys/capability.h>
#include <sys/wait.h>
#include <signal.h>
#include <errno.h>
#include "hello.h"

int main()
{
    sigset_t mask, oldmask;

    // initialize an empty signal set
    sigemptyset(&mask);

    // add SIGINT to the set
    sigaddset(&mask, SIGINT);

    // block SIGINT and save the current mask in oldmask
    if (sigprocmask(SIG_BLOCK, &mask, &oldmask) < 0)
    {
        perror("sigprocmask");
        exit(EXIT_FAILURE);
    }

    printf("SIGINT is blocked. Try pressing Ctrl + C now.\n");
    printf("Sleeping for 10 seconds...\n");

    printf("Now unblocking SIGINT. Any pending SIGINT will be delivered.\n");

    // Restore the old signal mask which unblocks SIGINT
    if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
    {
        perror("sigprocmask");
        exit(EXIT_FAILURE);
    }

    // sleep a bit to allow any pending SIGINT to be handled
    sleep(5);
    printf("Exiting program.\n");

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
SIGINT is blocked. Try pressing Ctrl + C now.
Sleeping for 10 seconds...
Now unblocking SIGINT. Any pending SIGINT will be delivered.
Exiting program.

```

- The program blocks `SIGINT` by adding it to the signal mask. While blocked, pressing Ctrl+C doesn’t immediately terminate the program.
- After 10 seconds (or when we pressed Ctrl+C during that time), the program unblocks `SIGINT`. At that point, if a `SIGINT` (Ctrl+C) was already pending, it is delivered.