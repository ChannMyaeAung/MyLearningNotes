# Common memory issues

- Incorrect memory accesses
  - Using uninitialized variables
  - Out-of-bounds memory accesses (read/ write underflow/ overflow bugs)
  - Use-after-free/ use-after-return (out-of-scope) bugs
  - Double-free
- Leakage
- Undefined behavior (UB)
- Data Races
- Fragmentation (internal implementation) issues
  - Internal
  - External



All these common memory issues (except fragmentation) are classified as UB.

## Accessing and/or using uninitialized variables

### Test case 1: Uninitialized memory access

- There are also known as **uninitialized memory reads (UMR)** bugs.

- Local (or automatic) variables are, by definition, uninitialized (unlike globals, which are always preset to zero).

```c
static void uninit_var()
{
    int x;

    if (x)
    {
        printf("true case: x=%d\n", x);
    }
    else
    {
        printf("false case\n");
    }
}

int main()
{
    uninit_var();
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ make all
Compiling the main file
clang -std=c23 -Wall -Wextra -g -D_XOPEN_SOURCE=700 -c main.c -o ./obj/main.o
main.c:20:9: warning: variable 'x' is uninitialized when used here [-Wuninitialized]
   20 |     if (x)
      |         ^
main.c:18:10: note: initialize the variable 'x' to silence this warning
   18 |     int x;
      |          ^
      |           = 0
1 warning generated.
Linking and producing the final application
clang -std=c23 -Wall -Wextra -g -D_XOPEN_SOURCE=700 ./obj/main.o -L./libs -lhello -o final -lssl -lcrypto -lpthread -lm
chan@CMA:~/C_Programming/test$ ./final
false case
```



## Out-of-bounds memory accesses

- **Write overflow**: A bug where a write is attempted into a memory buffer after its last legally accessible location
- **Write underflow**: A write is attempted into a memory buffer before its first legally accessible location
- **Read underflow**: A read is attempted on a memory buffer before its first legally accessible location
- **Read overflow**: A read is attempted on a memory buffer after its first legally accessible location.

## Test case 2

- Write of buffer overflow on compile-time allocated memory.

```c
static void write_overflow_compilemem(void)
{
    int i, arr[5], tmp[8];
    for (i = 0; i <= 5; i++)
    {
        arr[i] = 100; // Bug: 'arr' overfows on i == 5, overwriting part of the 'tmp' variable - a stack overflow
    }
}

int main()
{
    write_overflow_compilemem();
    return 0;
}
```

- This has caused a stack overflow (also referred to as a stack smashing or buffer overflow) bug.
- It's a serious class of vulnerability that attackers have successfully exploited many a time.

```sh
chan@CMA:~/C_Programming/test$ make all
Compiling the main file
clang -std=c23 -Wall -Wextra -g -D_XOPEN_SOURCE=700 -c main.c -o ./obj/main.o
main.c:18:20: warning: unused variable 'tmp' [-Wunused-variable]
   18 |     int i, arr[5], tmp[8];
      |                    ^~~
1 warning generated.
Linking and producing the final application
clang -std=c23 -Wall -Wextra -g -D_XOPEN_SOURCE=700 ./obj/main.o -L./libs -lhello -o final -lssl -lcrypto -lpthread -lm
chan@CMA:~/C_Programming/test$ ./final

```

- Very interestingly, compiling and running this portion of code shows that there is neither compile-time nor runtime detection of this dangerous bugs by default.
- These bugs are also sometimes called **off-by-one errors**.
- Our code writes out-of-bounds to a small array (arr[5]) which is undefined behavior and might not immediately crash. 
- In many cases, writing past an array boundary just corrupts adjacent memory (like tmp here) without triggering a crash. Also, modern compilers and runtime environments may not catch such overflow immediately.



## Test case 3

- Out-of-bounds: write overflow on dynamic memory

```c
static void write_overflow_dynmem(void)
{
    char *dest, src[] = "abcd56789";
    dest = malloc(8);
    if (!dest)
    {
        printf("malloc failed\n");
        return;
    }
    strcpy(dest, src);
    free(dest);
}

int main()
{
    write_overflow_dynmem();
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ make valgrind
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./final
==8349== Memcheck, a memory error detector
==8349== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==8349== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==8349== Command: ./final
==8349== 
==8349== Invalid write of size 1
==8349==    at 0x484F38C: strcpy (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==8349==    by 0x1091E6: write_overflow_dynmem (main.c:25)
==8349==    by 0x109183: main (main.c:31)
==8349==  Address 0x5129048 is 0 bytes after a block of size 8 alloc'd
==8349==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==8349==    by 0x1091B7: write_overflow_dynmem (main.c:19)
==8349==    by 0x109183: main (main.c:31)
==8349== 
==8349== Invalid write of size 1
==8349==    at 0x484F39E: strcpy (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==8349==    by 0x1091E6: write_overflow_dynmem (main.c:25)
==8349==    by 0x109183: main (main.c:31)
==8349==  Address 0x5129049 is 1 bytes after a block of size 8 alloc'd
==8349==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==8349==    by 0x1091B7: write_overflow_dynmem (main.c:19)
==8349==    by 0x109183: main (main.c:31)
==8349== 
==8349== 
==8349== HEAP SUMMARY:
==8349==     in use at exit: 0 bytes in 0 blocks
==8349==   total heap usage: 1 allocs, 1 frees, 8 bytes allocated
==8349== 
==8349== All heap blocks were freed -- no leaks are possible
==8349== 
==8349== For lists of detected and suppressed errors, rerun with: -s
==8349== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
```



## Test case 4

- Write Underflow Bug. We dynamically allocate a buffer with `malloc(3)`, decrement the pointer, and then write into that memory location.

```c
static void write_underflow(void)
{
    char *p = malloc(8);
    if (!p)
    {
        printf("malloc failed\n");
        return;
    }
    p--;
    strncpy(p, "abcd5678", 8);
    free(++p);
}

int main()
{
    write_underflow();
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final 4
double free or corruption (out)
Aborted (core dumped)

```



## Test case 5

- Read overflow on compile-time allocated memory.
- We attempt a read on a compile-time allocated memory buffer, after its last legally accessible location.

```c
static void read_overflow_compilemem(void)
{
    char arr[5], tmp[8];

    memset(arr, 'a', 5);
    memset(tmp, 't', 8);
    tmp[7] = '\0';

    printf("arr = %s\n", arr); // bug: read buffer overflow
}

int main()
{
    read_overflow_compilemem();
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final 2>&1 | grep -w 5
chan@CMA:~/C_Programming/test$ ./final 5
arr = aaaaa��(��

```

