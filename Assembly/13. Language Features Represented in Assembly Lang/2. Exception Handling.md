# Exception Handling 

- Exceptions can jump out of the normal function flow if a deep function throws an exception, it bypasses intervening calls until it finds a matching catch block.
- As the exception travels up through the call stack, each function gets a chance to clean up (like closing files or freeing memory) before handing off the exception.
- One simple method is to push the address of an exception handler onto the stack before calling a function. This way, if an exception occurs, the program knows where to jump back for cleanup and handling.
- Functions without explicit catch blocks will automatically pass the exception upward, executing any necessary cleanup along the way.
- If a function does catch the exception, it can perform its cleanup and then handle the error without further propagation.

---

## Code Example

```assembly
.section .data
msg_throw:
    .asciz "Deep function throwing exception\n"
msg_handler:
    .asciz "Exception caught\n"

.section .text
.globl _start
_start:
    # "Try" block: push handler address onto the stack
    lea catch(%rip), %rax    # load address of catch label
    push %rax                # push it as our exception handler
    jmp deep                 # jump to deep (avoid CALL so no return address is pushed)

deep:
    # Print the "throw" message.
    mov $1, %rdi             # stdout file descriptor
    lea msg_throw(%rip), %rsi  # message pointer
    mov $33, %rdx            # length of the message
    mov $1, %rax             # sys_write syscall number
    syscall

    # "Throw" the exception: pop the exception handler address and jump to it.
    pop %rax                 # pop the exception handler address
    jmp *%rax                # jump to the exception handler

catch:
    # "Catch" block: print the exception message.
    mov $1, %rdi             # stdout file descriptor
    lea msg_handler(%rip), %rsi  # address of the handler message
    mov $17, %rdx            # len of the message ("Exception caught\n")
    mov $1, %rax             # sys_write syscall number
    syscall
    jmp normal_exit          # jump to the normal exit routine               

normal_exit:
    mov $60, %rax           
    syscall
```

```sh
chan@CMA:~/C_Programming/Assembly$ as run.s -o run.o
chan@CMA:~/C_Programming/Assembly$ ld run.o -o run
chan@CMA:~/C_Programming/Assembly$ ./run
Deep function throwing exception
Exception caught
```



## A Simpler Exception Handling Code in ASM

```assembly
    .section .data
error_msg:
    .asciz "An error occurred.\n"

    .section .text
    .globl _start
_start:
    
    # "Try" block: perform an operation that might fail.
    # or illustration, we simulate an operation by setting a flag.
    mov $0, %rax       # assume our operation returns 0 on success
    # simulate an error condition by setting %rax != 0:
    mov $1, %rax

    # Check the result
    cmp $0, %rax
    jne .catch         # if not zero, an error occurred

    # Normal execution continues here.
    jmp .end

.catch:
    # "Catch" block: an error occurred.
    # Use sys_write to output error message.
    mov $1, %rdi           # stdout
    lea error_msg(%rip), %rsi
    mov $22, %rdx          # length of error_msg
    mov $1, %rax           # sys_write
    syscall

.end:
    mov $60, %rax         
    syscall
```

```sh
chan@CMA:~/C_Programming/Assembly$ as run.s -o run.o
chan@CMA:~/C_Programming/Assembly$ ld run.o -o run
chan@CMA:~/C_Programming/Assembly$ ./run
An error occurred.
```

