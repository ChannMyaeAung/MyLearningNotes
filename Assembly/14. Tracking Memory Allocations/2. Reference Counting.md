# Reference Counting

- Memory pools are nice, but the problem with them is that their usage is tied to fairly specific application styles and life cycles.
- A more general way to semiautomate memory management is with **reference counting**.
- Reference counting automatically tracks how many parts of a program are using a piece of memory by maintaining a counter (called the **reference count** or **refcount**) stored on the memory. 
  - When this counter reaches zero, the memory is deallocated.
- Every time a new reference is made to the memory (or a pointer is stored), the counter is incremented. 
- When a reference is removed (pointer reassigned or goes out of scope), the counter is decremented.
- **Overhead**: system adds runtime overhead since the counter must be updated and checked continuously.
- **Circular References Issue:** If two or more objects refer to each other (circular references), their counters may never drop to zero. Weak pointers can help break cycles, but they bring their own challenges.
- **Ownership Ambiguities:** Edge cases occur with object ownership. 
  - For example, deciding what the reference count should be when an object is returned from a function, and determining who is responsible for freeing it if the result is ignored.
- The programming languages most famous for reference counting are Objective-C and Swift.

---

## Code Example

`run.s`

```assembly
```

`run.c`

```c
```

```sh
```

