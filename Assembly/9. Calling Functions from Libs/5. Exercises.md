# Exercises

1. Modify one of the programs that prompt the user for input so that, after displaying the answer, it goes back and starts the process all over. Note that pressing Ctrl+C will terminate the program if you need to.

`factorialfunc.s`

```assembly
.section .note.GNU-stack, "", @progbits
.globl factorial
.section .text

# this is the offset into the stack frame (%rbp) that we store the number for which we are taking the factorial.
.equ LOCAL_NUM, -8

factorial:
    # we will reserve space for 1 variable - the value we were called with
    # aligned to 16 bytes
    enter $16, $0

    # if the arg is 1, then return the result as 1.
    # otherwise, continue 
    cmpq $1, %rdi
    jne continue

    # return 1
    movq $1, %rax
    leave 
    ret 

continue:
    # save the arg into our stack storage
    movq %rdi, LOCAL_NUM(%rbp)

    # call factorial with %rdi decreased by one
    decq %rdi
    call factorial 

    # the result will be in %rax. Multiply the result by our first arg we stored on the stack
    mulq LOCAL_NUM(%rbp)

    # result is in %rax which is what is needed for the return value

    leave 
    ret 
```

`test.s`

```assembly
.section .note.GNU-stack, "", @progbits
.globl main

.extern printf
.extern scanf

.section .data
prompt:         .asciz "Enter a number: "      # Prompt message
format_input:   .asciz "%d"                    # scanf format string
format_output:  .asciz "Factorial: %ld\n"        # printf format string (using %ld for a long)
input_value:    .long 0                        # Storage for the input number

.section .text
main:
    push %rbp
    mov %rsp, %rbp

.loop:
    # display the prompt
    lea prompt(%rip), %rdi
    call printf 

    # read an integer from stdin
    lea format_input(%rip), %rdi # 1st arg
    lea input_value(%rip), %rsi # 2nd arg : address to store input
    call scanf 

    # compute the factorial
    mov input_value(%rip), %rdi # move the input number into %rdi
    call factorial 

    # display the result
    lea format_output(%rip), %rdi # output format string
    mov %rax, %rsi # factorial result
    call printf 

    # loop back to prompt again
    jmp .loop
    pop %rbp
    ret 
```

```sh
chan@CMA:~/C_Programming/Assembly$ gcc test.s factorialfunc.s -o test
test.s: Assembler messages:
test.s:39: Warning: end of file not at end of a line; newline inserted
factorialfunc.s: Assembler messages:
factorialfunc.s:36: Warning: end of file not at end of a line; newline inserted
chan@CMA:~/C_Programming/Assembly$ ./test
Enter a number: 4
Factorial: 24
Enter a number: 5
Factorial: 120
Enter a number: 3
Factorial: 6
Enter a number: ^C
chan@CMA:~/C_Programming/Assembly$ 
```

---
