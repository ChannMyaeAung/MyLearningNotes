# Exercises

1. Write a program that adds two signed numbers. If the addition overflows, it should give back 1; otherwise, it should give back 0.

```assembly
.globl _start
.section .text
_start:
    # Load first signed number into %rax.
    movq $0x7FFFFFFFFFFFFFFF, %rax   # %rax = 0x7FFFFFFFFFFFFFFF (max positive 64-bit signed int)
    
    # Load second signed number into %rbx.
    movq $1, %rbx                    # %rbx = 1

    # Add %rbx to %rax. This addition should overflow.
    addq %rbx, %rax                  # Result is computed, and overflow flag (OF) is set if overflow occurs.
    
    # Use the 'seto' instruction to set AL to 1 if overflow occurred, 0 otherwise.
    seto %al                         # If OF==1 then AL becomes 1; else AL becomes 0.
    
    # Zero-extend AL to the full 64-bit register %rax.
    movzx %al, %rax                  # %rax now contains 0 or 1.

    # Move the result into %rdi as the exit code.
    movq %rax, %rdi                  # Exit code is now in %rdi.  
    movq $60, %rax                   
    syscall
```

```sh
chan@CMA:~/C_Programming/Assembly$ as test.s -o test.o
chan@CMA:~/C_Programming/Assembly$ ld test.o -o test
chan@CMA:~/C_Programming/Assembly$ ./test
chan@CMA:~/C_Programming/Assembly$ echo $?
1
```

**If we changed it to a number that won't overflow (3)**:

```assembly
movq $3,  %rax
...
```

```sh
chan@CMA:~/C_Programming/Assembly$ as test.s -o test.o
chan@CMA:~/C_Programming/Assembly$ ld test.o -o test
chan@CMA:~/C_Programming/Assembly$ ./test
chan@CMA:~/C_Programming/Assembly$ echo $?
0
```

---

2. Write a program that uses a combination of masks and rotates to count the number of 1s in a register.

```assembly
```

```sh
```

