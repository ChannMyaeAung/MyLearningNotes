# Writing a Simple Function

`exponentfunc.s`

```assembly
.globl exponent 
.type exponent, @function 

.section .text 
exponent:
    # %rdi has the base
    # %rsi has the exponent

    # Create the stack frame with one 8-byte local var which will be referred to using -8 (%rbp)
    # This will store the current value of the exponent as we iterate thru it
    # We are allocating 16 bytes so that we maintain 16-byte alignment
    enter $16, $0

    # Accumulated value in %rax
    movq $1, %rax

    # store the exponent
    movq %rsi, -8(%rbp)

mainloop:
    mulq %rdi
    decq -8(%rbp)
    jnz mainloop 

complete:
    # return the value in %rax
    leave
    ret

```

`runexponent.s`

```assembly
.globl _start 
.section .text
_start: 
    # call exponent with 3 and 2
    movq $3, %rdi
    movq $2, %rsi
    call exponent 

    # result is now in %rax
    movq %rax, %rdi
    movq $60, %rax
    syscall 
```



```sh
chan@CMA:~/C_Programming/Assembly$ as exponentfunc.s -o exponentfunc.o
chan@CMA:~/C_Programming/Assembly$ as runexponent.s -o runexponent.o
runexponent.s: Assembler messages:
runexponent.s:11: Warning: end of file not at end of a line; newline inserted
chan@CMA:~/C_Programming/Assembly$ ld exponentfunc.o runexponent.o -o runexponent
chan@CMA:~/C_Programming/Assembly$ ./runexponent
chan@CMA:~/C_Programming/Assembly$ echo $?
9
```

