# Is and As

- In Go’s error handling, **`errors.Is`** and **`errors.As`** let us inspect wrapped errors in a type-safe way. 
- Allow us to programmatically check an error's identity or type without needing to rely on fragile string comparisons of error messages.

---

## `errors.Is`

Use `errors.Is(err, target)` to ask “does `err` **equal** `target`, or wrap an instance of `target` anywhere in its chain?”

- **Equality** for non-wrapped errors is just `err == target`.
- For wrapped errors, Go calls `Unwrap()` on `err` repeatedly and checks each against `target`.

### Code Example #1

```go
package main

import (
	"errors"
	"fmt"
)

// a sentinel error we want to detect
var ErrNotFound = errors.New("not found")

// foo wraps ErrNotFound with extra context
func foo() error {
	return fmt.Errorf("foo failed: %w", ErrNotFound)
}

func main() {
	err := foo()

	// errors.Is returns true if err == ErrNotFound
	// or if any error in err's Unwrap chain == ErrNotFound
	if errors.Is(err, ErrNotFound) {
		fmt.Println("Detected ErrNotFound!")
	} else {
		fmt.Println("Some other error occurred:", err)
	}
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
hello.go
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./hello_world
Detected ErrNotFound!
```

### Code Example #2

```go
package main

import (
	"errors"
	"fmt"
	"os"
)

func fileChecker(name string) error {
	f, err := os.Open(name)
	if err != nil {
		return fmt.Errorf("in fileChecker: %w", err)
	}
	f.Close()
	return nil
}

func main() {
	err := fileChecker("xD.txt")
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			fmt.Println("File does not exist.")
		}
	}
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
hello.go
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./hello_world
File does not exist.
```

---

## `errors.As`

Use `errors.As(err, &targetPtr)` to ask “is there an error in this chain whose **type** matches the type of `targetPtr`?” If so, it sets `targetPtr` to that error value and returns `true`.

- We must pass a **pointer to a variable of the desired error type** (e.g. `*MyError`).
- Go will unwrap `err` and, for each layer, do a type assertion to see if it can convert it to the target type.

```go
package main

import (
	"errors"
	"fmt"
)

type MyError struct {
	Code int
	Err  error
}

func (e *MyError) Error() string {
	return fmt.Sprintf("code: %d: %v", e.Code, e.Err)
}

// Unwrap links MyError to its inner error
func (e *MyError) Unwrap() error {
	return e.Err
}

func bar() error {
	// wrap a sentinel inside our custom error
	return &MyError{
		Code: 404,
		Err:  errors.New("resource missing"),
	}
}

func main() {
	err := fmt.Errorf("outer context: %w", bar())

	// Create a variable of *MyError, then pass its address to errors.As
	var me *MyError
	if errors.As(err, &me) {
		// now `me` points to the *MyError instance inside err's chain
		fmt.Printf("Caught MyError with Code= %d\n", me.Code)
	} else {
		fmt.Println("Did not find a MyError in the chain")
	}
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
hello.go
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./hello_world
Caught MyError with Code= 404
```

---

