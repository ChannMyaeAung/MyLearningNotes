# Panic and Recover

- A panic is similar to an Error in other programming languages.
- It's a state generated by the Go runtime whenever it is unable to figure out what should happen next.
- As soon as panic happens, the current function exits immediately, and any `defers` attached to the current function start running.
  - When those defers complete, the defers attached to the calling function run, and so on until `main` is reached.
  - The program then exits with a message and a stack trace.
- If any situations in our programs are unrecoverable, we can create our own panics. 

```go
package main

import "os"

func doPanic(msg string) {
	panic(msg)
}

func main() {
	doPanic(os.Args[0])
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./hello_world
panic: ./hello_world

goroutine 1 [running]:
main.doPanic(...)
	/home/chan/Go_Programming/ch1/hello.go:6
main.main()
	/home/chan/Go_Programming/ch1/hello.go:10 +0x3a
```

- A panic prints out its message followed by a stack trace.

---

- Go provides a way to capture a panic to provide a more graceful shutdown or to prevent shutdown at all.
- The built-in `recover` function is called from within a `defer` to check whether a panic happened.
- If there was a panic, the value assigned to the panic is returned.
- Once a recover happens, execution continues normally.
- There's a specific pattern for using `recover`.
  - We register a function with `defer` to handle a potential panic. 
  - Call `recover` within an `if` statement and check whether a non-nil value was found. 
  - Must call `recover` from within a `defer` because once a panic happens, only deferred functions are run.

```go
package main

import "fmt"

func div60(i int) {
	defer func() {
		if v := recover(); v != nil {
			fmt.Println(v)
		}
	}()
	fmt.Println(60 / i)
}

func main() {
	for _, val := range []int{1, 2, 0, 6} {
		div60(val)
	}
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
hello.go
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./hello_world
60
30
runtime error: integer divide by zero
10
```

- Since `recover` uses a non-nil value to detect whether a panic happened, what happens if we call `panic(nil)` and there's a recover?.
  - A `panic(nil)` call is identical to `panic(new(runtime.PanicNilError))`.
  - `panic(nil)` + a `recover()` ends up *silently* swallowing the panic, but because the recovered value is nil there’s no way in our handler to distinguish “no panic happened” vs. “panic(nil) happened.”

---

