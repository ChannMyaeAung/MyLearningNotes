# Slices

- We can grow slices as needed. Because the length of a slice is not part of its type.
- This removes the biggest limitations of arrays and allows us to write  a single function that processes slices of any size.
- First thing: we don't specify the size of the slice when we declare it.

```go
// this creates a slice of three ints using a slice literal
var x = []int{10,20,30}

// we can also specify only the indices with non-zero values in the slice literal
var x = []int{1, 5:4, 6, 10: 100, 15}

// Multidimensional slices
var x [][]int
```

- Using `[...]` makes an array. Using `[]` makes a slice.
- A Slice is the first type that isn't comparable. 
  - It's a compile time error to use `==` to see if two slices are identical or `!=` to see if they are different.
- The only thing we can compare a slice with using `==` is `nil`:

```go
fmt.Println(x == nil) // prints true
```

---

**Note**: Since Go `1.21`, the `slices` package in the standard library includes two functions to compare slices.

- `slices.Equal` takes in two slices and returns true if the slices are the same length and all of the elements are equal.
  - It requires the elements of the slice to be comparable.
- `slices.EqualFunc` lets us pass in a function to determine equality and does not require the slice elements to be comparable.

```go
package main

import (
	"fmt"
	"slices"
)

func main() {
	x := []int{1, 2, 3, 4, 5}
	y := []int{1, 2, 3, 4, 5}
	z := []int{5, 6, 7, 8, 9}
	// s := []string{"a", "b", "c"}
	// fmt.Println(x == y) // does not compile
	fmt.Println(slices.Equal(x, y))
	fmt.Println(slices.Equal(x, z))
	// fmt.Println(slices.Equal(x, s)) // does not compile
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
go vet ./...
go build 
chan@CMA:~/Go_Programming/ch1$ ./hello_world
true
false
```

---

