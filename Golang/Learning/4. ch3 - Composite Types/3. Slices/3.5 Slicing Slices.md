# Slicing Slices

- When we take a slice from a slice, we are not making a copy of the data.
- Instead, we now have two variables that are sharing memory.
- Means that changes to an element in a slice effect all slices that share that element.

```go
package main

import (
	"fmt"
)

func main() {
	x := []string{"a", "b", "c", "d"}
	y := x[:2]
	z := x[1:]
	d := x[1:3]
	e := x[:]

	fmt.Println("x: ", x)
	fmt.Println("y: ", y)
	fmt.Println("z: ", z)
	fmt.Println("d: ", d)
	fmt.Println("e: ", e)

	// slices with overlapping storage
	fmt.Println("Slices with overlapping storage")
	x[1] = "y"
	y[0] = "x"
	z[1] = "z"
	fmt.Println("x: ", x)
	fmt.Println("y: ", y)
	fmt.Println("z: ", z)

}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
go vet ./...
go build 
chan@CMA:~/Go_Programming/ch1$ ./hello_world
x:  [a b c d]
y:  [a b]
z:  [b c d]
d:  [b c]
e:  [a b c d]
Slices with overlapping storage
x:  [x y z d]
y:  [x y]
z:  [y z d]
```

- Changing `x` modified both `y` and `z`, while changes to `y` and `z` modified `x`.

---

## `append` makes overlapping slices more confusing

```go
package main

import (
	"fmt"
)

func main() {
	x := []string{"a", "b", "c", "d"}
	y := x[:2]
	fmt.Printf("cap(x): %d, cap(y): %d\n", cap(x), cap(y))
	fmt.Println("y (before append): ", y)
	y = append(y, "z")
	fmt.Println("x: ", x)
	fmt.Println("y: ", y)
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
go vet ./...
go build 
chan@CMA:~/Go_Programming/ch1$ ./hello_world
cap(x): 4, cap(y): 4
y (before append):  [a b]
x:  [a b z d]
y:  [a b z]
```

- Whenever we take a slice from another slice, 
  - the subslice's capacity is set to the capacity of the original slice, minus the starting offset of the subslice within the original slice.
  - This means elements of the original slice beyond the end of the subslice, including unused capacity, are shared by both slices.
- Both have capacity 4, meaning `y` can grow to 4 elements without needing reallocation.
- Since `y` has available capacity, `"z"` is added to position 2 in the underlying array. This modifies the shared array, which is also used by `x`.
- `y` becomes `["a", "b", "z"]`
- `x` becomes `["a", "b", "z", "d"]` because `"z"` overwrote the value at index 2 ("c").