# Goroutines 

- A function that runs concurrently with other goroutines.
- A lightweight thread managed by the Go runtime. 
- We can spawn one with the `go` keyword.
- We can easily launch thousands; they consume ~2KB stack initially. 

## Code Example #1

```go
package main

import (
	"fmt"
	"time"
)

func work(id int) {
	fmt.Printf("worker %d starting\n", id)
	time.Sleep(time.Second)
	fmt.Printf("worker %d done\n", id)
}

func main() {
	for i := 1; i <= 3; i++ {
		go work(i) // each call runs in its own goroutine
	}
	time.Sleep(2 * time.Second) // wait for them to finish
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
main.go
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./main
worker 3 starting
worker 1 starting
worker 2 starting
worker 1 done
worker 2 done
worker 3 done
```

---

## Code Example #2

```go
package main

import (
	"fmt"
	"time"
)

func say(msg string) {
	fmt.Println(msg)
}

func main() {
	go say("hello")
	go say("world")
	time.Sleep(1 * time.Second)
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
main.go
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./main
world
hello
```

---

## Code Example #3

```go
package main

import (
	"fmt"
	"time"
)

func say(msg string) {
	for i := 0; i < 3; i++ {
		fmt.Println(msg)
		time.Sleep(100 * time.Millisecond)
	}
}

func main() {
	// Start a new goroutine
	go say("hello")

	// Current goroutine (main) continues
	say("world")

	// If main finishes, all other goroutines are terminated.
	// We'll add a sleep here for demonstration, but in real apps,
	// we'd use channels or sync.WaitGroup for synchronization.
	// time.Sleep(500 * time.Millisecond)
	fmt.Println("Done")
}
```

```sh
chan@CMA:~/Go_Programming/ch1$ make
go fmt ./...
go vet ./...
go build
chan@CMA:~/Go_Programming/ch1$ ./main
world
hello
world
hello
hello
world
Done
```

---

