# PostgreSQL MERGE Statement

- `MERGE` can look at our data and decide whether to add new records, update existing ones, or even delete records, all in a single command.
- **Update rows**: If a match is found and condition is true, it updates `column1` and `column2` in `target_table`.
- **Delete rows**: If a match is found but condition is false, it deletes the matching rows in `target_table`.
- **Insert rows**: If no match is found, it inserts new rows into `target_table` using values from `source_table`.
- The `RETURNING` clause provides details of the operation (`merge_action()`) and the affected rows.

```postgresql
MERGE INTO target_table
USING source_table
ON match_condition
WHEN MATCHED AND condition THEN 
	UPDATE SET column1 = value1, column2 = value2
WHEN MATCHED AND NOT condition THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT (column1, column2) VALUES (value1, value2)
RETURNING merge_action(), target_table.*;
```

---

## Example

```postgresql
DROP TABLE IF EXISTS PRODUCTS;

DROP TABLE IF EXISTS PRODUCT_UPDATES;

CREATE TABLE PRODUCTS (
	PRODUCT_ID SERIAL PRIMARY KEY,
	NAME TEXT UNIQUE,
	PRICE DECIMAL(10, 2),
	STOCK INTEGER,
	STATUS TEXT,
	LAST_UPDATED TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert some initial data
INSERT INTO
	PRODUCTS (NAME, PRICE, STOCK, STATUS)
VALUES
	('Laptop', 999.99, 50, 'active'),
	('Keyboard', 79.99, 100, 'active'),
	('Mouse', 29.99, 200, 'active');

-- Create a table for our updates
CREATE TABLE PRODUCT_UPDATES (
	NAME TEXT,
	PRICE DECIMAL(10, 2),
	STOCK INTEGER,
	STATUS TEXT
);

-- Insert mixed update data (new products, updates, and discontinuations)
INSERT INTO
	PRODUCT_UPDATES
VALUES
	('Laptop', 1099.99, 75, 'active'),
	('Monitor', 299.99, 30, 'active'),
	('Keyboard', NULL, 0, 'discontinued'),
	('Headphones', 89.99, 50, 'active');

SELECT * FROM PRODUCTS;
SELECT * FROM PRODUCT_UPDATES;
```

![MERGE_Result](Imgs\MERGE_Result.png)



```postgresql
MERGE INTO PRODUCTS P USING PRODUCT_UPDATES U ON P.NAME = U.NAME WHEN MATCHED
AND U.STATUS = 'discontinued' THEN DELETE WHEN MATCHED
AND U.STATUS = 'active' THEN
UPDATE
SET
	PRICE = COALESCE(U.PRICE, P.PRICE),
	STOCK = U.STOCK,
	STATUS = U.STATUS,
	LAST_UPDATED = CURRENT_TIMESTAMP WHEN NOT MATCHED
	AND U.STATUS = 'active' THEN INSERT (NAME, PRICE, STOCK, STATUS)
VALUES
	(U.NAME, U.PRICE, U.STOCK, U.STATUS)
RETURNING
	MERGE_ACTION () AS ACTION,
	P.PRODUCT_ID,
	P.NAME,
	P.PRICE,
	P.STOCK,
	P.STATUS,
	P.LAST_UPDATED;
```

![MERGE_Result_2](Imgs\MERGE_Result_2.png)

```postgresql
SELECT * FROM products
ORDER BY product_id;
```

![MERGE_Result_3](Imgs\MERGE_Result_3.png)

---

## Advanced Usage with Conditions

```postgresql
MERGE INTO PRODUCTS P USING (
	SELECT
		NAME,
		PRICE,
		STOCK,
		STATUS,
		CASE
			WHEN PRICE IS NULL
			AND STATUS = 'discontinued' THEN 'DELETE'
			WHEN STOCK = 0 THEN 'OUT_OF_STOCK'
			ELSE STATUS
		END AS ACTION_TYPE
	FROM
		PRODUCT_UPDATES
) U ON P.NAME = U.NAME WHEN MATCHED
AND U.ACTION_TYPE = 'DELETE' THEN DELETE WHEN MATCHED
AND U.ACTION_TYPE = 'OUT_OF_STOCK' THEN
UPDATE
SET
	STATUS = 'inactive',
	STOCK = 0,
	LAST_UPDATED = CURRENT_TIMESTAMP WHEN MATCHED THEN
UPDATE
SET
	PRICE = COALESCE(U.PRICE, P.PRICE),
	STOCK = U.STOCK,
	STATUS = U.STATUS,
	LAST_UPDATED = CURRENT_TIMESTAMP WHEN NOT MATCHED
	AND U.ACTION_TYPE != 'DELETE' THEN INSERT (NAME, PRICE, STOCK, STATUS)
VALUES
	(U.NAME, U.PRICE, U.STOCK, U.STATUS)
RETURNING
	MERGE_ACTION () AS ACTION,
	P.*,
	U.ACTION_TYPE;
```

![MERGE_Result_4](Imgs\MERGE_Result_4.png)