## Password generators

### Exercise 6.1

Write a program that brute-force guesses the password "password". Have your code spin through all the letter combinations "aaaaaaaa"  through "zzzzzzzz" until it matches "password".

```C
#include <stdio.h>

/* This function rolls over the digits in the array from 'a' to 'z'. When 'z' is encountered, the column shift back to 'a', but the function is recursively called to the next position left, which is -1 element in the array. A check is made to ensure that the function doesn't attempt to modify array elements < 0. Argument 'c' is the char array. Argument 'pos' is the element position, highest first*/

int flip(char *c, int pos){
    *(c+pos) = *(c+pos) + 1; // increment the letter
    if(*(c+pos) > 'z'){
        *(c+pos) = 'a'; //reset back to a
        if(pos != 0){ // watch the overflow
            if(!flip(c, pos-1)){ // flip the next column's digit
                return 0; // echo down the FALSE return
            }
        }else{
            return 0; // last column, FALSE return
        }
    }
    
    // keep looping
    return 1;
}

int main(){
    char password[] = "password"; // password to guess
    char guess[] = "aaaaaaaa"; // initialized to make it easier
    char *p, *g;
    
    printf("Password cracking...\n");
    
    // do while loop so that the first iteration of guess[] isn't skipped
    do{
        // perform the comparison and exit if true
        // casue strcmp() is slow
        p = password;
        g = guess;
        while(*p){
            // compare each letter
            if(*p == *g){
                p++;
                g++;
            }else{
                break;
            }
            
            // if both characters are null here, the strings match.
            if(*p == '\0' && *g == '\0'){
                printf("Found password '%s'\n", guess);
                break;
            }
    }while(flip(guess, 7));
     return 0;
}


```



### Building a silly random password program

```C
int main()
{
    int x;
    char ch;

    // Makes the password 10 characters long
    const int length = 10;

    srand((unsigned) time(NULL));

    for(x = 0; x < length; x++){
        // Set the range of random values to printable characters
        ch = rand() % ('~' - '!' + 1);
        putchar(ch + '!');
    }
    putchar('\n');
    
    return 0;
}
```

- ```C
  srand((unsigned) time(NULL));
  ```

  - **Purpose**: This line seeds the random number generator used by `rand()`.
  - **Explanation:**
    - `time(NULL)`: Returns the current calendar time as a `time_t` object. If the argument is `NULL`, it returns the current time.
    - `(unsigned)`: Casts the `time_t` value to an `unsigned` integer.
    - `srand()`: Seeds the random number generator with the given seed value. By using the current time, it ensures that the sequence of random numbers generated by `rand()` will be different each time the program runs.

- ```C
  ch = rand() % ('~' - '!' + 1);
  ```

  - **Purpose**: This line generates a random printable ASCII character.
  - **Explanation:**
    - `rand()`: Generates a random integer.
    - `('~' - '!' + 1)` : Calculates the range of printable ASCII characters.
      - `'~'` is the ASCII value for the tilde character (`126`).
      - `'!'` is the ASCII value for the exclamation mark (`33`).
      - The range of printable characters is from `33` to `126`, inclusive. Therefore, the total number of printable characters is `126 - 33 + 1 = 94`.
    - `rand() % 94`: Generates a random integer between `0` and `93` (inclusive).
    - `ch = rand() % 94`: Assigns this random integer to the variable `ch`.

- ```C
  putchar(ch + '!');
  ```

  - **Purpose**: This line converts the random integer to a printable ASCII character and prints it.
  - **Explanation:**
    - `ch + '!'` : Adds the ASCII value of the exclamation mark (`33`) to the random integer `ch`.
      - Since `ch`is a random integer between `0` and `93`, adding `33` shifts it to the range of printable ASCII characters (`33` to `126`).
    - `putchar()`: Prints the resulting character to the standard output.

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
RSvz2YN*VG
```

### Adding conditions to the password program

To improve the silly password program and make it smarter, consider limiting the password's content to the following:

- One uppercase letter
- Six lowercase letters
- One number
- Two symbols

The total number of characters is 10, which is good for a password.

Symbols list : 

```
! @ # $ % * _ -
```

**Exercise 6.2**

Write code that generates a random password limited to the characters listed in this section.

#### Solution #1

```C
#define UPPER 1
#define LOWER 6
#define NUM 1
#define SYM 2

char uppercase(void){
    // Random number between 0 and 25, mapped to 'A' to 'Z'
    return (rand() % 26 + 'A');
}

char lowercase(void){
    // Random number between 0 and 25, mapped to 'a' to 'z'
    return (rand() % 26 + 'a');
}

char number(void){
    // Random number between 0 and 9, mapped to '0' to '9'
    return (rand() % 10 + '0');
}

char symbol(void){
    char s[8] = "!@#$%*_-";
    int r;
    r = rand() % 8;
    return s[r];
}

int main(){
    int x;
    
    // seeds the random number generator with the current time to ensure different sequences of random numbers in each run.
    srand((unsigned) time(NULL));
    
    for(x = 0; x < UPPER; x++){
        putchar(uppercase());
    }
    
    for(x = 0; x < LOWER; x++){
        putchar(lowercase());
    }
    
    for(x = 0; x < NUM; x++){
        putchar(number());
    }
    
    for(x = 0; x < SYM; x++){
        putchar(symbol());
    }
    
    putchar('\n');
    
    return 0;
}
```

- `uppercase()`: Generates a random uppercase letter by mapping a random number between 0 and 25 to the ASCII values of 'A' to 'Z'.
- `lowercase()`: Generates a random lowercase letter by mapping a random number between 0 and 25 to the ASCII values of 'a' to 'z'.
- `number()`: Generates a random digit by mapping a random number between 0 and 9 to the ASCII values of '0' to '9'.
- `symbol()`: Generates a random symbol from a predefined set of symbols.

**Alternative Lowercase function (Work the same way)**

```C
char lowercase(){
    char ch;
    // Calls the uppercase() function to generate a random uppercase letter and assigns it to ch.
    ch = uppercase();
   
    return (ch |= 0x20);
}
```

- The bitwise OR assignment operator (`|=`) is used to set the 6th bit of the ASCII value of `ch`.

- In ASCII, the difference between uppercase and lowercase letters is the 6th bit. For example:
  - 'A' (uppercase) has an ASCII value of 65 (`01000001` in binary).
  - 'a' (lowercase) has an ASCII value of 97 (`01100001` in binary).
- By setting the 6th bit, we convert the uppercase letter to its corresponding lowercase letter.
- `0x20` is the hexadecimal representation of the binary value `00100000`.
- `ch |= 0x20` sets the 6th bit of `ch` to 1, effectively converting it to lowercase.
- The function then returns the modified `ch`.

### Example

Let's see an example with the letter 'A':

1. **Uppercase 'A'**:
   - ASCII value: 65
   - Binary: `01000001`
2. **Bitwise OR with `0x20`**:
   - `0x20` in binary: `00100000`
   - `01000001` (65) OR `00100000` (32) = `01100001` (97)
3. **Result**:
   - ASCII value: 97
   - Character: 'a' (lowercase)

### Example

Let's see an example with the letter 'A':

1. **Uppercase 'A'**:
   - ASCII value: 65
   - Binary: `01000001`
2. **Bitwise OR with `0x20`**:
   - `0x20` in binary: `00100000`
   - `01000001` (65) OR `00100000` (32) = `01100001` (97)
3. **Result**:
   - ASCII value: 97
   - Character: 'a' (lowercase)

**Output**

```sh
chan@CMA:~/C_Programming/test$ ./final
Qengxvq6-*
chan@CMA:~/C_Programming/test$ ./final
Zwznnux9$@
```



#### Solution #2

`hello.c`

```C
void generate_password(){
    char uppercase[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";  // Uppercase letters
    char lowercase[] = "abcdefghijklmnopqrstuvwxyz";  // Lowercase letters
    char digits[] = "0123456789";                     // Digits
    char symbols[] = "!@#$%*_-";
    
    // 1 uppercase, 6 lowercase, 1 digit, 2 symbols (total: 10 characters)
    char password[11];
    
    // Seed the random number generator
    srand(time(NULL));
    
    // Select one random uppercase letter
    password[0] = uppercase[rand() % 26];
    
    // Select six random lowercase letter
    for(i = 1; i <= 6; i++){
        password[i] = lowercase[rand() % 26];
    }
    
    // Select one random digit
    password[7] = digits[rand() % 10];
    
    // Select two random symbols
    password[8] = symbols[rand() % 8];
    password[9] = symbols[rand() % 8];
    
    password[10] = '\0';
    
    printf("Generated password: %s\n", password);
 }
```

`hello.h`

```C
void generate_password();
```



`main.c`

```C
int main(){
    generate_pasword();
    return 0;
}
```



**Output**

```sh
chan@CMA:~/C_Programming/test$ ./final
Generated password: Xsjzgdu4!!
chan@CMA:~/C_Programming/test$ ./final
Generated password: Pwyliha8!-
chan@CMA:~/C_Programming/test$ ./final
Generated password: Lobshhz5-*

```

#### Improving upon the password

- The password pattern of the previous password generating program is predictable.
- A better way to output the random characters is to scramble them.
- For this improvement, the password must be stored in an array as opposed to output directly.

`hello.h`

```C
enum
{
    ERROR_CODE = -1,
    UPPER = 1,
    LOWER = 6,
    NUM = 1,
    SYM = 2,
};

char uppercase(void);
char lowercase(void);
char numbers(void);
char symbols(void);
void scramble(char p[]);

```



`hello.c`

```C
#include "hello.h"

char uppercase(void){
    return (rand() % 26 + 'A');
}
char lowercase(void){
    char ch;
    ch = uppercase();
    return (ch |= 0x20);
}
char numbers(void){
    return (rand() % 10 + '0');
}
char symbols(void){
    char s[8] = "!@#$%*_-";
    int r;
    r = rand() % 8;
    return s[r];
}

void scramble(char p[]){

    // calculates the buffer size
    const int size = UPPER+LOWER+NUM+SYM+1;
    
    // key[] to determine which characters need to be randomized.
    char key[size];
    int x, r;

    // Initialize the array with null characters
    for(x = 0; x < size; x++){
        key[x] = '\0';
    }

    x = 0;
    // Loops until the passed array has been fully processed (minus one for the null character)
    while(x <size - 1){
        // Generate a random value, 0 thru the buffer size 
        r = rand() % (size - 1);

        // Check if position is empty
        // If the random value at element r is a null character, meaning it's unassigned
        if(!key[r]){

            // it copies the original character to its new, random position.
            // places the characters from p[x] into the random position key[r].
            key[r] = p[x];
            
            // Moves to the next character
            x++;
        }
    }


    // Copy the randomized array into the passed array
    for(x=0; x < size; x++){
        p[x] = key[x];
    }
}
```



`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <time.h>
#include <signal.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <pthread.h>
#include <ctype.h>
#include <stdbool.h>
#include "hello.h"

int main()
{
    // Necessary storage for the password, plus one for the null character
    char password[UPPER+LOWER+NUM+SYM+1];
    int x;
	
    // Seeds the randomizer
    srand((unsigned)time(NULL));
	
    x = 0;
    while(x < UPPER){
        password[x++] = uppercase();
    }
    while(x < UPPER+LOWER){
        password[x++] = lowercase();
    }
    while(x < UPPER+LOWER+NUM){
        password[x++] = numbers();
    }
    while(x < UPPER+LOWER+NUM+SYM){
        password[x++] = symbols();
    }

    password[x] = '\0';

    printf("%s\n", password);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
Yrhxsdb1-$
chan@CMA:~/C_Programming/test$ ./final
Jkjqpxv5!*
```

##### Explanation

- The program's output is unchanged, but this incremental step stores the password.

- With the password stored in a buffer, it can be passed to a new function, `scramble()` which randomizes the characters in the buffer.

  - **Purpose**: The function shuffles the characters in the input array `p[]` so that they appear in random order.
  - Mechanism:
    - Uses a temporary array `key[]` to store characters at random positions.
    - Random indices are generated using `rand() % (size - 1)`.
    - The function ensures that each character is placed in a unique position by checking if `key[r]` is empty.
  - **Result**: After the function executes, `p[]` contains the same characters as before but in a randomized order.

  ### Example

  Suppose `p[]` contains the characters: `{'A', 'b', '3', '@', '\0'}`.

  1. **Before Scrambling**:

     ```
     Index: 0 1 2 3 4
     p[]     : A b 3 @ \0
     ```

  2. **Scrambling Process**:

     - Randomly assigns each character to a position in `key[]`.
     - For example:
       - `key[2] = 'A'`
       - `key[0] = 'b'`
       - `key[3] = '3'`
       - `key[1] = '@'`

  3. **After Scrambling**:

     ```
     Index: 0 1 2 3 4
     
     key[]: b @ A 3 \0
     ```

  4. **Copy Back to `p[]`**:

     - `p[]` now contains: `{'b', '@', 'A', '3', '\0'}`.

  ##### Important Notes

  - **Randomness**: The function relies on the `rand()` function to generate random indices. Ensure that the random number generator is properly seeded using `srand()` in your `main()` function.
  - **Null Terminator**: The `size` calculation includes an extra character for the null terminator `'\0'`, which signifies the end of the string.
  - **No Repeats**: By checking if `key[r]` is empty before assigning, the function prevents overwriting characters and ensures all positions are filled exactly once.

  Now if we add our scramble() function to our main function just before the printf() statement:

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <time.h>
#include <signal.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <pthread.h>
#include <ctype.h>
#include <stdbool.h>
#include "hello.h"

int main()
{
    // Necessary storage for the password, plus one for the null character
    char password[UPPER + LOWER + NUM + SYM + 1];
    int x;

    srand((unsigned)time(NULL));

    x = 0;
    while (x < UPPER)
    {
        password[x++] = uppercase();
    }
    while (x < UPPER + LOWER)
    {
        password[x++] = lowercase();
    }
    while (x < UPPER + LOWER + NUM)
    {
        password[x++] = numbers();
    }
    while (x < UPPER + LOWER + NUM + SYM)
    {
        password[x++] = symbols();
    }

    password[x] = '\0';

    scramble(password);

    printf("%s\n", password);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
g_fiu$wCo9
chan@CMA:~/C_Programming/test$ ./final
3*Wxievkg%
```

Now it is blessedly randomized.

#### Generating random words, Mad Libs style

- To build a random word password generator, we need a routine that spits out random words.
- If they're to be legitimate words, we most likely need some type of list from which to extract the words.
- Writing a word-generating function is a good approach, plus it gives us an opportunity to create a list of words we like.

`hello.h`

```C
const char *add_word(void);
```

`hello.c`

```C
#include <stdlib.h>
#include "hello.h"

const char *add_word(void){
    const char *vocabulary[] = {
        "orange", "grape", "apple", "banana",
        "coffee", "tea", "juice", "beverage",
        "happy", "grumpy", "bashful", "sleepy"};
	
    int r;
    
    // Generate a random value, zero thru the number of elements in the array (minus one)
    r = rand() % (sizeof(vocabulary) / sizeof(char *));
    
    // Returns the random element - the word
    return vocabulary[r];
}
```

`main.c`

```C
// This macro makes the for loop more readable in the main() function
#define repeat(a) for(int x = 0; x < a; x++)

int main(){
    srand((unsigned)time(NULL));
    
    // Outputs three random words
    repeat(3){
        printf("%s ", add_word());
    }
    putchar('\n');
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
sleepy apple sleepy 
chan@CMA:~/C_Programming/test$ ./final
grumpy orange sleepy 
```



#### Mad Libs Style

Mad Libs style is a fun word game format where players fill in blanks with specific types of words (like nouns, adjectives, or verbs) to complete a story without knowing the context. Once all the blanks are filled in, the story is read back, often resulting in funny or absurd sentences because the chosen words rarely fit the narrative in a conventional way.

Here’s how it works:

1. A template story is created with blanks labeled by word types, like **[noun]**, **[adjective]**, or **[verb]**.
2. Players are prompted to fill in each blank with a word matching the specified type, without seeing the full story.
3. After all the blanks are filled, the complete story is revealed, often resulting in hilarious or nonsensical outcomes.

**Example:**

Template:

> "The [adjective] cat jumped over the [noun] and started to [verb] loudly."

Filled in:

> "The *spiky* cat jumped over the *pineapple* and started to *dance* loudly."

Mad Libs is commonly used as a fun party activity, educational tool, or writing exercise to spark creativity and encourage understanding of parts of speech.



The first step in coding a Mad Libs program is crafting several functions along the lines of `add_word()` . 

- We must write one function for each word category as found in a Mad Libs: `add_noun()`, `add_verb()`, and `add_adjective()`.
- Each function is populated with its own `vocabulary[]` array, packed with the corresponding word types: nouns, verbs and adjectives.
- The `main()` function calls each function as required to fill in the blanks for a Mad Libs-like sentence.

`hello.h`

```C
const char *add_noun(void);
const char *add_verb(void);
const char *add_adjective(void);
```



`hello.c`

```C
#include <stdlib.h>
#include "hello.h"

const char *add_noun(void)
{
    const char *vocabulary[] = {
        "couch", "dog", "tree", "eyeball",
        "banana", "necklace", "house", "car",
        "computer", "mountain", "cup", "hair"};
    int r;

    // Generates a random value, zero thru the number of elements in the array (minus one)
    r = rand() % (sizeof(vocabulary) / sizeof(char *));

    // Returns the random element - the word
    return vocabulary[r];
}

const char *add_verb(void)
{
    const char *vocabulary[] = {
        "run", "eat", "burp", "sneeze",
        "cut", "yodel", "cook", "slice"};
    int r;

    r = rand() % (sizeof(vocabulary) / sizeof(char *));
    return vocabulary[r];
}
const char *add_adjective(void)
{
    const char *vocabulary[] = {
        "loud", "big", "soft", "crunchy",
        "smelly", "great", "blue", "tiny",
        "ripe", "hairy"};
    int r;

    r = rand() % (sizeof(vocabulary) / sizeof(char *));

    return vocabulary[r];
}
```



`main.c`

```C
int main(){
    srand((unsigned) time(NULL));
    
    printf("Will you please take the %s %s ", add_adjective(), add_noun());
    printf("and %s the %s?\n", add_verb(), add_noun());
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Will you please take the tiny computer and cook and couch?

chan@CMA:~/C_Programming/test$ ./final
Will you please take the tiny mountain and slice and house?
```



One way to add a richer variety of words to the various functions is to take the code a step further and read words from a vocabulary text file.

`nouns.txt`

```
couch
dog
tree
eyeball
banana
necklace
house
car
computer
mountain
cup
hair
girl
teeth
flagpole
table
mummy
motorcycle
log
Godzilla
```

`adjectives.txt`

```
loud
big
soft
crunchy
smelly
great
blue
tiny
ripe
hairy
pretty
ugly
tall
short
fat
skinny
great
busy
slow
sexy
hungry
rich
poor
```

`verbs.txt`

```
run
eat
burp
sneeze
cut
yodel
cook
slice
pinch
torture
beg
cough
laugh
fly
climb
kick
yell
punch
fight
sit
play
```

- These three separate files will be scanned for random words.

`hello.h`

```C
enum{
    BSIZE = 32,
};

struct term{
    char filename[16];  // A string representing the filename to open
    
    FILE *fp;  // A FILE pointer referencing the open file listed in the filename member
    
    int items;  // The total number of words extracted from the file
    
    char *list_base;  // A block of memory containing pointers referencing each word extracted from the file
}

// arg passed as a pointer to allow the function to modify the struct's members and have the updated data retained.
void build_vocabulary(struct term *t);

// The function doesn't require a pointer as an arg because it doesn't modify the struct's content
char *add_word(struct term t);
```

- If we don't pass `struct term *t` pointer as an argument to the function `build_vocabulary`, any changes are abandoned when the function terminates.
- Because a pointer is passed, structure pointer notation `->` is used within the function.



`hello.c`

**Purpose**: Reads words from a file and stores them in the `list_base` array of the `struct term`.

**Process** of `build_vocabulary(struct term *t)`:

- **Opening the File**:
  - Attempts to open the file specified by `t->filename`.
  - If the file cannot be opened, it prints an error message and exits.
- **Initializing the List**:
  - Allocates initial memory for `t->list_base` to hold pointers to strings (words).
  - Checks if the memory allocation was successful.
- **Reading Words**:
  - Uses a loop to read each line from the file using `fgets`.
  - Allocates memory for each word and copies it into the allocated space.
  - Removes the newline character at the end of each word. This step is required to ensure that the word returned doesn't contain a newline.
  - Stores the pointer to the word in `t->list_base` and increments `t->items`.
  - Confirms that  the `t->list_base` buffer isn't full. If the list becomes full, it reallocates more memory to accommodate additional words.
- **Closing the File**:
  - After all words are read, it closes the file.

```C
void build_vocabulary(struct term *t){
    char buffer[BSIZE]; // Buffer to store each line from the file
    char *r, *entry;
    
    t->fp = fopen(t->filename, "r");
    if(t->fp == NULL){
        fprintf(stderr, "Unable to open file %s\n", t->filename);
        exit(1);
    }
    
    // Allocate initial memory for the list of words
    t->list_base = malloc(sizeof(char *) * 100);
    if(t->list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    t->items = 0;
    
    // Read words from the file until the end is reached
    while(!feof(t->fp)){
        r = fgets(buffer, BSIZE, t->fp);
        if(r == NULL){
            break;
        }
        
        // Allocate memory for the word.
        entry = malloc(sizeof(char) * strlen(buffer) + 1);
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        // Copy the word from the buffer into the allocated space "entry".
        strcpy(entry, buffer);
        r = entry;
        
        // Remove the newline character at the end of the word
        while(*r){
            if(*r == '\n'){
                *r = '\0';
                break;
            }
            r++;
        }
        
        // Add the word to the list
        *(t->list_base + t->items) = entry;
        // increment the word count
        t->items++;
        
        // If the list reaches its current capacity, reallocate more memory
        if(t->items % 100 == 0){
            t->list_base = realloc(t->list_base, sizeof(char *)*(t->items + 100));
            if(t->list_base == NULL){
                fprintf(stderr, "Unable to allocate memory\n");
                exit(1);
            }
        }
    }
    fclose(t->fp);
}

/* Purpose: Select a random word from the vocabulary stored in t.list_base */
char *add_word(struct term t){
    int word;
    
    // Generates a random index within the range of 0 to t.items - 1
    word = rand() % t.items;
    return *(t.list_base + word); // Returns the word at that index from t.list_base
}
```

- At the end of the function, the `items` member of the struct (`t.items`) contains **a count of all the words read from the file**.
- The `list_base` member contains **the addresses for each string stored in memory.**



`main.c`

```C
int main(){
    struct term noun = {"nouns.txt", NULL, 0, NULL};
    struct term verb = {"verbs.txt", NULL, 0, NULL};
    struct term adjectives = {"adjectives.txt", NULL, 0, NULL};
    
    // Build vocabularies by reading words from files
    build_vocabulary(&noun);
    build_vocabulary(&verb);
    build_vocabulary(&adjectives);
    
    srand((unsigned)time(NULL));
    
    printf("Will you please take the %s %s ", add_word(adjective), add_word(noun));
    
    printf("and %s the %s?\n", add_word(verb), add_word(noun));
    
    return 0;
}
```



`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Will you please take the hungry log and fight the Godzilla?

chan@CMA:~/C_Programming/test$ ./final
Will you please take the blue table and cough the mummy?

chan@CMA:~/C_Programming/test$ ./final
Will you please take the pretty necklace and sit the tree?

```



### Building a random word password generator

- We can craft two different types of random word password programs based on the two versions of the Mad Libs programs.
- The first program uses arrays to store a series of random words. 
- For more variety, however, we can use the second code to take advantage of files that store our favorite password words.



`hello.h`

```C
char *number(void);
char *symbol(void);
char *add_word(void);
```

`hello.c`

```C
char *number(void){
    // The static array's contents are retained when the function terminates
    static char n[2];
    n[1] = rand() % 10 + '0'; // Generate a random character, 0 thru 9, storing it as the first element of array n[]
    
    n[1] = '\0';
    return n;
}

char *symbol(void){
    char sym[8] = "!@#$%*_-";
    static char s[2];
    
    s[0] = sym[rand() % 8];
    s[1] = '\0';
    
    return s;
}
char *add_word(void){
    char *vocabulary[] = {
        "Orange", "Grape", "Apple", "Banana", "coffee", "tea", "juice", "beverage",
        "happY", "grumpY", "bashfuL", "sleepY"};
	int r;
    r = rand() % 12;
    return vocabulary[r];
}
```

- The purpose of declaring variables as `static` here is to ensure that the arrays `n` and `s` persist after the functions return.
- This allows us to safely return pointers to these arrays without causing undefined behavior.
- In C, when we declare a variable inside a function as `static`, it has the following properties:
  - **Static Storage Duration**: The variable is allocated when the program starts and remains in memory until the program exits.
  - **Local Scope**: The variable is only accessible within the function where it is declared.
  - **Retains Value Between Calls**: The variable retains its value between multiple calls to the function.

`main.c`

```C
int main(){
    char password[32];
    
    srand((unsigned)time(NULL));
    
    // Initialize the string so that the strcpy() doesn't puke
    password[0] = '\0';
    
    // Copies the first word, appends a number, appends the second word, appends a symbol, appends the final word
    strcpy(password, add_word());
    strcat(password, number());
    strcat(password, add_word());
    strcat(password, symbol());
    strcat(password, add_word());
    
    printf("%s\n", password);
    return 0;
}
```

- It's important to initialize the `password` array as an empty with with the null terminator `\0`, before using `strcat` as `strcat` expects a properly null-terminated string as its destination.
- `strcpy(destination, source)` : Copies the `source` string into the `destination` array, including the null terminator.
- `strcat(destination, source)` : Appends the source string to the end of the `destination` string, starting from the null terminator, and **adds a new null terminator at the end.**

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
happY4sleepY_Orange

chan@CMA:~/C_Programming/test$ ./final
Orange3sleepY%bashfuL

chan@CMA:~/C_Programming/test$ ./final
grumpY0bashfuL$Banana
```



- The  above program can be enhanced by expanding the `vocabulary[]` array in the `add_word()` function.
- Or, devise a system where we have files containing words we like to use in a password like the way the second Mad Libs program works.

`hello.h`

```C
enum{
    BSIZE = 32,
};

struct term{
    char filename[16];
    FILE *fp;
    int items;
    char **list_base;
}

void build_vocabulary(struct term *t);
char *number(void);
char *symbol(void);
char *add_word(void);
```

- `t->list_base` is a dynamically allocated array of pointers to `char`, effectively an array of strings.
- `t->items` is an integer tracking the number of words added to the list.

`hello.c`

```C
void build_vocabulary(struct term *t){
    char buffer[BSIZE];
    char *r, *entry;
    
    t->fp = fopen(t->filename, "r");
    if(t->fp == NULL){
        fprintf(stderr, "Unable to open file %s\n", t->filename);
        exit(1);
    }
    
    t->list_base = malloc(sizeof(char *) * 100);
    
    if(t->list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    t->items = 0;
    while(!feof(!t->fp)){
        r = fgets(buffer, BSIZE, t->fp);
        if(r == NULL){
            break;
        }
        
        entry = malloc(sizeof(char *) * strlen(buffer) + 1);
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        strcpy(entry, buffer);
        r = entry;
        while(*r){
            if(*r == '\n'){
                *r = '\0';
                break;
            }
            r++;
        }
        
        // Adds a new word `entry` to the t->list_base at the current index t->items
        *(t->list_base + t-> items) = entry;
        t->items++;
        if(t->items % 100 == 0){
            t->list_base = realloc(t->list_base, sizeof(char *) * (t->items + 100));
            if(t->list_base == NULL){
                fprintf(stderr, "Unable to allocate memory\n");
                exit(1);
            }
        }
    }
    fclose(t->fp);
}

char *number(void){
    static char n[2];
    n[0] = rand() % 10 + '0';
    n[1] = '\0';
    
    return n;
}

char *symbol(void){
    char sym[8] = "!@#$%*_-";
    static char s[2];
    
    s[0] = sym[rand() % 8];
    s[1] = '\0';
    
    return s;
}

char *add_word(void){
    char *vocabulary[] = {
        "Orange", "Grape", "Apple", "Banana", "coffee", "tea", "juice", "beverage",
        "happY", "grumpY", "bashfuL", "sleepY"};
    int r;
    r = rand() % 12;
    return vocabulary[r];

}

// Ensure that the passed string has at lease one uppercase letter
void check_caps(char *string){
    int found, r, len;
    char *s;
    
    // initial scan
    found = 0;
    s = string;
    while(*s){
        if(isupper(*s)){
            found = 1;
            break;
        }
        s++;
    }
    
    // Exit if the string has a capital letter
    if(found){
        return;
    }
    
    // Make a random letter uppercase
    len = strlen(string);
    s = string;
    while(1){
        r = rand() % len;
        if(islower(*(s+r))){
            *(s+r) = toupper(*(s+r));
            break;
        }
    }
}
```

- `t->list_base + t->items` in `build_vocabulary()`:
  - `t->list_base` is a pointer to the first element of the array (`char **`).
  - By adding `t->items`, we move the pointer ahead by `t->items` positions.
  - This points to the next available slot in the array where we can store the new word.
- **`*(t->list_base + t->items)`**:
  - The `*` operator dereferences the pointer to access the value at that position, which is of type `char *`.
  - This represents the slot in the array where we will store the pointer to the new word (`entry`).
- **`= entry;`**:
  - `entry` is a pointer to a `char` (a string), which we've just read from the file and copied into dynamically allocated memory.
  - We assign `entry` to the dereferenced slot, effectively storing the new word in our vocabulary list.

**Alternative Notation**

The line can also be written using array indexing for clarity:

```C
t->list_base[t->items] = entry;
```

- This notation shows that we are placing `entry` into the `list_base` array at index `t->items`.

`main.c`

```C
int main()
{

    char password[32];
    struct term nouns = {"nouns.txt", NULL, 0, NULL};
    struct term verbs = {"verbs.txt", NULL, 0, NULL};
    struct term adjectives = {"adjectives.txt", NULL, 0, NULL};

    build_vocabulary(&nouns);
    build_vocabulary(&verbs);
    build_vocabulary(&adjectives);

    srand((unsigned)time(NULL));

    password[0] = '\0';

    strcpy(password, add_word());
    strcat(password, number());
    strcat(password, add_word());
    strcat(password, symbol());
    strcat(password, add_word());

    printf("%s\n", password);

    return 0;
}
```



`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Orange2Apple$beverage
chan@CMA:~/C_Programming/test$ ./final
coffee5Apple!beverage
chan@CMA:~/C_Programming/test$ ./final
tea6happY!grumpY

```

---

