## Chapter 15 - Tic-tac-toe

### Creating the game grid

- Seven color constants are created to achieve the colors.
- Two different values are used for each of the three square possibilities: blank, X, and O.

| Constant Name | Code           | For Output                                       |
| ------------- | -------------- | ------------------------------------------------ |
| `bfwb[]`      | `\x1b[32;47m`  | Blank square, green foreground/ white background |
| `bf[]`        | `\x1b[32m`     | Blank square, green foreground                   |
| `xfwb[]`      | `\x1b[31; 47m` | X square, red foreground/ white background       |
| `xf[]`        | `\x1b[31m`     | X square, red foreground                         |
| `ofwb[]`      | `\x1b[43; 47m` | O square, blue foreground/ white background      |
| `of[]`        | `\x1b[34m`     | O square, blue foreground                        |
| `reset[]`     | `\x1b[0m`      | Color values off                                 |

- Each sequence sets a foreground or foreground-background combination.
- The background colors are used, every other square, to create the checkerboard  pattern.
- The final `reset[]` sequence removes color from the output, which avoids color spill between lines in the output.
- The next listing shows the `showgrid()` function outputs the game grid with alternating colors, numbering each position, one through nine.
- A `switch-case` test determines whether the square is occupied with an O(-1), an X(+1), or a blank(0).
- In the `main()` function, the grid is initialized in the `grid[]` array and then output.

```C
void showgrid(int *g)
{
    // Define ANSI escape codes for text color and background formatting (b = background, x = X square, o = O square)
    const char bfwb[] = "\x1b[32;47m"; // Bright green text on white background
    const char bf[] = "\x1b[32m";      // Bright green text
    const char xfwb[] = "\x1b[31;47m"; // Red text on white background
    const char xf[] = "\x1b[31m";      // Red text
    const char ofwb[] = "\x1b[34;47m"; // Blue text on white background
    const char of[] = "\x1b[34m";      // Blue text
    const char reset[] = "\x1b[0m";    // Reset text formatting to default

    int x;

    for (x = 0; x < 9; x++)
    {
        switch (g[x])
        {
        case -1:
                // If the value is -1, it's player O's move
            if (x % 2)
            {
                // For odd positions, use blue text on white background
                printf("%s O %s", ofwb, reset);
            }
            else
            {
                // For even positions, use blue text
                printf("%s O %s", of, reset);
            }
            break;
        case 1: // If the value is 1, it's player X's move
            if (x % 2)
            {
                // For odd positions, use red text on white background
                printf("%s X %s", xfwb, reset);
            }
            else
            {
                // For even positions, use red text
                printf("%s X %s", xf, reset);
            }
            break;
        default: // If the value is 0, the position is empty
            if (x % 2)
            {
                // For odd positions, display the position number with green text on white background
                printf("%s %d %s", bfwb, x + 1, reset);
            }
            else
            {
                // For even positions, display the position number with green text
                printf("%s %d %s", bf, x + 1, reset);
            }
        }
        
        // After every third position, move to the next line to form the grid
        if ((x + 1) % 3 == 0)
        {
            putchar('\n');
        }
    }

    // Print an extra newline after the grid
    putchar('\n');
}

int main()
{
    int grid[] = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0};

    puts("Tic-Tac-Toe");
    showgrid(grid);
    return 0;
}
```

- The `showgrid()` function processes squares in the game gird.
- For each possible value - (-1, +1, 0), two options are available for output.
- The first is triggered for odd-numbered squares, where a background color is applied.
- For even squares, no background color is used.

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
 1  2  3 
 4  5  6 
 7  8  9 
```

![Screenshot from 2024-11-30 20-23-48](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-30 20-23-48.png)

### Adding game play

To update our existing code, the game play loop must display the grid, prompt for input, and then update the `grid[]` array.

`practice.h`

```C
void showgrid(int *g);

int prompt(int p);
```

`functions.c`

```C
void showgrid(int *g)
{
    // Define ANSI escape codes for text color and background formatting (b = background, x = X square, o = O square)
    const char bfwb[] = "\x1b[32;47m"; // Bright green text on white background
    const char bf[] = "\x1b[32m";      // Bright green text
    const char xfwb[] = "\x1b[31;47m"; // Red text on white background
    const char xf[] = "\x1b[31m";      // Red text
    const char ofwb[] = "\x1b[34;47m"; // Blue text on white background
    const char of[] = "\x1b[34m";      // Blue text
    const char reset[] = "\x1b[0m";    // Reset text formatting to default

    int x;

    for (x = 0; x < 9; x++)
    {
        switch (g[x])
        {
        case -1:
                // If the value is -1, it's player O's move
            if (x % 2)
            {
                // For odd positions, use blue text on white background
                printf("%s O %s", ofwb, reset);
            }
            else
            {
                // For even positions, use blue text
                printf("%s O %s", of, reset);
            }
            break;
        case 1: // If the value is 1, it's player X's move
            if (x % 2)
            {
                // For odd positions, use red text on white background
                printf("%s X %s", xfwb, reset);
            }
            else
            {
                // For even positions, use red text
                printf("%s X %s", xf, reset);
            }
            break;
        default: // If the value is 0, the position is empty
            if (x % 2)
            {
                // For odd positions, display the position number with green text on white background
                printf("%s %d %s", bfwb, x + 1, reset);
            }
            else
            {
                // For even positions, display the position number with green text
                printf("%s %d %s", bf, x + 1, reset);
            }
        }
        
        // After every third position, move to the next line to form the grid
        if ((x + 1) % 3 == 0)
        {
            putchar('\n');
        }
    }

    // Print an extra newline after the grid
    putchar('\n');
}

int prompt(int p){
    int square;
    
    printf("%c's turn: Pick a square, 0 to quit: ", p % 2 ? 'O' : 'X');
    scanf("%d", &square);
    
    // For out of range values, returns 0 (exit)
    if(square < 0 || square > 9){
        return 0;
    }
    return square;
}
```

`practice.c (main)`

```C
int main(){
    int grid[] = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0
    };
    int ply, p;
    puts("Tic-Tac-Toe");
    
    // // Initialize the play counter to 0
    ply = 0;
    
    // Start the game loop, the loop is endless, relying on a win or exit command to break
    while(1){
        showgrid(grid);
        
        // Prompt the current player for their move
        // Accepts input, returning the square to place a token
        p = prompt(ply);
        
        // If the player enters 0, exit the game loop
        if(p == 0){
            break;
        }
        
        // Sets the token on the grid, subtracts one from p to obtain the array offset, and uses the current ply to determine whether O(-1) or X(+1) has played
        // Update the grid with the player's move
        // For player X (even turns), mark with 1
        // For player O (odd turns), mark with -1
        grid[p - 1] = ply % 2 ? -1 : 1;
        ply++;
    }
    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
 1  2  3 
 4  5  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 1
 X  2  3 
 4  5  6 
 7  8  9 

O's turn: Pick a square, 0 to quit: 5
 X  2  3 
 4  O  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 0
chan@CMA:~/C_Programming/practice$ 
```

![Screenshot from 2024-11-30 20-42-03](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-30 20-42-03.png)

#### Step-by-Step Explanation of `prompt()` function

- **First Iteration**:

  - Since all elements in `grid` are `0`, the default case triggers.

  - The grid is displayed showing numbers 1 to 9 representing available positions.

  - **Prompt Player for Input**:
    - `p = prompt(ply);` calls the `prompt` function with the current play count.

  - **Determine Current Player**:
    - `(p % 2 ? 'O' : 'X')` calculates the current player.
      - If `p` is even (`ply = 0`), current player is `'X'`.
      - If `p` is odd, current player is `'O'`.

  - **Prompt Message**:
    - Prints: `X's turn: Pick a square, 0 to quit:`

  - **Player Input**:
    - Player `X` enters `1`.

  - **Check for Quit Condition**:
    - `if (p == 0)` checks if the player wants to quit.
    - Since `p = 1`, the game continues.

  - **Update the Grid**:
    - `grid[p - 1] = ply % 2 ? -1 : 1;`
    - For `ply = 0` (even), the value is `1` (player `X`).
    - Updates `grid[0]` (since `p - 1 = 0`) to `1`.

  - **Increment Play Counter**:
    - `ply++;` increments `ply` to `1`.

- **Second iteration (ply = 1)**:

  - **Display the Updated Grid**:

    - `showgrid(grid);` displays the grid with the updated move.

    - **Grid State**:

    - `grid` now has the following values:

      - `[1, 0, 0, 0, 0, 0, 0, 0, 0]`

    - Position `1` is marked with `X`.

    - ```
      X  2  3
      4  5  6
      7  8  9
      ```

    - **Prompt Player `O` for Input**:

      - `p = prompt(ply);` calls `prompt` with `ply = 1`.
      - Current player is `'O'` (since `1 % 2 = 1`).
      - Player `O` enters `5`.

    - **Check for Quit Condition**:

      - Since `p = 5`, the game continues.

    - **Update the Grid**:

      - `grid[p - 1] = ply % 2 ? -1 : 1;`
      - For `ply = 1` (odd), the value is `-1` (player `O`).
      - Updates `grid[4]` (`p - 1 = 4`) to `-1`.

    - **Increment Play Counter**:

      - `ply++;` increments `ply` to `2`.

- **Third Iteration (ply = 2)**:

  - **Display the Updated Grid**:

    - `showgrid(grid);` displays the grid with the new move.

  - **Grid State**:

    - `grid` now has:

      - `[1, 0, 0, 0, -1, 0, 0, 0, 0]`

    - Position `5` is marked with `O`.

    - ```
      X  2  3
      4  O  6
      7  8  9
      ```

  - **Prompt Player `X` for Input**:

    - `p = prompt(ply);` with `ply = 2`.
    - Current player is `'X'` (since `2 % 2 = 0`).
    - Player `X` enters `0` (chooses to quit the game).

  - **Check for Quit Condition**:

    - `if (p == 0)` evaluates to `true`.
    - The `break;` statement exits the `while` loop.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
 1  2  3 
 4  5  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 1
 X  2  3 
 4  5  6 
 7  8  9 

O's turn: Pick a square, 0 to quit: 1
 O  2  3 
 4  5  6 
 7  8  9 

```



What's missing from the code is the capability to determine when a square is already occupied.

- As we can see in the above output, O was able to capture the 1st square after it was already taken by X.



### Limiting the input to free squares

- To prevent squares from being retaken, the `prompt()` function must be updated as well as the game play loop in the `main()` function.

`practice.h`

```C
void showgrid(int *g);

int prompt(int p, int *g);
```

`functions.c`

```C
void showgrid(int *g)
{
    // Define ANSI escape codes for text color and background formatting (b = background, x = X square, o = O square)
    const char bfwb[] = "\x1b[32;47m"; // Bright green text on white background
    const char bf[] = "\x1b[32m";      // Bright green text
    const char xfwb[] = "\x1b[31;47m"; // Red text on white background
    const char xf[] = "\x1b[31m";      // Red text
    const char ofwb[] = "\x1b[34;47m"; // Blue text on white background
    const char of[] = "\x1b[34m";      // Blue text
    const char reset[] = "\x1b[0m";    // Reset text formatting to default

    int x;

    for (x = 0; x < 9; x++)
    {
        switch (g[x])
        {
        case -1:
                // If the value is -1, it's player O's move
            if (x % 2)
            {
                // For odd positions, use blue text on white background
                printf("%s O %s", ofwb, reset);
            }
            else
            {
                // For even positions, use blue text
                printf("%s O %s", of, reset);
            }
            break;
        case 1: // If the value is 1, it's player X's move
            if (x % 2)
            {
                // For odd positions, use red text on white background
                printf("%s X %s", xfwb, reset);
            }
            else
            {
                // For even positions, use red text
                printf("%s X %s", xf, reset);
            }
            break;
        default: // If the value is 0, the position is empty
            if (x % 2)
            {
                // For odd positions, display the position number with green text on white background
                printf("%s %d %s", bfwb, x + 1, reset);
            }
            else
            {
                // For even positions, display the position number with green text
                printf("%s %d %s", bf, x + 1, reset);
            }
        }
        
        // After every third position, move to the next line to form the grid
        if ((x + 1) % 3 == 0)
        {
            putchar('\n');
        }
    }

    // Print an extra newline after the grid
    putchar('\n');
}

// Array grid[] is used as pointer variable g here
int prompt(int p, int *g)
{
    int square;

    printf("%c's turn: Pick a square, 0 to quit: ", p % 2 ? 'O' : 'X');
    scanf("%d", &square);
    if (square < 0 || square > 9)
    {
        puts("Value out of range");
        return -1;
    }

    // Test for 0 to quit here; otherwise, the value is returned and used improperly on array grid[]
    if (square == 0)
    {
        return square;
    }

    // If the value chosen is occupied, or not zero: note that 1 is subtracted because the input is 1 thru 9, though the array elements are numbered 0 thru 8
    if (g[square - 1] != 0)
    {
        printf("Square %d is occupied, try again\n", square);
        return -1;
    }

    // Return the square chosen, which is unoccupied
    return square;
}
```

`practice.c (main)`

- The `while` loop repeatedly calls the `prompt()` function as long as the value returned is -1.
- Only valid input - 0 or an open square number breaks the loop.
- The remainder of the `main()` function is unchanged.

```C
int main()
{
    int grid[] = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0};
    int ply, p;
    puts("Tic-Tac-Toe");

    ply = 0;
    while (1)
    {
        showgrid(grid);
        while ((p = prompt(ply, grid)) == -1)
            ;
        if (p == 0)
        {
            break;
        }
        grid[p - 1] = ply % 2 ? -1 : 1;
        ply++;
    }

    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
 1  2  3 
 4  5  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 5
 1  2  3 
 4  X  6 
 7  8  9 

O's turn: Pick a square, 0 to quit: 5
Square 5 is occupied, try again
O's turn: Pick a square, 0 to quit: 1
 O  2  3 
 4  X  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 9
 O  2  3 
 4  X  6 
 7  8  X 

O's turn: Pick a square, 0 to quit: 0

```

![Screenshot from 2024-11-30 22-02-46](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-30 22-02-46.png)



### Determining the winner

- To determine a winner, the `winner()` function is written.

- It examines the eight slices through the game grid where a win is possible.

- For a slice to identify as a winner, all of its square must contain the same value:

  - +1 for X or -1 for O.

- The total for a given slice must either be +3 or -3 to win the game.

- The `winner()` function accepts the game grid as an argument,

  - Each square is examined as columns, rows and diagonals.

  - ```C
    slice[0] = *(g + 0) + *(g + 3) + *(g + 6);
    ```

  - Element 0 of the `slice[]` array holds the total for the first column - squares 0, 3 and 6.

  - Each square is represented by the integer pointer `g`, plus an offset into the array.



- The `slice[]` array contains the totals of the eight possible winning combinations, totalling the values in each of the three squares for each slice.
- If a slice contains all the same tokens, its value is -3 for an O win or +3 for an X win.
- A `for` loop test these possibilities. 
- When a win occurs, the function returns 1, or 0 otherwise.

```C
int winner(int *g)
{
    // Eight possible ways to win; the slice[] array holds the totals.
    int slice[8];
    int x;
	
    // Tallies the columns, rows, and diagonals for each slice
    slice[0] = TL + ML + BL;
    slice[1] = TC + MC + BC;
    slice[2] = TR + MR + BR;
    slice[3] = TL + TC + TR;
    slice[4] = ML + MC + MR;
    slice[5] = BL + BC + BR;
    slice[6] = TL + MC + BR;
    slice[7] = BL + MC + TR;

    for (x = 0; x < 8; x++)
    {
        if (slice[x] == -3)
        {
            showgrid(g);
            puts(">>> O wins!");
            return 1;
        }
        if (slice[x] == 3)
        {
            showgrid(g);
            puts(">>> X wins!");
            return 1;
        }
    }
    
    // Return 0 if no one has 1
    return 0;
}
```



**Full Program**

`practice.h`

```C
// T = Top, M = Middle, B = Bottom, L = Left, R = Right, C = Center
#define TL *(g + 0)
#define TC *(g + 1)
#define TR *(g + 2)
#define ML *(g + 3)
#define MC *(g + 4)
#define MR *(g + 5)
#define BL *(g + 6)
#define BC *(g + 7)
#define BR *(g + 8)
// Functions.c
void showgrid(int *g);

int prompt(int p, int *g);

int winner(int *g);
```

`functions.c`

```C
void showgrid(int *g)
{
    // Define ANSI escape codes for text color and background formatting (b = background, x = X square, o = O square)
    const char bfwb[] = "\x1b[32;47m"; // Bright green text on white background
    const char bf[] = "\x1b[32m";      // Bright green text
    const char xfwb[] = "\x1b[31;47m"; // Red text on white background
    const char xf[] = "\x1b[31m";      // Red text
    const char ofwb[] = "\x1b[34;47m"; // Blue text on white background
    const char of[] = "\x1b[34m";      // Blue text
    const char reset[] = "\x1b[0m";    // Reset text formatting to default

    int x;

    for (x = 0; x < 9; x++)
    {
        switch (g[x])
        {
        case -1:
                // If the value is -1, it's player O's move
            if (x % 2)
            {
                // For odd positions, use blue text on white background
                printf("%s O %s", ofwb, reset);
            }
            else
            {
                // For even positions, use blue text
                printf("%s O %s", of, reset);
            }
            break;
        case 1: // If the value is 1, it's player X's move
            if (x % 2)
            {
                // For odd positions, use red text on white background
                printf("%s X %s", xfwb, reset);
            }
            else
            {
                // For even positions, use red text
                printf("%s X %s", xf, reset);
            }
            break;
        default: // If the value is 0, the position is empty
            if (x % 2)
            {
                // For odd positions, display the position number with green text on white background
                printf("%s %d %s", bfwb, x + 1, reset);
            }
            else
            {
                // For even positions, display the position number with green text
                printf("%s %d %s", bf, x + 1, reset);
            }
        }
        
        // After every third position, move to the next line to form the grid
        if ((x + 1) % 3 == 0)
        {
            putchar('\n');
        }
    }

    // Print an extra newline after the grid
    putchar('\n');
}

// Array grid[] is used as pointer variable g here
int prompt(int p, int *g)
{
    int square;

    printf("%c's turn: Pick a square, 0 to quit: ", p % 2 ? 'O' : 'X');
    scanf("%d", &square);
    if (square < 0 || square > 9)
    {
        puts("Value out of range");
        return -1;
    }

    // Test for 0 to quit here; otherwise, the value is returned and used improperly on array grid[]
    if (square == 0)
    {
        return square;
    }

    // If the value chosen is occupied, or not zero: note that 1 is subtracted because the input is 1 thru 9, though the array elements are numbered 0 thru 8
    if (g[square - 1] != 0)
    {
        printf("Square %d is occupied, try again\n", square);
        return -1;
    }

    // Return the square chosen, which is unoccupied
    return square;
}

int winner(int *g)
{
    // Eight possible ways to win; the slice[] array holds the totals.
    int slice[8];
    int x;
	
    // Tallies the columns, rows, and diagonals for each slice
    slice[0] = TL + ML + BL;
    slice[1] = TC + MC + BC;
    slice[2] = TR + MR + BR;
    slice[3] = TL + TC + TR;
    slice[4] = ML + MC + MR;
    slice[5] = BL + BC + BR;
    slice[6] = TL + MC + BR;
    slice[7] = BL + MC + TR;

    for (x = 0; x < 8; x++)
    {
        if (slice[x] == -3)
        {
            showgrid(g);
            puts(">>> O wins!");
            return 1;
        }
        if (slice[x] == 3)
        {
            showgrid(g);
            puts(">>> X wins!");
            return 1;
        }
    }
    
    // Return 0 if no one has 1
    return 0;
}
```

`practice.c (main)`

```C
int main()
{
    int grid[] = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0};
    int ply, p;
    puts("Tic-Tac-Toe");

    ply = 0;
    
    // Limits the loop to nine turns
    while (ply < 9)
    {
        showgrid(grid);
        while ((p = prompt(ply, grid)) == -1)
            ;
        if (p == 0)
        {
            break;
        }
        grid[p - 1] = ply % 2 ? -1 : 1;
        // Calls the winner() function which returns 1 when a winner is detected
        if (winner(grid))
        {
            break;
        }
        ply++;
    }
	
    // Test to see whether the loop terminated in a no-win (draw)
    if (ply == 9)
    {
        showgrid(grid);
        puts("Cat's game!");
    }

    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
 1  2  3 
 4  5  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 5
 1  2  3 
 4  X  6 
 7  8  9 

O's turn: Pick a square, 0 to quit: 2
 1  O  3 
 4  X  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 1
 X  O  3 
 4  X  6 
 7  8  9 

O's turn: Pick a square, 0 to quit: 9
 X  O  3 
 4  X  6 
 7  8  O 

X's turn: Pick a square, 0 to quit: 4
 X  O  3 
 X  X  6 
 7  8  O 

O's turn: Pick a square, 0 to quit: 7
 X  O  3 
 X  X  6 
 O  8  O 

X's turn: Pick a square, 0 to quit: 6
 X  O  3 
 X  X  X 
 O  8  O 

>>> X wins!

```



### Choosing the number of players

- Set in the `main()` function, immediately after the program's title is output, the prompt asks for the number of players: 0, 1, or 2. 
- If an invalid number is input, the program quits.
- In the game play loop, however, decisions are made based on the number of players:
  - When the number of players is 0, the computer plays every turn.
  - When the number of players is 1, the computer alternates every other turn.
  - When the number of players is 2, humans take turns of the game.

`practice.h`

```C
// T = Top, M = Middle, B = Bottom, L = Left, R = Right, C = Center
#define TL *(g + 0)
#define TC *(g + 1)
#define TR *(g + 2)
#define ML *(g + 3)
#define MC *(g + 4)
#define MR *(g + 5)
#define BL *(g + 6)
#define BC *(g + 7)
#define BR *(g + 8)
// Functions.c
void showgrid(int *g);

int prompt(int p, int *g);

int winner(int *g);

int computer(int *g);
```

`functions_2.c`

```C
int computer(int *g)
{
    int r;

    do
    {
        r = rand() % 9; // Generates a random value, 0 thru 8
    } while (*(g + r) != 0); // Confirms that the square is empty, or keeps looping otherwise

    r++;
    printf("The computer moves to square %d\n", r);
    return r;
}
```

`functions.c`

```C
void showgrid(int *g)
{
    // Define ANSI escape codes for text color and background formatting (b = background, x = X square, o = O square)
    const char bfwb[] = "\x1b[32;47m"; // Bright green text on white background
    const char bf[] = "\x1b[32m";      // Bright green text
    const char xfwb[] = "\x1b[31;47m"; // Red text on white background
    const char xf[] = "\x1b[31m";      // Red text
    const char ofwb[] = "\x1b[34;47m"; // Blue text on white background
    const char of[] = "\x1b[34m";      // Blue text
    const char reset[] = "\x1b[0m";    // Reset text formatting to default

    int x;

    for (x = 0; x < 9; x++)
    {
        switch (g[x])
        {
        case -1:
                // If the value is -1, it's player O's move
            if (x % 2)
            {
                // For odd positions, use blue text on white background
                printf("%s O %s", ofwb, reset);
            }
            else
            {
                // For even positions, use blue text
                printf("%s O %s", of, reset);
            }
            break;
        case 1: // If the value is 1, it's player X's move
            if (x % 2)
            {
                // For odd positions, use red text on white background
                printf("%s X %s", xfwb, reset);
            }
            else
            {
                // For even positions, use red text
                printf("%s X %s", xf, reset);
            }
            break;
        default: // If the value is 0, the position is empty
            if (x % 2)
            {
                // For odd positions, display the position number with green text on white background
                printf("%s %d %s", bfwb, x + 1, reset);
            }
            else
            {
                // For even positions, display the position number with green text
                printf("%s %d %s", bf, x + 1, reset);
            }
        }
        
        // After every third position, move to the next line to form the grid
        if ((x + 1) % 3 == 0)
        {
            putchar('\n');
        }
    }

    // Print an extra newline after the grid
    putchar('\n');
}

// Array grid[] is used as pointer variable g here
int prompt(int p, int *g)
{
    int square;

    printf("%c's turn: Pick a square, 0 to quit: ", p % 2 ? 'O' : 'X');
    scanf("%d", &square);
    if (square < 0 || square > 9)
    {
        puts("Value out of range");
        return -1;
    }

    // Test for 0 to quit here; otherwise, the value is returned and used improperly on array grid[]
    if (square == 0)
    {
        return square;
    }

    // If the value chosen is occupied, or not zero: note that 1 is subtracted because the input is 1 thru 9, though the array elements are numbered 0 thru 8
    if (g[square - 1] != 0)
    {
        printf("Square %d is occupied, try again\n", square);
        return -1;
    }

    // Return the square chosen, which is unoccupied
    return square;
}

int winner(int *g)
{
    // Eight possible ways to win; the slice[] array holds the totals.
    int slice[8];
    int x;
	
    // Tallies the columns, rows, and diagonals for each slice
    slice[0] = TL + ML + BL;
    slice[1] = TC + MC + BC;
    slice[2] = TR + MR + BR;
    slice[3] = TL + TC + TR;
    slice[4] = ML + MC + MR;
    slice[5] = BL + BC + BR;
    slice[6] = TL + MC + BR;
    slice[7] = BL + MC + TR;

    for (x = 0; x < 8; x++)
    {
        if (slice[x] == -3)
        {
            showgrid(g);
            puts(">>> O wins!");
            return 1;
        }
        if (slice[x] == 3)
        {
            showgrid(g);
            puts(">>> X wins!");
            return 1;
        }
    }
    
    // Return 0 if no one has 1
    return 0;
}
```

`practice.c (main)`

```C
int main()
{
    int grid[] = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0};
    int ply, p, players;

    srand((unsigned)time(NULL));
    puts("Tic-Tac-Toe");
    printf("Number of players (0, 1, 2): ");
    scanf("%d", &players);

    if (players < 0 || players > 2)
    {
        return 1;
    }

    ply = 0;
    while (ply < 9)
    {
        showgrid(grid);
        if (players == 0)
        {
            p = computer(grid);
        }
        else if (players == 1)
        {
            if (ply % 2)
            {
                p = computer(grid);
            }
            else
            {
                while ((p = prompt(ply, grid)) == -1)
                    ;
            }
        }
        else
        {
            while ((p = prompt(ply, grid)) == -1)
                ;
        }

        if (p == 0)
        {
            break;
        }
        grid[p - 1] = ply % 2 ? -1 : 1;
        if (winner(grid))
        {
            break;
        }
        ply++;
    }

    if (ply == 9)
    {
        showgrid(grid);
        puts("Cat's game!");
    }

    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
Number of players (0, 1, 2): 1
 1  2  3 
 4  5  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 5
 1  2  3 
 4  X  6 
 7  8  9 

The computer moves to square 7
 1  2  3 
 4  X  6 
 O  8  9 

X's turn: Pick a square, 0 to quit: 1
 X  2  3 
 4  X  6 
 O  8  9 

The computer moves to square 9
 X  2  3 
 4  X  6 
 O  8  O 

X's turn: Pick a square, 0 to quit: 2
 X  X  3 
 4  X  6 
 O  8  O 

The computer moves to square 3
 X  X  O 
 4  X  6 
 O  8  O 

X's turn: Pick a square, 0 to quit: 8
 X  X  O 
 4  X  6 
 O  X  O 

>>> X wins!

```



### Adding some intelligence

- Three pieces of intelligence for the computer player.

- First, if it's the first turn (ply zero) and the computer moves first, it should snag the center square.

  - The update is made to the `computer()` function.

  ```C
  if(p == 0){
      puts("The computer snags the center");
      return 5;
  }
  ```

  - Variable `p` is the current `ply` value from the game play loop in the `main()` fucntion.

  - When its value is 0, the computer is taking the first turn and all squares are open.

  - A message is output and the function returns 5, the center square.

  - The value should be 4 because this is the offset in the `grid[]` array, but the `computer()` function must be compatible with the user's `prompt()` function and return values in the range of 1 through 9.

  - `prompt()` returns 0 to quit the game.

  - This `if` test can be improved to check the center square during the second `ply`; if the computer goes second but its human opponent is too stupid to grab the center square, it should take it.

    ```C
    if(p == 0 || (p == 1 && MC == 0)){
        puts("The computer snags the center");
        return 5;
    }
    ```

- The second iota of intelligence is to play a corner square when the center square is taken.

  - This move provides the best defense when moving second.

  ```C
  if(p == 1 && TL == 0){
      puts("The computer moves to square 1");
      return 1;
  }
  ```

  - On the second `ply`, `p == 1`, the top-left (`TL`) square is most likely empty.

- The third piece of intelligence consists of a game grid scan for moves to block or moves to win.

  - Before the computer resorts to a random move, it scans all eight possible winning slices on the game grid.
  - If any of these slices contains two of the same tokens plus an empty square, the empty square is filled so that the computer wins or blocks a win.
  - `towin()` and `toblock()` are implemented to carry out the game grid scan.
  - The `towin()` function wants the computer's tokens to add up to 2 or -2.
  - The `toblock()` function wants the opponent's tokens to add up to 2 or -2.

  ```C
  int three(int *g, int p);
  ```

  - The function's arguments are `g`, the game grid, and `p` , the token to look for: -1 for O and +1 for X.

  ```C
  if(TL + ML + BL == p * 2){
      if(TL == 0) return 0;
      if(ML == 0) return 3;
      if(BL == 0) return 6;
  }
  ```

  - If their total is equal to two times variable `p`, the column contains two matching tokens and a blank.
  - This result holds true whether `p` is -1 for O or +1 for X.
  - After a slice is identified as a potential win or block, the function returns a value representing the blank square.
    - If it's the top-left square, `TL`, 0 is returned.
    - IF the middle-left square is blank, `ML == 0`, its offset is returned.
    - This logic allows the computer to either win or block, depending on the value of variable `p`.



#### Final Version

`practice.h`

```C
// T = Top, M = Middle, B = Bottom, L = Left, R = Right, C = Center
#define TL *(g + 0)
#define TC *(g + 1)
#define TR *(g + 2)
#define ML *(g + 3)
#define MC *(g + 4)
#define MR *(g + 5)
#define BL *(g + 6)
#define BC *(g + 7)
#define BR *(g + 8)
// Functions.c
void showgrid(int *g);

int prompt(int p, int *g);

int winner(int *g);

int computer(int p, int *g);

int three(int *g, int p);
```

`functions_2.c`

```C
int computer(int p, int *g)
{
    int r;

    if (p == 0 || (p == 1 && MC == 0))
    {
        puts("The computer snags the center");
        return 5;
    }

    if (p == 1 && TL == 0)
    {
        puts("The computer moves to square 1");
        return 1;
    }

    // Detects a win using the `ply` value: 0 means it's O turn, 1 for X.
    if (p % 2)
    {
        // Check for a win for O(-1)
        r = three(g, -1);
    }
    else
    {
        // Check for a win for X (+1)
        r = three(g, 1);
    }

    // If a win isn't detected, three() returns -1: checks for a block (you want to win before you block).
    if (r == -1)
    {
        
        // Determines whether X or O is moving next
        if (p % 2)
        {
            // Block for X
            r = three(g, 1);
        }
        else
        {
            // Block for O
            r = three(g, -1);
        }
    }

    // If r is qual to -1, the computer hasn't won or blocked: time for a random square pick
    if (r == -1)
    {
        do
        {
            r = rand() % 9;
        } while (*(g + r) != 0);
    }

    r++; // increment r to represent the proper offset 1 thru 9
    printf("The computer moves to square %d\n", r);
    return r;
}

int three(int *g, int p)
{
    if (TL + ML + BL == p * 2)
    {
        if (TL == 0)
            return 0;
        if (ML == 0)
            return 3;
        if (BL == 0)
            return 6;
    }
    if (TC + MC + BC == p * 2)
    {
        if (TC == 0)
            return 1;
        if (MC == 0)
            return 4;
        if (BC == 0)
            return 7;
    }
    if (TR + MR + BR == p * 2)
    {
        if (TR == 0)
            return 2;
        if (MR == 0)
            return 5;
        if (BR == 0)
            return 8;
    }

    if (TL + TC + TR == p * 2)
    {
        if (TL == 0)
            return 0;
        if (TC == 0)
            return 1;
        if (TR == 0)
            return 2;
    }
    if (ML + MC + MR == p * 2)
    {
        if (ML == 0)
            return 3;
        if (MC == 0)
            return 4;
        if (MR == 0)
            return 5;
    }
    if (BL + BC + BR == p * 2)
    {
        if (BL == 0)
            return 6;
        if (BC == 0)
            return 7;
        if (BR == 0)
            return 8;
    }

    if (TL + MC + BR == p * 2)
    {
        if (TL == 0)
            return 0;
        if (MC == 0)
            return 4;
        if (BR == 0)
            return 8;
    }
    if (TR + MC + BL == p * 2)
    {
        if (TR == 0)
            return 2;
        if (MC == 0)
            return 4;
        if (BL == 0)
            return 6;
    }

    return (-1);
}
```

`functions.c`

```C
void showgrid(int *g)
{
    const char bfwb[] = "\x1b[32;47m";
    const char bf[] = "\x1b[32m";
    const char xfwb[] = "\x1b[31;47m";
    const char xf[] = "\x1b[31m";
    const char ofwb[] = "\x1b[34;47m";
    const char of[] = "\x1b[34m";
    const char reset[] = "\x1b[0m";

    int x;

    for (x = 0; x < 9; x++)
    {
        switch (g[x])
        {
        case -1:
            if (x % 2)
            {
                printf("%s O %s", ofwb, reset);
            }
            else
            {
                printf("%s O %s", of, reset);
            }
            break;
        case 1:
            if (x % 2)
            {
                printf("%s X %s", xfwb, reset);
            }
            else
            {
                printf("%s X %s", xf, reset);
            }
            break;
        default:
            if (x % 2)
            {
                printf("%s %d %s", bfwb, x + 1, reset);
            }
            else
            {
                printf("%s %d %s", bf, x + 1, reset);
            }
        }
        if ((x + 1) % 3 == 0)
        {
            putchar('\n');
        }
    }

    putchar('\n');
}

int prompt(int p, int *g)
{
    int square;

    printf("%c's turn: Pick a square, 0 to quit: ", p % 2 ? 'O' : 'X');
    scanf("%d", &square);
    if (square < 0 || square > 9)
    {
        puts("Value out of range");
        return -1;
    }

    if (square == 0)
    {
        return square;
    }

    if (g[square - 1] != 0)
    {
        printf("Square %d is occupied, try again\n", square);
        return -1;
    }

    return square;
}

int winner(int *g)
{
    int slice[8];
    int x;

    slice[0] = TL + ML + BL;
    slice[1] = TC + MC + BC;
    slice[2] = TR + MR + BR;
    slice[3] = TL + TC + TR;
    slice[4] = ML + MC + MR;
    slice[5] = BL + BC + BR;
    slice[6] = TL + MC + BR;
    slice[7] = BL + MC + TR;

    for (x = 0; x < 8; x++)
    {
        if (slice[x] == -3)
        {
            showgrid(g);
            puts(">>> O wins!");
            return 1;
        }
        if (slice[x] == 3)
        {
            showgrid(g);
            puts(">>> X wins!");
            return 1;
        }
    }
    return 0;
}
```

`practice.c (main)`

```C
int main()
{
    int grid[] = {
        0, 0, 0,
        0, 0, 0,
        0, 0, 0};
    int ply, p, players, first;

    srand((unsigned)time(NULL));
    puts("Tic-Tac-Toe");
    printf("Number of players (0, 1, 2): ");
    scanf("%d", &players);

    if (players < 0 || players > 2)
    {
        return 1;
    }

    if (players == 1)
    {
        printf("A flip of the bitcon says that ");
        first = rand() % 2;
        if (first)
        {
            puts("you go first\n");
        }
        else
        {
            puts("the computer goes first\n");
        }
    }

    ply = 0;
    while (ply < 9)
    {
        showgrid(grid);
        if (players == 0)
        {
            p = computer(ply, grid);
        }
        else if (players == 1)
        {
            if (ply % 2)
            {
                p = computer(ply, grid);
            }
            else
            {
                while ((p = prompt(ply, grid)) == -1)
                    ;
            }
        }
        else
        {
            while ((p = prompt(ply, grid)) == -1)
                ;
        }

        if (p == 0)
        {
            break;
        }
        grid[p - 1] = ply % 2 ? -1 : 1;
        if (winner(grid))
        {
            break;
        }
        ply++;
    }

    if (ply == 9)
    {
        showgrid(grid);
        puts("Cat's game!");
    }

    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Tic-Tac-Toe
Number of players (0, 1, 2): 1
A flip of the bitcon says that you go first

 1  2  3 
 4  5  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 1
 X  2  3 
 4  5  6 
 7  8  9 

The computer snags the center
 X  2  3 
 4  O  6 
 7  8  9 

X's turn: Pick a square, 0 to quit: 4
 X  2  3 
 X  O  6 
 7  8  9 

The computer moves to square 7
 X  2  3 
 X  O  6 
 O  8  9 

X's turn: Pick a square, 0 to quit: 3
 X  2  X 
 X  O  6 
 O  8  9 

The computer moves to square 2
 X  O  X 
 X  O  6 
 O  8  9 

X's turn: Pick a square, 0 to quit: 8
 X  O  X 
 X  O  6 
 O  X  9 

The computer moves to square 9
 X  O  X 
 X  O  6 
 O  X  O 

X's turn: Pick a square, 0 to quit: 6
 X  O  X 
 X  O  X 
 O  X  O 

Cat's game!
```

