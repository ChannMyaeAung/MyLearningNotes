## Chapter 13 - Calendar



### The calendar program

```shell
chan@CMA:~$ cal
   November 2024      
Su Mo Tu We Th Fr Sa  
                1  2  
 3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30  
```

- We can follow `cal` with a year argument to obtain the full, 12-month calendar for the given year:

```shell
chan@CMA:~$ cal 1999
```

-  We can add a month argument to see the calendar for a specific month in a specific year:

```shell
chan@CMA:~$ cal 11 1999
   November 1999      
Su Mo Tu We Th Fr Sa  
    1  2  3  4  5  6  
 7  8  9 10 11 12 13  
14 15 16 17 18 19 20  
21 22 23 24 25 26 27  
28 29 30              
```

- The month can be specified numerically or by name.



- To see the next three months of output, specify the `-A2` argument:

```shell
chan@CMA:~$ cal -A2
   November 2024         December 2024          January 2025      
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
                1  2   1  2  3  4  5  6  7            1  2  3  4  
 3  4  5  6  7  8  9   8  9 10 11 12 13 14   5  6  7  8  9 10 11  
10 11 12 13 14 15 16  15 16 17 18 19 20 21  12 13 14 15 16 17 18  
17 18 19 20 21 22 23  22 23 24 25 26 27 28  19 20 21 22 23 24 25  
24 25 26 27 28 29 30  29 30 31              26 27 28 29 30 31 
```



### Creating constants and enumerating dates

- For weekday and month names, `const char` pointers - string constants will be used.

```C
const char *weekday[] ={
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
};
```

```C
const char *weekday[] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
```

```C
const char *month[] = {
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
};
```

- Each statement creates an array of pointers: storage for each string is allocated by the program at runtime.
- What remains is an array of addresses.
- Each array in in a sequence that matches the `tm_wday` and `tm_mon` members of the `tm` structure returned from the `localtime()` function.
- For example, the `tm_mon` member for January is numbered 0, and the zeroth element of the `month[]` array is the string for January.
- The `const` classifier declares these arrays as immutable, which prevents them from being accidentally altered elsewhere in the code.
- The strings can be passed to functions, but don't change them!.
- Doing so leads to unpredictable behavior, but not when they're classified as constants.
- Paring with these two arrays, enumerated constants will be used to represent the weekday and month values.
- `enum` helps us define constants similarly to the way an array defines groups of variables with the same data type.
- Values in `enum` are assigned sequentially, starting with 0:

```C
enum{FALSE, TRUE};
```

- Here, constant `FALSE` is defined as 0; `TRUE` as 1.

```C
enum{ALPHA = 1, GAMMA = 5, DELTA, EPSILON, THETA};
```

- This statement defines constant `ALPHA` as 1.
- Constant `GAMMA` is set equal to 5, with the rest of the constants numbered sequentially: `DELTA` is 6, `EPSILON` is 7, and `THETA` is 8.

In the following listing, the `time()` function obtains the current epoch value, a `time_t` data type.

- The `localtime()` function uses this value to fill a `tm` structure, `date`.
- The month, month day, year, and weekday values are then interpreted and output, displaying the current day and date.

```C
int main()
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    time_t now;
    struct tm *date;
	
    // Obtain the current clock tick value
    time(&now);
    
    // Fills the `tm_date` structure with individual time values
    date = localtime(&now);

    printf("Today is %s %d, %d, a %s\n", month[date->tm_mon], date->tm_mday, date->tm_year + 1900, weekday[date->tm_wday]);
    return 0;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is November 25, 2024, a Monday
```





### Demonstrating an algorithm to find the weekday for any day, month and year

`Sakamoto Algorithm`

- **Sakamoto's Algorithm** is a concise method to calculate the day of the week for any given date. 
- It was devised by **Hideo Sakamoto** and is known for its simplicity and efficiency. 

- The algorithm assigns specific values to each month, adjusts the year based on the month, and then applies a formula to compute the day of the week.
- **Key Components:**
  1. **Month Table (`t[]`):**
     - An array that holds values corresponding to each month.
     - These values are used in the calculation to account for the varying number of days in each month.
  2. **Year Adjustment:**
     - If the month is January or February (i.e., month < 3), the year is decremented by 1. This adjustment aligns the months correctly within the Gregorian calendar leap year rules.
  3. **Day of the Week Calculation:**
     - The formula combines the adjusted year, month table value, day, and leap year considerations to compute the day of the week.
     - The result is taken modulo 7 to obtain a value between 0 and 6, each representing a day from Sunday to Saturday.

```C
int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
year -= month < 3;
r = (year + year / 4 - year / 100 + year / 400 + t[month - 1] + day) % 7;
```



```C
// The month value, m, ranges from 0 thru 11 for Jan thru Dec. d is the day of the month, and y is the full year value (tm_year + 1900)
int dayoftheweek(int m, int d, int y)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    int r = 0;
    ;

    // The m < 2 evaluation is either 1 or 0, which is added to the year variable
    y -= m < 2;
    r = (y + y / 4 - y / 100 + y / 400 + t[m] + d) % 7;
    return r;
}

int main()
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    int m, d, y, r;

    m = 10;
    d = 29;
    y = 1999;

    r = dayoftheweek(m, d, y);

    printf("%s %d, %d was a %s\n", month[m], d, y, weekday[r]);
    return 0;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
November 29, 1999 was a Monday
```



**Exercise 13.1**

Modify the source code so that command-line arguments are interpreted as the month, day, and year for which we want to find the day of the week.

**Author's Solution**

```C
int dayoftheweek(int m, int d, int y)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    y -= m < 2;
    int r = (y + y / 4 - y / 100 + y / 400 + t[m] + d) % 7;
    return r;
}

int main(int argc, char *argv[])
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    int m, d, y, r;

    if (argc < 4)
    {
        fprintf(stderr, "Format: month day year\n");
        exit(1);
    }

    // Convert command-line arguments into integers
    m = strtol(argv[1], NULL, 10);

    // No human will type 0 for January
    m--;

    d = strtol(argv[2], NULL, 10);
    y = strtol(argv[3], NULL, 10);

    r = dayoftheweek(m, d, y);

    printf("%s %d, %d was a %s\n", month[m], d, y, weekday[r]);
    return 0;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice 11 29 1999
November 29, 1999 was a Monday
chan@CMA:~/C_Programming/practice$ ./practice 10 19 1987
October 19, 1987 was a Monday

```



**My Solution**

```C
int dayoftheweek(int m, int d, int y)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    if (m < 3)
    {
        y -= 1;
    }
    int r = (y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7;
    return r;
}

int main()
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    int m, d, y, r;

    printf("Enter month, day, year: ");

    if (scanf("%d %d %d", &m, &d, &y) != 3)
    {
        printf("Invalid input format.\n");
        return 1;
    }

    if (m < 1 || m > 12)
    {
        printf("Invalid month. Please enter a value between 1 and 12.\n");
        return 1;
    }
    if (d < 1 || d > 31)
    {
        printf("Invalid day. Please enter a value between 1 and 31.\n");
        return 1;
    }

    r = dayoftheweek(m, d, y);

    printf("%s %d, %d was a %s\n", month[m - 1], d, y, weekday[r]);
    return 0;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Enter date (MM DD YYYY): 11 29 1999
November 29, 1999 was a Monday
chan@CMA:~/C_Programming/practice$ ./practice
Enter date (MM DD YYYY): 10 19 1987
October 19, 1987 was a Monday

```



### Calculating the first day of the month

![Screenshot from 2024-11-25 21-22-50](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-25 21-22-50.png)

- If today is  Monday the 20th, the first of the month is on a Wednesday, always, for any month where Monday is the 20th.
- When given a day of the month and its weekday, the computer can easily calculate upon which day the first of the month falls.

```C
first = weekday - (day % 7) + 1;
```

- Assume today is the 23rd. It's a Thursday, numeric value 4:

```C
first = 4 - (23 % 7) + 1;
first = 4 - 2 + 1;
first  = 3;
```

- When a month has the 23rd fall on a Thursday, the first is on a Wednesday (value 3.)
- The next listing shows code that obtains the current date. 
  - It uses the weekday and day of the month values to work the algorithm, outputting on which weekday the first of the month falls.

```C
int thefirst(int wday, int mday)
{
    int first = wday - (mday % 7) + 1;
    if (first < 0)
    {
        first += 7;
    }
    return first;
}

int main()
{
    enum
    {
        SUNDAY,
        MONDAY,
        TUESDAY,
        WEDNESDAY,
        THURSDAY,
        FRIDAY,
        SATURDAY
    };
    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    printf("If day %d is a %s, the first is on a %s\n", 25, weekday[SATURDAY], weekday[thefirst(SATURDAY, 25)]);
    return 0;
}

```

![Screenshot from 2024-11-25 21-22-50](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-25 21-22-50.png)

```shell
chan@CMA:~/C_Programming/practice$ ./practice
If day 25 is a Saturday, the first is on a Wednesday
```



### Identifying leap years

- Leap year rules:
  - If the year is divisible by both 100 and 400, it's a leap year.
  - If the year is divisible only by 100, it's not a leap year.
  - If the year is divisible by four, it's a leap year.

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

int main()
{
    int y;
    for (y = 1999; y <= 2024; y++)
    {
        if (february(y) == 29)
        {
            printf("%d is a leap year\n", y);
        }
    }
    return 0;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
2000 is a leap year
2004 is a leap year
2008 is a leap year
2012 is a leap year
2016 is a leap year
2020 is a leap year
2024 is a leap year
```



- In Linux, we can check the computer's time zone information by examining the `/etc/localtime` symbolic link.

```shell
chan@CMA:~$ ls -l /etc/localtime
lrwxrwxrwx 1 root root 32 Oct 22 22:38 /etc/localtime -> /usr/share/zoneinfo/Asia/Bangkok
```

- The output we see is local to my system, a value set when Linux was first configured.



### `putenv()` and `tzset()`

#### `putenv()`

- The `putenv()` adds an environment variable to the program's local environment; the change doesn't affect the shell.

```C
int putenv(char *string);
```

- The `string` is the environment entry to add.
- In this case, it's `TZ=GMT` for "time zone equals Greenwich Mean Time".
- This function requires the inclusion of the `stdlib.h` library.



#### `tzset()`

- The `tzset()` function sets the program's time zone but only while it runs.
- The function doesn't otherwise alter the system.

```C
void tzset(void);
```

- The `tzset()` requires no arguments because it uses the `TZ` environment variable to set the program's time zone.
- The `time.h` header must be included for this function to behave properly.



```C
int main()
{
    time_t epoch = 0;

    putenv("TZ=GMT");
    tzset();
    printf("Time is %s", ctime(&epoch));
    return 0;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Time is Thu Jan  1 00:00:00 1970
```

- The output now reflects the true Unix epoch as the program's time zone is changed to GMT internally.
- One decision to make right way with any calendar utility is whether the week starts on Monday or Sunday.



```C
int main()
{
    const char *months[] = {
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"};
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d;
	
    // obtain the current time in clock ticks
    time(&now);
    
    // convert the time_t value into tm structure members
    date = localtime(&now);

    day = date->tm_mday;
    month = date->tm_mon;
    weekday = date->tm_wday;
    
    // calculate the date for Sunday
    sunday = day - weekday;

    printf("  %s\n", months[month]);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    
    // Loop thru days of the week, Sunday thru Sunday + 7
    for (d = sunday; d < sunday + 7; d++)
    {
        // for the current day, output its value in brackets
        if (d == day)
        {
            printf("[%2d]", d);
        }
        else
        {
            // Output every other day without brackets
            printf(" %2d ", d);
        }
    }

    putchar('\n');
    return 0;
}
```

- The `localtime()` function reports details about the current day of the week.

- ```C
  sunday = day_of_the_month - weekday;
  ```

- The `day_of_the_month` value is found in the `tm` structure, member `tm_mday`. 

- Today's `weekday` value is member `tm_wday`.

- As an example, if today is Thursday the 16th, the formula reads:

```C
sunday = 16 - 4;
```

- The `sunday` value is then used in a loop to output the seven days of the week.

- The primary reason for using `sunday + 7` in the loop condition is to ensure that the loop iterates exactly **seven times**, corresponding to the **seven days of the week** (Sunday through Saturday). 

- By setting the loop to run while `d < sunday + 7`, we cover a range of seven days:

  - **Start:** `d = sunday`
  - **End:** `d = sunday + 6`
    (since the loop stops before `d` reaches `sunday + 7`)

  This range (`sunday` to `sunday + 6`) encompasses all seven days of the week:

  - **Sunday:** `d = sunday`
  - **Monday:** `d = sunday + 1`
  - ...
  - **Saturday:** `d = sunday + 6`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
Sun Mon Tue Wed Thu Fri Sat
 24 [25] 26  27  28  29  30 
```

- The loop outputs days of the week, starting at Sunday. The current day is highlighted.
- Of course, this code isn't perfect. If the first of the month falls on any day other than Sunday, we see output like this:

![Screenshot from 2024-11-26 16-53-02](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-26 16-53-02.png)

- Likewise, at the end of the month, we can see output like this:

![Screenshot from 2024-11-26 17-07-34](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-26 17-07-34.png)

- For the first update to the code, in the `for` loop, if the value of variable `d` is less than one, spaces are output instead of the day value.
- Likewise, spaces are output when the day value is greater than the number of days in the current month.
- Determining the last day of the month requires more code.
- Specifically, we must add the `mdays[]` array that lists days of each month, and also the `february()` function.
  - This function is necessary to ensure that the proper number of days in February is known for the current year.
- The `mdays[]` array is added to the code in the variable declaration part of the `main()` function:

```C
int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

- The `february()` function is also added to the code.
- After the `localtime()` function is called, the `february()` function is called to update the `mdays[]` array, element one:

```C
mdays[1] = february(date->tm_year + 1900);
```



`practice.c (main)`

```C
#include <stdio.h>
#include <time.h>

int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }  
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

int main(){
    const char *months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
	int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d;
    
    time(&now);
    date = localtime(&now);
    mdays[1] = february(date->tm_year + 1900);
    
    month = date->tm_mon;
    day = date->tm_mday;
    weekday = date->tm_wday;
    sunday = day - weekday;
    
    printf("  %s\n", months[month]);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    for(d = sunday; d < sunday + 7; d++){
        
        // If date d is out of range, less than 1, or greater than the number of days in the current month, outputs spaces
        if(d < 1 || d > mdays[month]){
            printf("   ");
        }else{
            // Output current day with brackets
            if(d == day){
                printf("[%02d]", d);
            }else{ // Outputs other days without brackets
                printf(" %2d ", d);
            }
        }
    }
    putchar('\n');
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
Sun Mon Tue Wed Thu Fri Sat
 24  25 [26] 27  28  29  30 
```

```C
// Manually setting the date to be close to the end of the month to test the code
month = date->tm_mon;
    day = 29;
    weekday = date->tm_wday;
    sunday = day - weekday;
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
Sun Mon Tue Wed Thu Fri Sat
 27  28 [29] 30  
```



To update the above program, `pmonth` is added, which holds the value of the previous month. 

- The `pmonth` calculation takes place after the current month's value is read and stored in variable `month`:

```C
pmonth = month - 1;
if(pmonth < 0){
    pmonth = 11;
}
```

- The previous month's value is the current month's value minus one.
- If it's January (0), the previous month's value is negative.
- The `if` test catches this condition, in which case the value of `pmonth` is set to 11, December.

```C
#include <stdio.h>
#include <time.h>

int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

int main(){
    const char *months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
	int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d, pmonth;
    
    time(&now);
    date = localtime(&now);
    
    mdays[1] = february(date->tm_year + 1900);
    
    month = date->tm_mon;
    pmonth = month - 1;
    if(pmonth < 0){
        pmonth = 11;
    }
    day = date->tm_mday;
    weekday = date->tm_wday;
    sunday = day - weekday;
    
    // When days from the previous month are calculated
    // If the calculated Sunday date is less than 1, it belongs to the previous month
    if(sunday < 1){
        // Shows the previous and current months
        // Example: "  October / November"
        printf("  %s / %s\n", months[pmonth], months[month]);
        
        // Else if the calculated Saturday date exceeds the number of days in the current month
    }else if(sunday + 6 > mdays[month]){ // Test to see whether days from the next month are output
        
        // For Dec, outputs December and January directly
        // Example: "  December / January"
        if(month == 11){
            printf("  %s / %s\n", months[month], months[0]);
        }else{
            
            // For other months, output the current, and next month names
            printf("  %s / %s\n", months[month], months[month + 1]);
        }
    }else{ // No previous or next month dates appear in the output
        // If the entire week falls within the current month, print only the current month
        // Example: "  November"
        printf("  %s\n", months[month]);
    }
    
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    for(d = sunday; d < sunday + 7; d++){
        
        // If the day is less than 1, it belongs to the previous month
        // The previous month still has days to output
        if(d < 1){
            
            // Print the corresponding day from the previous month
            // Example: " 30 " for day 30 of the previous month
            printf("%2d", mdays[pmonth] + d);
        }else if(d > mdays[month]){ // Else if the day exceeds the number of days in the current month, it belongs to the next month
            
            // Print the corresponding day from the next month
            // Example: " 1 " for day 1 of the next month
            //Output days from the next month using d minus the number of days in the current month
            printf(" %2d ", d - mdays[month]);
        }else{
            if(d == day){
                printf("[%2d]", d);
            }else{
                printf(" %2d ", d);
            }
        }
    }
    
    putchar('\n');
    return 0;
}
```



To update the program, we can also make it to output the current week number as well.

```C
weekno = (9 + day_of_the_year - weekday) / 7;
```

- The `day_of_the_year` value is kept in the `tm` structure as member `tm_yday`.
- The weekday value is `tm` structure member `tm_wday`, where Sunday is zero.
- The expression is divided by seven, which is rounded as an integer value and stored in variable `weekno`.
- The value of `weekno` must be tested for the first week of the year - specifically, when the first of January falls late in the week.
- The `weekno` value returned by the equation is 0. 
- It should be 52, as it's technically the last week of the previous year.

```C
if(weekno == 0){
    weekno = 52;
}
```



```C
#include <stdio.h>
#include <time.h>

int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

int main(){
    const char *months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
	int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d, pmonth, weekno;
    
    time(&now);
    date = localtime(&now);
    
    mdays[1] = february(date->tm_year + 1900);
    
    month = date->tm_mon;
    pmonth = month - 1;
    if(pmonth < 0){
        pmonth = 11;
    }
    day = date->tm_mday;
    weekday = date->tm_wday;
    sunday = day - weekday;
    
    // When days from the previous month are calculated
    // If the calculated Sunday date is less than 1, it belongs to the previous month
    if(sunday < 1){
        // Shows the previous and current months
        // Example: "  October / November"
        printf("  %s / %s\n", months[pmonth], months[month]);
        
        // Else if the calculated Saturday date exceeds the number of days in the current month
    }else if(sunday + 6 > mdays[month]){ // Test to see whether days from the next month are output
        
        // For Dec, outputs December and January directly
        // Example: "  December / January"
        if(month == 11){
            printf("  %s / %s\n", months[month], months[0]);
        }else{
            
            // For other months, output the current, and next month names
            printf("  %s / %s\n", months[month], months[month + 1]);
        }
    }else{ // No previous or next month dates appear in the output
        // If the entire week falls within the current month, print only the current month
        // Example: "  November"
        printf("  %s\n", months[month]);
    }
    
    // Calculate the current week number based on the day of the year and the current weekday
    // Example: If today is the 250th day of the year and it's a Wednesday (wday = 3),
    // weekno = (9 + 250 - 3) / 7 = 256 / 7 = 36
    weekno = (9 + date->tm_yday - weekday) / 7;
    
    // If the calculated week number is 0, it implies that the date belongs to the last week of the previous year
    // Thus, we adjust it to week 52
    // Example: For January 1st, weekno might be calculated as 0, so we set it to 52
    if(weekno == 0){
        weekno = 52;
    }
    printf(" - Week %d\n", weekno);
    
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    for(d = sunday; d < sunday + 7; d++){
        
        // If the day is less than 1, it belongs to the previous month
        // The previous month still has days to output
        if(d < 1){
            
            // Print the corresponding day from the previous month
            // Example: " 30 " for day 30 of the previous month
            printf("%2d", mdays[pmonth] + d);
        }else if(d > mdays[month]){ // Else if the day exceeds the number of days in the current month, it belongs to the next month
            
            // Print the corresponding day from the next month
            // Example: " 1 " for day 1 of the next month
            //Output days from the next month using d minus the number of days in the current month
            printf(" %2d ", d - mdays[month]);
        }else{
            
            // If the day falls within the current month
            if(d == day){
                printf("[%2d]", d);
            }else{
                printf(" %2d ", d);
            }
        }
    }
    
    putchar('\n');
    return 0;
}
```

- ```C
  // Calculate the current week number based on the day of the year and the current weekday
  // Example: If today is the 250th day of the year and it's a Wednesday (wday = 3),
  // weekno = (9 + 250 - 3) / 7 = 256 / 7 = 36
  weekno = (9 + date->tm_yday - weekday) / 7;
  ```

- **Purpose:**
  Determines the current week number of the year.

- **Breakdown:**

  - `date->tm_yday`: The day of the year (0-based, where January 1st is 0).

  - `weekday`: The current day of the week (0 = Sunday, 1 = Monday, ..., 6 = Saturday).

  - **Formula:**
    `(9 + tm_yday - wday) / 7`

  - **Example Calculation:**
    If `tm_yday = 249` (which is the 250th day) and `wday = 3` (Wednesday),

  - ```
    weekno = (9 + 249 - 3) / 7 = 255 / 7 â‰ˆ 36
    ```

- ```C
  // If the calculated week number is 0, it implies that the date belongs to the last week of the previous year
  // Thus, we adjust it to week 52
  // Example: For January 1st, weekno might be calculated as 0, so we set it to 52
  if (weekno == 0)
  {
      weekno = 52;
  }
  ```

- **Purpose:**
  Ensures that week numbers are valid within the range `[1, 52]`. If the calculation results in `0`, it adjusts the week number to `52`, which typically represents the last week of the previous year.

- **Rationale:**
  Dates at the very beginning of the year might fall into the last week of the previous year based on how week numbers are calculated. This adjustment prevents displaying a week number of `0`.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
 - Week 48
Sun Mon Tue Wed Thu Fri Sat
 24  25 [26] 27  28  29  30 

# when hardcoding the day to 30
chan@CMA:~/C_Programming/practice$ ./practice
  November / December
 - Week 48
Sun Mon Tue Wed Thu Fri Sat
 28  29 [30]  1   2   3   4 
 
```



```C
month = date->tm_mon;
    pmonth = month - 1;
    if (pmonth < 0)
    {
        pmonth = 11;
    }

// Manually set day to the first day of the month to test the code
    day = 1;
    weekday = date->tm_wday;
    sunday = day - weekday;
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
 October / November
 - Week 48
Sun Mon Tue Wed Thu Fri Sat
 30  31 [ 1]  2   3   4   5 

```



### Showing a month

```C
int main(){
    int mdays, today, first, day, d;
    
    mdays = 30; // Presets the number of days in the month (for November) 
    today = 26; // Sets today as the 26th
    first = 5; // The first day of the month is on Friday
    
    printf("November 2024\n");
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    
    // Starts with the day counter at 1, the first day of the month
    day = 1;
    
    // Loop thru the days of the month
    while(day <= mdays){
        
        // Loop thru a week, Sunday(0) thru Saturday(6)
        for(d = 0; d < 7; d++){
            
            // Check for the first week of the month
            if(d < first && day == 1){
                printf("    "); // Outputs 4 spaces blank and do not increment the day counter!
            }else{ // Outputs days, now that the first week/day has passed.
                if(day == today){
                    // highlight today
                    printf("[%2d]", day);
                }else{
                    // Regular day output
                    printf(" %2d ", day);
                }
                day++;
                
                // Exit the loop after the last day of the month
                if(day > mdays){
                    break;
                }
            }
        }
        putchar('\n');
    }
    
    return 0;
    
}
```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
November 2024
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25 [26] 27  28  29  30 
 
chan@CMA:~/C_Programming/practice$ cal
   November 2024      
Su Mo Tu We Th Fr Sa  
                1  2  
 3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30
```



#### Using the current date for the above program

```C
int thefirst(int wday, int mday)
{
    // Calculate the starting day of the week for the first date to display
    // Subtract the remainder of the current day divided by 7 from the current weekday
    // Then add 1 to align the days correctly
    int first = wday - (mday % 7) + 1;

    // If the calculated first day is negative, adjust it by adding 7 to wrap around the week
    if (first < 0)
    {
        first += 7;
    }

    // Return the adjusted first day of the week
    return first;
}

int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

int main()
{
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    time_t now;
    struct tm *date;
    int month, today, weekday, year, first, day, d;

    time(&now);
    date = localtime(&now);

    month = date->tm_mon;
    today = date->tm_mday;
    weekday = date->tm_wday;
    year = date->tm_year + 1900;
    mdays[1] = february(year);
    
    // set to the day of the week upon which the first of the month falls
    first = thefirst(weekday, today);
	
    
    // OUtput the current month and year (E.g. November 2024)
    printf("%s %d\n", months[month], year);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");

    day = 1;
    while (day <= mdays[month])
    {
        for (d = 0; d < 7; d++)
        {
            if (d < first && day == 1)
            {
                printf("    ");
            }
            else
            {
                if (day == today)
                {
                    printf("[%2d]", day);
                }
                else
                {
                    printf(" %2d ", day);
                }
                day++;
                if (day > mdays[month])
                {
                    break;
                }
            }
        }
        putchar('\n');
    }

    return 0;
}

```



**Exercise 13.3 & 13.4**

Update the code so that the function output the top heading centered within a certain width. Then modify the `main()` function so that any command-line arguments are parsed as a month-and-year value. Both values must be present and valid; otherwise, the current month is output.



`practice.h`

```C
int thefirst(int wday, int mday);

int february(int year);

void center(char *text, int width);
```

`functions.c`

```C
int thefirst(int wday, int mday)
{
    // Calculate the starting day of the week for the first date to display
    // Subtract the remainder of the current day divided by 7 from the current weekday
    // Then add 1 to align the days correctly
    int first = wday - (mday % 7) + 1;

    // If the calculated first day is negative, adjust it by adding 7 to wrap around the week
    if (first < 0)
    {
        first += 7;
    }

    // Return the adjusted first day of the week
    return first;
}

int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;

    length = strlen(text);
    if (length < width)
    {
        indent = (width - length) / 2;
        for (s = 0; s < indent; s++)
        {
            putchar(' ');
        }
        puts(text);
    }
    else
    {
        for (s = 0; s < width; s++)
        {
            putchar(*text++);
        }
        putchar('\n');
    }
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[])
{
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    time_t now;
    struct tm *date;
    int month, today, weekday, year, first, day, d;

    int a_month, a_year; /* arguments from the command line */
    const int output_width = 27;
    char title[output_width];

    time(&now);
    date = localtime(&now);

    if (argc == 3)
    {
        a_month = strtol(argv[1], NULL, 10);
        a_year = strtol(argv[2], NULL, 10);

        /* check month range */
        if (a_month > 0 && a_month < 13)
        {
            // Set the month in the 'date' structure (0-based indexing)
            date->tm_mon = a_month - 1;    // Jan is zero
            
            // Set the year in the 'date' structure (years since 1900)
            date->tm_year = a_year - 1900; // account for 1900
            date->tm_mday = 1;             // start on the first
            mktime(date);                  // update the date structure
        }
    }

    month = date->tm_mon;
    today = date->tm_mday;
    weekday = date->tm_wday;
    year = date->tm_year + 1900;
    mdays[1] = february(year);
    first = thefirst(weekday, today);

    sprintf(title, "%s %d\n", months[month], year);
    center(title, output_width);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");

    day = 1;
    
    // Loop through each day of the month to display the calendar
    while (day <= mdays[month])
    {
        // Iterate over each day of the week (Sunday to Saturday)
        for (d = 0; d < 7; d++)
        {
            // If it's the first week and the current day hasn't started yet, print spaces
            if (d < first && day == 1)
            {
                printf("    "); // 4 spaces for alignment
            }
            else
            {
                if (day == today)
                {
                    printf("[%2d]", day);
                }
                else
                {
                    printf(" %2d ", day);
                }
                day++;
                if (day > mdays[month])
                {
                    break;
                }
            }
        }
        putchar('\n');
    }

    return 0;
}

```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
      November 2024

Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25 [26] 27  28  29  30 
chan@CMA:~/C_Programming/practice$ ./practice 11 2024
      November 2024

Sun Mon Tue Wed Thu Fri Sat
                    [ 1]  2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
chan@CMA:~/C_Programming/practice$ ./practice 12 2024
      December 2024

Sun Mon Tue Wed Thu Fri Sat
[ 1]  2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 

```



### Displaying a full year

The following listing shows the initialization portion of the `main()` function.

`practice.h`

```C
int february(int year);

void center(char *text, int width);
```



`functions.c`

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;

    length = strlen(text);
    if (length < width)
    {
        // Calculate the number of spaces needed on the left to center the text
        indent = (width - length) / 2;
        
        // Loop to print the indentation spaces
        for (s = 0; s < indent; s++)
        {
            putchar(' '); // Print a single space
        }
        puts(text);
    }
    else
    {
        // If the text length exceeds the desired width, truncate the text to fit the width
        for (s = 0; s < width; s++)
        {
            putchar(*text++); // Print each character and increment the pointer
        }
        putchar('\n');
    }
}
```



```C
int main(int argc, char *argv[])
{
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    struct tm date;
    int month, weekday, year, day, dow;
    const int output_width = 27;
    char title[output_width];
 
    // Initialize the date structure to January 1
    date.tm_year = 2000 - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;

    // Set the timezone to GMT (Greenwich Mean Time)
    putenv("TZ=GMT");
    tzset(); // Apply the timezone setting
    
    // Normalize the date structure and compute the time value
    // mktime modifies the struct tm based on the fields set above
    mktime(&date);

    weekday = date.tm_wday;
    year = date.tm_year + 1900;
    mdays[1] = february(year);

    // dow is updated manually as opposed in a loop because the first weekday of the month isn't the same for every month
    dow = 0; // The weekday loop variable, day-of-the-week (it counts weekdays)
    
    // The outer loop pages thru months of the year
    for (month = 0; month < 12; month++)
    {
        
        // Outputs the month & year, centered and the weekday header row
        sprintf(title, "%s %d", months[month], year);
        center(title, output_width);
        printf("Sun Mon Tue Wed Thu Fri Sat\n");
	
        // Initialize the day of the month, the 1st
        day = 1;
        
        // Loop thru days of the month
        while (day <= mdays[month])
        {
            
            // The first week is special; variable weekday holds the first weekday of the month. Outputs blanks before then.
            if (dow < weekday && day == 1)
            {
                printf("    ");
                
                // Increment the day of the week, Sunday (0) thru Saturday (6)
                dow++;
            }
            else
            {
                printf(" %2d ", day);
                dow++;
                
                // Check for the weekday overflow
                if (dow > 6)
                {
                    // Reset the day of the week back to Sunday (0)
                    dow = 0;
                    putchar('\n');
                }
                day++;
                if (day > mdays[month])
                {
                    break;
                }
            }
        }
        
        // Set the first day of the month for next month
        weekday = dow;
        
        // Reset the day of the week back to Sunday for the next month
        dow = 0;
        printf("\n\n");
    }

    return 0;
}

```

- Variable `dow` works with variable `weekday` to output the first week of January.
- Afterwards, variables `weekday` and `dow` are updated so that the following month's start day is properly set.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
       January 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       February 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28 

        March 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

        April 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30 

         May 1999
Sun Mon Tue Wed Thu Fri Sat
                          1 
  2   3   4   5   6   7   8 
  9  10  11  12  13  14  15 
 16  17  18  19  20  21  22 
 23  24  25  26  27  28  29 
 30  31 

         June 1999
Sun Mon Tue Wed Thu Fri Sat
          1   2   3   4   5 
  6   7   8   9  10  11  12 
 13  14  15  16  17  18  19 
 20  21  22  23  24  25  26 
 27  28  29  30 

         July 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30  31 


        August 1999
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 

      September 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30 

       October 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       November 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30 

       December 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 

```



**Exercise 13.5**

Modify the code so that it accepts a command-lien argument for the year to output. When a command-line argument isn't available, the current year is output. 



**Solution**

`practice.h`

```C
int february(int year);

void center(char *text, int width);
```

`functions.c`

```C
int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

void center(char *text, int width){
    int s, length, indent;
    length = strlen(text);
    
    if(length < width){
        indent = (width - length) / 2;
        for(s = 0; s < indent; s++){
            putchar(' ');
        }
        puts(text);
    }else{
        for(s = 0; s < width; s++){
            putchar(*text++);
        }
        putchar('\n');
    }
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[]){
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    time_t now;
    struct tm date = {0};
    int month, weekday, year, day, dow;
    const int output_width = 27;
    char title[output_width];
    
    if(argc < 2){ // No year provided
        time(&now);
        struct tm *today = localtime(&now);
        year = today->tm_year + 1900;
    }else{ // convert argv[1] to year
        year = strtol(argv[1], NULL, 10);
    }
    
    // Set January 1 of the given year
    date.tm_year = year - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1; // Allow mktime to determine dst
    
    putenv("TZ=GMT");
    tzset();
    
    // Normalize the date
    mktime(&date);
    weekday = date.tm_wday;
    
    mdays[1] = february(year);
    
    dow = 0;
    
    for(month = 0; month < 12; month++){
        sprintf(title, "%s %d", months[month], year);
        center(title, output_width);
        printf("Sun Mon Tue Wed Thu Fri Sat\n");
        
        day = 1;
        while(day <= mdays[month]){
            if(dow < weekday && day == 1){
                printf("    ");
                dow++;
            }else{
                printf(" %2d ", day);
                dow++;
                if(dow > 6){
                    dow = 0;
                    putchar('\n');
                }
                day++;
            }
        }
        weekday = dow;
        dow = 0;
        printf("\n\n");
    }
    return 0;
}
```

- **`mktime` requires a fully initialized `struct tm`:** The `mktime` function depends on all fields in the `struct tm` being set correctly. If we don't initialize fields like `tm_isdst`, unexpected results can occur.

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
       January 2024
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

       February 2024
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29 

        March 2024
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

        April 2024
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30 

         May 2024
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 

         June 2024
Sun Mon Tue Wed Thu Fri Sat
                          1 
  2   3   4   5   6   7   8 
  9  10  11  12  13  14  15 
 16  17  18  19  20  21  22 
 23  24  25  26  27  28  29 
 30 

         July 2024
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

        August 2024
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30  31 


      September 2024
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30 

       October 2024
Sun Mon Tue Wed Thu Fri Sat
          1   2   3   4   5 
  6   7   8   9  10  11  12 
 13  14  15  16  17  18  19 
 20  21  22  23  24  25  26 
 27  28  29  30  31 

       November 2024
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 


       December 2024
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 
 
 chan@CMA:~/C_Programming/practice$ ./practice 1999
       January 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       February 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28 

        March 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

        April 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30 

         May 1999
Sun Mon Tue Wed Thu Fri Sat
                          1 
  2   3   4   5   6   7   8 
  9  10  11  12  13  14  15 
 16  17  18  19  20  21  22 
 23  24  25  26  27  28  29 
 30  31 

         June 1999
Sun Mon Tue Wed Thu Fri Sat
          1   2   3   4   5 
  6   7   8   9  10  11  12 
 13  14  15  16  17  18  19 
 20  21  22  23  24  25  26 
 27  28  29  30 

         July 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30  31 


        August 1999
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 

      September 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30 

       October 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       November 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30 

       December 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 

```



### Putting the full year into a grid

- The required update is to the `center()` function.
- The function centers the month and year within a given width but doesn't pad out the rest of the row of text.
- To line up the months in a grid, the header row one must be output at a consistent size.
- The next listing shows the required updates to the `center()` function for row-by-row output.
- The `width` argument centers the text and sets the number of spaces to pad on both sides.

```C
void center(char *text, int width){
    int s, length, indent;
    
    length = strlen(text);
    
    if(length < width){
        indent = (width - length) / 2;
        for(s = 0; s < indent; s++){
            puthcar('\n');
        }
        
        // instead of a puts() function, outputs the string one character at a time
        while(*text){
            putchar(*text);
            text++;
            s++; // tracks s to determine the final output width
        }
        // Output spaces to match the width value
        for(; s < width; s++){
            putchar(' ');
        }
    }else{
        for(s = 0; s < width; s++){
            putchar(*text++);
        }
    }
}
```



#### Full Program to output a full year in a grid

`practice.h`

```C
enum
{
    COLUMNS = 3
};

int february(int year);

void center(char *text, int width);
```

`functions.c`

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;
    length = strlen(text);

    if (length < width)
    {
        indent = (width - length) / 2;
        for (s = 0; s < indent; s++)
        {
            putchar(' ');
        }
        
        // instead of a puts() function, outputs the string one character at a time
        while (*text)
        {
            putchar(*text);
            text++;
            s++;
        }
        
        // Output spaces to match the width value
        for (; s < width; s++)
        {
            putchar(' ');
        }
    }
    else
    {
        for (s = 0; s < width; s++)
        {
            putchar(*text++);
        }
    }
}
```

`practice.c (main)`

- `int dotm[12]`:  The `dotm[]` (day of the month) array holds the starting day for each month in the year.
  - Its values are the same as the `weekday` variable, 0 through 6.
  - The `weekday` variable already holds the day of the week for January 1.
  - It's stored in element 0 of the `dotm[]` array.

```C
int main(int argc, char *argv[]){
     const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};

    // Array with the number of days in each month
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int dotm[12]; // Array to hold the starting day for each month in the year
    int month, weekday, year, day, dow, c, week;
    char int output_width = 27;
    char title[output_width];
    
    // Check if a year is provided as a command-line arg
    if(argc < 2){ // If no argument is provided,use the current year
        time(&now); // Get the current time
        struct tm *today = localtime(&now); // Convert to local time
        year = today->tm_year + 1900; // Extract the year
    }else // If a year is provided
    {
        year = strtol(argv[1], NULL, 10); // Convert argument to an integer year
    }

    // Initialize the date structure for January 1st of the given year
    date.tm_year = year - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1; // Let `mktime` determine daylight savings time
    putenv("TZ=GMT"); // Set time zone to GMT
    tzset(); // Apply time zone settings
    mktime(&date); // Normalize the date

    weekday = date.tm_wday; // Get the day of the week for January 1
    mdays[1] = february(year); // Adjust February days for leap years
    dotm[0] = weekday; // First day of the year

    // Calculate the first day of each month
    for (month = 1; month < 12; month++)
    {
        dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
    }

    // Loop through the months in sets of `COLUMNS` (3 months per row)
    for (month = 0; month < 12; month += COLUMNS)
    {
        // Print the titles for each month in the row
        for (c = 0; c < COLUMNS; c++)
        {
            sprintf(title, "%s %d", months[month + c], year); // Format the title
            center(title, output_width); // Center the title
            printf("   "); // Spacing between columns
        }
        putchar('\n'); // New line after titles

        // Print the weekday headers for each month
        for (c = 0; c < COLUMNS; c++)
        {
            printf("Sun Mon Tue Wed Thu Fri Sat    "); // Weekday names
        }
        putchar('\n'); // New line after headers

        // Print the first week of each month
        for (c = 0; c < COLUMNS; c++)
        {
            day = 1;
            for (dow = 0; dow < 7; dow++) // Loop through the days of the week
            {
                
                // If the first of the month weekday hasn't happened, outputs spaces
                if (dow < dotm[month + c]) // Print spaces for days before the 1st
                {
                    printf("    ");
                }
                else // Print the days starting from the 1st
                {
                    printf(" %2d ", day++);
                }
            }
            printf("  ");
            dotm[month + c] = day; // Update the first day of the next week
        }
        putchar('\n'); // New line after the first week

        // Print the remaining weeks
        for (week = 1; week < 6; week++) // Up to 6 weeks per month
        {
            for (c = 0; c < COLUMNS; c++) // Loop through each column (month)
            {
                day = dotm[month + c]; // Start with the current day
                for (dow = 0; dow < 7; dow++) // Loop through the days of the week
                {
                    if (day <= mdays[month + c]) // Print the day if within range
                    {
                        printf(" %2d ", day);
                    }
                    else // Print spaces if out of range
                    {
                        printf("    ");
                    }
                    day++; // Move to the next day
                }
                printf("  ");
                dotm[month + c] = day; // Update the first day of the next week
            }
            putchar('\n'); // New line after each week
        }
        putchar('\n'); // New line between rows of months
    }

    return (0); // Successful execution
}

}
```

- ```C
  dotm[0] = weekday;
  
  for(month = 1; month < 12; month++){
      dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
  }
  ```

- The statement in the `for` loop totals the values of the number of days in the previous month, `mdays[month - 1]`, with the starting day of the week for the previous month, `dotm[month - 1]`.

- The total is modulo 7, which yields the starting day of the week for the month represented by variable `month`.

  - **`% 7`:** The modulus operation ensures that the result wraps around to stay within the range of valid days of the week (0â€“6).

- When the loop is complete, the `dotm[]` array holds the starting weekday for the first of each month in a given year.

- Assume the year is 2024 (a leap year) and January 1 is a Monday (`weekday = 1`). The `mdays` array contains the number of days in each month:

```C
mdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

```

- **January (`dotm[0]`):** Starts on Monday (`dotm[0] = 1`).
- February (`dotm[1]`):
  - Days in January: 31 (`mdays[0]`).
  - Starting day of February: `(31 + 1) % 7 = 32 % 7 = 4` (Thursday).
  - `dotm[1] = 4`.
- March (`dotm[2]`):
  - Days in February: 29 (`mdays[1]`).
  - Starting day of March: `(29 + 4) % 7 = 33 % 7 = 5` (Friday).
  - `dotm[2] = 5`.
- April (`dotm[3]`):
  - Days in March: 31 (`mdays[2]`).
  - Starting day of April: `(31 + 5) % 7 = 36 % 7 = 1` (Monday).
  - `dotm[3] = 1`.

This process continues for all months, correctly calculating the starting day of the week for each one.

##### **Visualization**

Assume `COLUMNS = 3`. Here's what happens for January, February, and March:

Step 1: First Row Titles

```plaintext
        January 2024                February 2024                March 2024        

```

Step 2: Weekday Headers

```plaintext
Sun Mon Tue Wed Thu Fri Sat    Sun Mon Tue Wed Thu Fri Sat    Sun Mon Tue Wed Thu Fri Sat

```

**Step 3: First Week**

- January starts on Monday (`dotm[0] = 1`).
- February starts on Thursday (`dotm[1] = 4`).
- March starts on Friday (`dotm[2] = 5`).

```
             1   2   3   4   5   6        1   2   3        1   2   

```

**Step 4: Remaining Weeks**

Days are printed week by week until the end of the month.

`Output`

![Screenshot from 2024-11-27 22-36-58](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-27 22-36-58.png)



### A calendar in color

- An ANSI escape sequence is a series of characters, the first of which is the escape character, ASCII 27, hex 1B.
- This character must be output directly.

```C
#define RESET "\x1b[0m"
#define BOLD "\x1b[1m"
#define FAINT "\x1b[2m"
#define UNDERLINE "\x1b[4m"
#define BLINK "\x1b[5m"
#define INVERSE "\x1b[7m"

int main(int argc, char *argv[])
{
    printf("%sBold text%s\n", BOLD, RESET);
    printf("%sFaint text%s\n", FAINT, RESET);
    printf("%sUnderlined text%s\n", UNDERLINE, RESET);
    printf("%sBlinking text%s\n", BLINK, RESET);
    printf("%sInverted text%s\n", INVERSE, RESET);
    return (0);
}
```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Bold text
Faint text
Underlined text
Blinking text
Inverted text
```

![Screenshot from 2024-11-27 22-45-53](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-27 22-45-53.png)

| Color   | Foreground Code | Background Code | Foreground Sequence | Background Sequence |
| ------- | --------------- | --------------- | ------------------- | ------------------- |
| Black   | 30              | 40              | `\x1b[30m`          | `\x1b[40m`          |
| Red     | 31              | 41              | `\x1b[31m`          | `\x1b[41m`          |
| Green   | 32              | 42              | `\x1b[32m`          | `\x1b[42m`          |
| Yellow  | 33              | 43              | `\x1b[33m`          | `\x1b[43m`          |
| Blue    | 34              | 44              | `\x1b[34m`          | `\x1b[44m`          |
| Magenta | 35              | 45              | `\x1b[35m`          | `\x1b[45m`          |
| Cyan    | 36              | 46              | `\x1b[36m`          | `\x1b[46m`          |
| White   | 37              | 47              | `\x1b[37m`          | `\x1b[47m`          |



```C
int main(int argc, char *argv[])
{
    int f, b;

    for (f = 0; f < 8; f++)
    {
        for (b = 0; b < 8; b++)
        {
            printf("\x1b[%d, %dm %d:%d ", f + 30, b + 40, f + 30, b + 40);
        }
        printf("\x1b[0m\n");
    }
    return (0);
}
```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
 30:40  30:41  30:42  30:43  30:44  30:45  30:46  30:47 
 31:40  31:41  31:42  31:43  31:44  31:45  31:46  31:47 
 32:40  32:41  32:42  32:43  32:44  32:45  32:46  32:47 
 33:40  33:41  33:42  33:43  33:44  33:45  33:46  33:47 
 34:40  34:41  34:42  34:43  34:44  34:45  34:46  34:47 
 35:40  35:41  35:42  35:43  35:44  35:45  35:46  35:47 
 36:40  36:41  36:42  36:43  36:44  36:45  36:46  36:47 
 37:40  37:41  37:42  37:43  37:44  37:45  37:46  37:47 

```



### Generating a tight-but-colorful calendar

`practice.h`

```C
#define BOLD 1
#define BLACK 0
#define CYAN 6
#define WHITE 7
#define FG 30
#define BG 40

enum
{
    COLUMNS = 3,
};

int february(int year);

void center(char *text, int width);

void color_output(int d);
```

`functions.c`

```C
int february(int year){
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width){
    int s, length, indent;
    length = strlen(text);
    
    if(length < width){
        indent = (width - length) / 2;
        for(s = 0; s < indent; s++){
            putchar(' ');
        }
        while(*text){
            putchar(*text);
            text++;
            s++;
        }
        for(; s < width; s++){
            putchar(' ');
        }
    }else{
        for(S = 0; s < width; s++){
            putchar(*text++);
        }
    }
}

void color_output(int d){
    
    // d % 2 == 1?
    if (d % 2)
    {
        // Outputs odd days with a black foreground and white background
        printf("\x1b[%d;%dm%2d", FG + BLACK, BG + WHITE, d);
    }
    else
    {
        // Output even days with a white foreground and cyan background
        printf("\x1b[%d;%dm%2d", FG + WHITE, BG + CYAN, d);
    }
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[]){
    onst char *months[] = {
        "Jan", "Feb", "March", "April",
        "May", "June", "July", "Aug",
        "Sep", "Oct", "Nov", "Dec"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    // Array to store the starting weekday of each month
    int dotm[12];
    time_t now;
    struct tm date;
    int month, weekday, year, day, dow, c, week;
    const int output_width = 14;
    char title[output_width];
    
    // Check if a year is provided as a command-line argument
    if(argc < 2){ // If no argument is provided, use the current year
        time(&now);
        struct tm *today = localtime(&now);
        year = today->tm_year + 1900;
    }else{ // If a year is provided
        year = strtol(argv[1], NULL, 10);
    }
    // Set the date structure to January 1st of the specified year
    date.tm_year = year - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1;
    
    putenv("TZ=GMT");
    tzset();
    
    mktime(&date);
    
    // Retrieve the weekday of January 1st
    weekday = date.tm_wday; // 0 = Sunday, ..., 6 = Saturday
    mdays[1] = february(year);
    dotm[0] = weekday;
    
    // Calculate the starting weekday for each subsequent month
    for(mont = 1; month < 12; month++){
        dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
    }
    
    for(month = 0; month < 12; month += COLUMNS){
        for(c = 0; c < COLUMNS; c++){
            sprintf(title, "%s %d", months[month + c], year);
            center(title, output_width);
            printf("  ");
        }
        putchar('\n');
        
        for(c = 0 ; c < COLUMNS; c++){
            printf("\x1b[%dm%s", BOLD, "Su");
            printf("\x1b[0m%s", "Mo");
            printf("\x1b[%dm%s", BOLD, "Tu");
            printf("\x1b[0m%s", "We");
            printf("\x1b[%dm%s", BOLD, "Th");
            printf("\x1b[0m%s", "Fr");
            printf("\x1b[%dm%s", BOLD, "Sa");
            printf("\x1b[0m  ");
        }
        putchar('\n');
        
        for(c = 0; c < COLUMNS; c++){
            day = 1;  // Start from the first day of the month
            for(dow = 0; dow < 7; dow++){
                if(dow < dotm[month + c]){
                    // Print spaces before the first day of the month
                    printf("  ");
                }else{
                    color_output(day);
                    day++;
                }
            }
            
            // Reset formatting and add spacing between columns
            printf("\x1b[0m  ");
            
            // Update the day for the current month in 'dotm' array
            dotm[month + c] = day; 
        }
        
        // Reset formatting and move to the next line after the first week
        printf("\x1b[0m\n");
        
        // Print the remaining weeks (up to 5 weeks per month)
        for(week = 1; week < 6; week++){
            for(c = 0; c < COLUMNS; c++){
                day = dotm[month + c]; // Continue from the last day printed
                for(dow = 0; dow < 7; dow++){
                    if(day <= mdays[month + c]){
                        color_output(day);
                    }else{
                        printf("\x1b[0m  ");
                    }
                    day++;
                }
                printf("\x1b[0m  ");
                // Update the day for the current month in 'dotm' array
                dotm[month + c] = day;
            }
            
            // Reset formatting and move to the next line after each week
            printf("\x1b[0m\n");
        }
        putchar('\n');
    }
    return 0;
}
```

- ```C
  for(mont = 1; month < 12; month++){
          dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
      }
  ```

  - **`mdays[month - 1]`:** This gives the number of days in the previous month.

  - **`dotm[month - 1]`:** This is the starting day of the week for the previous month.

  - Adding these two values gives the total number of days from the start of the year to the start of the current month.

  - **`% 7`:** The modulus operation ensures that the result wraps around to stay within the range of valid days of the week (0â€“6).

  - The result is stored in `dotm[month]`, which now contains the starting day of the week for the current month.

  - Assume the year is 2024 (a leap year) and January 1 is a Monday (`weekday = 1`). The `mdays` array contains the number of days in each month:

  - ```
    mdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    ```

  - **January (`dotm[0]`):** Starts on Monday (`dotm[0] = 1`).

  - February (`dotm[1]`):

    - Days in January: 31 (`mdays[0]`).
    - Starting day of February: `(31 + 1) % 7 = 32 % 7 = 4` (Thursday).
    - `dotm[1] = 4`.

  - March (`dotm[2]`):

    - Days in February: 29 (`mdays[1]`).
    - Starting day of March: `(29 + 4) % 7 = 33 % 7 = 5` (Friday).
    - `dotm[2] = 5`.

  - April (`dotm[3]`):

    - Days in March: 31 (`mdays[2]`).
    - Starting day of April: `(31 + 5) % 7 = 36 % 7 = 1` (Monday).
    - `dotm[3] = 1`.

  This process continues for all months, correctly calculating the starting day of the week for each one.

- The space between months is reduced to two.

- Various `putchar('\n')` statements are replaced by `printf()` statements that also output the ANSI escape sequence to reset the colors back to normal.

- This change avoided color spill at the end of each line of output.

- Color spill is something we must be aware of when coding color output: always terminate the color output, resetting it when colored text is no longer required.

- The reset sequence is `\x1b[0m`.

`Output`

![Screenshot from 2024-11-28 16-52-14](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-28 16-52-14.png)

**Exercise 13.6**

Your task for this exercise is to modify the source code to detect the current day of the year and output this one specific day in a special color. Obviously, if the calendar isn't showing the current year, the code won't highlight today's date.

`practice.h`

```C
#define BOLD 1
#define BLACK 0
#define CYAN 6
#define WHITE 7
#define RED 1
#define FG 30
#define BG 40

enum
{
    COLUMNS = 3,
};

int february(int year);

void center(char *text, int width);

void color_output(int d);

void color_today(int d);
```

`functions.c`

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;
    length = strlen(text);

    if (length < width)
    {
        indent = (width - length) / 2;
        for (s = 0; s < indent; s++)
        {
            putchar(' ');
        }
        while (*text)
        {
            putchar(*text);
            text++;
            s++;
        }
        for (; s < width; s++)
        {
            putchar(' ');
        }
    }
    else
    {
        for (s = 0; s < width; s++)
        {
            putchar(*text++);
        }
    }
}

void color_output(int d)
{
    if (d % 2)
    {
        printf("\x1b[%d;%dm%2d", FG + BLACK, BG + WHITE, d);
    }
    else
    {
        printf("\x1b[%d;%dm%2d", FG + WHITE, BG + CYAN, d);
    }
}

void color_today(int d)
{
    printf("\x1b[%d;%dm%2d", FG + RED, BG + BLACK, d);
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[]){
    onst char *months[] = {
        "Jan", "Feb", "March", "April",
        "May", "June", "July", "Aug",
        "Sep", "Oct", "Nov", "Dec"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    // Array to store the starting weekday of each month
    int dotm[12];
    time_t now;
    struct tm date, *today;
    int month, weekday, year, day, dow, c, week;
    const int output_width = 14;
    char title[output_width];
    
    /* these two statements are moved outside of the if decision */
    /* It's necessary to always know the current date, even when another year is specified at the command prompt*/
    time(&now); 
    today = localtime(&now);
    
    // Check if a year is provided as a command-line argument
    if(argc < 2){ // If no argument is provided, use the current year
        date.tm_year = today->tm_year;
    }else{ // If a year is provided
        date.tm_year = strtol(argv[1], NULL, 10) - 1900;
    }
    // Set the date structure to January 1st of the specified year
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1;
    
    putenv("TZ=GMT");
    tzset();
    
    mktime(&date);
    
    // Retrieve the weekday of January 1st
    weekday = date.tm_wday; // 0 = Sunday, ..., 6 = Saturday
    year = date.tm_year + 1900;
    mdays[1] = february(year);
    dotm[0] = weekday;
    
    // Calculate the starting weekday for each subsequent month
    for(mont = 1; month < 12; month++){
        dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
    }
    
    for(month = 0; month < 12; month += COLUMNS){
        for(c = 0; c < COLUMNS; c++){
            sprintf(title, "%s %d", months[month + c], year);
            center(title, output_width);
            printf("  ");
        }
        putchar('\n');
        
        for(c = 0 ; c < COLUMNS; c++){
            printf("\x1b[%dm%s", BOLD, "Su");
            printf("\x1b[0m%s", "Mo");
            printf("\x1b[%dm%s", BOLD, "Tu");
            printf("\x1b[0m%s", "We");
            printf("\x1b[%dm%s", BOLD, "Th");
            printf("\x1b[0m%s", "Fr");
            printf("\x1b[%dm%s", BOLD, "Sa");
            printf("\x1b[0m  ");
        }
        putchar('\n');
        
        // calculate and output the first week
        for(c = 0; c < COLUMNS; c++){
            day = 1;  // Start from the first day of the month
            for(dow = 0; dow < 7; dow++){
                if(dow < dotm[month + c]){
                    // Print spaces before the first day of the month
                    printf("  ");
                }else{
                    /* a decision is made here when today happens in the first week of the month. First check the date */
                    if(today->tm_year + 1900 == year && today->tm_mon == month + c && today->tm_mday == day){
                        color_today(day);
                    }else{
                        color_output(day);
                    }
                    day++;
                }
            }
            
            // Reset formatting and add spacing between columns
            printf("\x1b[0m  ");
            
            // Update the day for the current month in 'dotm' array
            dotm[month + c] = day; 
        }
        
        // Reset formatting and move to the next line after the first week
        printf("\x1b[0m\n");
        
        // Print the remaining weeks (up to 5 weeks per month)
        for(week = 1; week < 6; week++){
            for(c = 0; c < COLUMNS; c++){
                day = dotm[month + c]; // Continue from the last day printed
                for(dow = 0; dow < 7; dow++){
                    /* test for today every day of the month */
                    if(today->tm_year + 1900 == year && today->tm_mon == month + c && today->tm_mday == day){
                        color_today(day);
                    }else{
                        if(day <= mdays[month + c]){
                            color_output(day);
                        }else{
                            printf("\x1b[0m  ");
                        }
                    }
                    day++;
                }
                printf("\x1b[0m  ");
                // Update the day for the current month in 'dotm' array
                dotm[month + c] = day;
            }
            
            // Reset formatting and move to the next line after each week
            printf("\x1b[0m\n");
        }
        putchar('\n');
    }
    return 0;
}
```



`Output`

![Screenshot from 2024-11-28 18-36-31](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-28 18-36-31.png)



### Coloring holidays

`practice.h`

```C
// Functions.c

#define BOLD 1
#define BLACK 0
#define CYAN 6
#define WHITE 7
#define RED 1
#define YELLOW 3
#define FG 30
#define BG 40

// functions.c
enum
{
    COLUMNS = 3,
};

int february(int year);

void center(char *text, int width);

void color_output(int d);

void color_today(int d);

void color_holiday(int d);

// Functions_2.c
#define FIRST_WEEK h->day < 8
#define SECOND_WEEK h->day > 7 && h->day < 15
#define THIRD_WEEK h->day > 14 && h->day < 22
#define FOURTH_WEEK h->day > 21 && h->day < 29
#define LAST_WEEK h->day > 24 && h->day < 32
struct holiday
{
    int month;
    int day;
    int year;
    int wday;
    char *name;
};

enum weekdays
{
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
};

int easter(struct holiday *hday);
int weekend(int holiday, int mday, int wday);
int isholiday(struct holiday *h);
```

`functions_2.c`

```C
int easter(struct holiday *hday)
{
    int Y, a, c, e, h, k, L;
    double b, d, f, g, i, m, month, day;

    Y = hday->year;
    a = Y % 19;
    b = floor(Y / 100);
    c = Y % 100;
    d = floor(b / 4);
    e = (int)b % 4;
    f = floor((b + 8) / 25);
    g = floor((b - f + 1) / 3);
    h = (19 * a + (int)b - (int)d - (int)g + 15) % 30;
    i = floor(c / 4);
    k = c % 4;
    L = (32 + 2 * e + 2 * (int)i - h - k) % 7;
    m = floor((a + 11 * h + 22 * L) / 451);
    month = floor((h + L - 7 * m + 114) / 31) - 1;
    day = ((h + L - 7 * (int)m + 114) % 31) + 1;

    if (hday->month == month && hday->day == day)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int weekend(int holiday, int mday, int wday)
{
    // Narrow down the range of dates to check for Friday & Monday
    if (mday > holiday - 2 && mday < holiday + 2)
    {
        // If the day is 1 day before the holiday and it's Friday?
        if (mday == holiday - 1 && wday == FRIDAY)
        {
            return 2;
        }
        
        // If the day is 1 day after the holiday and it's Monday?
        if (mday == holiday + 1 && wday == MONDAY)
        {
            return 2;
        }
        
        // Checking for the actual holiday
        if (mday == holiday)
        {
            return 1;
        }
    }
    return 0;
}
int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Years Day",
        "Martin Luther King Day",
        "Presidents Day",
        "Memorial Day",
        "Juneteenth",
        "Independence Day",
        "Labor Day",
        "Columbus Day",
        "Veterans Day",
        "Thanksgiving",
        "Christmas",
        "Easter"};
    int r;

    enum months
    {
        JANUARY,
        FEBRUARY,
        MARCH,
        APRIL,
        MAY,
        JUNE,
        JULY,
        AUGUST,
        SEPTEMBER,
        OCTOBER,
        NOVEMBER,
        DECEMBER
    };

    // Check for New Year's Day (Dec 31st Friday)
    if (h->month == DECEMBER && h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        return 2;
    }
    // Check for New Year's Day (Jan 1st)
    if (h->month == JANUARY && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }
    // Check for New Year's Day (Jan 2nd Monday)
    if (h->month == JANUARY && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for Martin Luther King Day (3rd Monday in January)
    if (h->month == JANUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[1];
            return 1;
        }
    }

    // Check for Presidents Day (3rd Monday in February)
    if (h->month == FEBRUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[2];
            return 1;
        }
    }

    // Check for Memorial Day (Last Monday in May)
    if (h->month == MAY && h->wday == MONDAY)
    {
        if (LAST_WEEK)
        {
            h->name = n[3];
            return 1;
        }
    }

    // Check for Juneteenth (June 19th)
    if (h->month == JUNE)
    {
        r = weekend(19, h->day, h->wday);
        h->name = n[4];
        return r;
    }

    // Check for Independence Day (July 4th)
    if (h->month == JULY)
    {
        r = weekend(4, h->day, h->wday);
        h->name = n[5];
        return r;
    }

    // Check for Labor Day (1st Monday in September)
    if (h->month == SEPTEMBER && h->wday == MONDAY)
    {
        if (FIRST_WEEK)
        {
            h->name = n[6];
            return 1;
        }
    }

    // Check for Columbus Day (2nd Monday in October)
    if (h->month == OCTOBER && h->day == MONDAY)
    {
        if (SECOND_WEEK)
        {
            h->name = n[7];
            return 1;
        }
    }

    // Check for (November 11th)
    if (h->month == NOVEMBER)
    {
        // Thanksgiving is the 4th Thursday in November
        if (h->wday == THURSDAY && FOURTH_WEEK)
        {
            h->name = n[9];
            return 1;
        }
        // Veterans Day is the 11th
        r = weekend(11, h->day, h->wday);
        h->name = n[8];
        return r;
    }

    // Check for Christmas (Dec 25th)
    if (h->month == DECEMBER)
    {
        r = weekend(25, h->day, h->wday);
        h->name = n[10];
        return r;
    }

    // Check for Easter
    r = easter(h);
    if (r == 1)
    {
        h->name = n[11];
        return r;
    }

    return 0;
}

```

`functions.c`

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;
    length = strlen(text);

    if (length < width)
    {
        indent = (width - length) / 2;
        for (s = 0; s < indent; s++)
        {
            putchar(' ');
        }
        while (*text)
        {
            putchar(*text);
            text++;
            s++;
        }
        for (; s < width; s++)
        {
            putchar(' ');
        }
    }
    else
    {
        for (s = 0; s < width; s++)
        {
            putchar(*text++);
        }
    }
}

void color_output(int d)
{
    if (d % 2)
    {
        printf("\x1b[%d;%dm%2d", FG + BLACK, BG + WHITE, d);
    }
    else
    {
        printf("\x1b[%d;%dm%2d", FG + WHITE, BG + CYAN, d);
    }
}

void color_today(int d)
{
    printf("\x1b[%d;%dm%2d", FG + RED, BG + BLACK, d);
}

void color_holiday(int d)
{
    printf("\x1b[%d;%dm%2d", FG + YELLOW, BG + BLACK, d);
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[]){
    onst char *months[] = {
        "Jan", "Feb", "March", "April",
        "May", "June", "July", "Aug",
        "Sep", "Oct", "Nov", "Dec"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    // Array to store the starting weekday of each month
    int dotm[12];
    time_t now;
    struct tm date, *today;
    int month, weekday, year, day, dow, c, week;
    const int output_width = 14;
    char title[output_width];
    struct holiday h;
    
    /* these two statements are moved outside of the if decision */
    /* It's necessary to always know the current date, even when another year is specified at the command prompt*/
    time(&now); 
    today = localtime(&now);
    
    // Check if a year is provided as a command-line argument
    if(argc < 2){ // If no argument is provided, use the current year
        date.tm_year = today->tm_year;
    }else{ // If a year is provided
        date.tm_year = strtol(argv[1], NULL, 10) - 1900;
    }
    // Set the date structure to January 1st of the specified year
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1;
    
    putenv("TZ=GMT");
    tzset();
    
    mktime(&date);
    
    // Retrieve the weekday of January 1st
    weekday = date.tm_wday; // 0 = Sunday, ..., 6 = Saturday
    year = date.tm_year + 1900;
    mdays[1] = february(year);
    dotm[0] = weekday;
    
    // Calculate the starting weekday for each subsequent month
    for(mont = 1; month < 12; month++){
        dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
    }
    
    for(month = 0; month < 12; month += COLUMNS){
        for(c = 0; c < COLUMNS; c++){
            sprintf(title, "%s %d", months[month + c], year);
            center(title, output_width);
            printf("  ");
        }
        putchar('\n');
        
        for(c = 0 ; c < COLUMNS; c++){
            printf("\x1b[%dm%s", BOLD, "Su");
            printf("\x1b[0m%s", "Mo");
            printf("\x1b[%dm%s", BOLD, "Tu");
            printf("\x1b[0m%s", "We");
            printf("\x1b[%dm%s", BOLD, "Th");
            printf("\x1b[0m%s", "Fr");
            printf("\x1b[%dm%s", BOLD, "Sa");
            printf("\x1b[0m  ");
        }
        putchar('\n');
        
        // calculate and output the first week
        for(c = 0; c < COLUMNS; c++){
            h.month = month + c;
            h.year= year;
            h.name = NULL;
            day = 1;  // Start from the first day of the month
            for(dow = 0; dow < 7; dow++){
                if(dow < dotm[month + c]){
                    // Print spaces before the first day of the month
                    printf("  ");
                }else{
                    h.day = day;
                    h.wday = dow;
                    if(isholid(&h) == 1){
                        color_holiday(day);
                    }else if(today->tm_year + 1900 == year && today->tm_mon == month + c && today->tm_mday == day){
                        color_today(day);
                    }else{
                        color_output(day);
                    }
                    day++;
                }
            }
            
            // Reset formatting and add spacing between columns
            printf("\x1b[0m  ");
            
            // Update the day for the current month in 'dotm' array
            dotm[month + c] = day; 
        }
        
        // Reset formatting and move to the next line after the first week
        printf("\x1b[0m\n");
        
        // Print the remaining weeks (up to 5 weeks per month)
        for(week = 1; week < 6; week++){
            for(c = 0; c < COLUMNS; c++){
                h.month = month + c;
                h.year = year;
                h.name = NULL;
                day = dotm[month + c]; // Continue from the last day printed
                for(dow = 0; dow < 7; dow++){
                    h.day = day;
                    h.wday = dow;
                    if(isholiday(&h) == 1){
                        color_holiday(day);
                    }else if(today->tm_year + 1900 == year && today->tm_mon == month + c && today->tm_mday == day){
                        color_today(day);
                    }else{
                        if(day <= mdays[month + c]){
                            color_output(day);
                        }else{
                            printf("\x1b[0m  ");
                        }
                    }
                    
                    day++;
                }
                printf("\x1b[0m  ");
                // Update the day for the current month in 'dotm' array
                dotm[month + c] = day;
            }
            
            // Reset formatting and move to the next line after each week
            printf("\x1b[0m\n");
        }
        putchar('\n');
    }
    return 0;
}
```





`Output`

![Screenshot from 2024-11-28 19-18-07](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-28 19-18-07.png)

- Today (the day I am learning this November 28th 2024) is the Thanksgiving holiday.
- All holidays are highlighted with yellow color and black background.