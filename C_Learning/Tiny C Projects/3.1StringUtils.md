## Chapter 7 - String utilities

### Understanding the string

- It's important to separate what we believe to be a string from a character array.
- Though all strings are character arrays, not all character arrays are strings.
- For example:

```C
char a[3] = {'c', 'a', 't'};
```

- This statement creates a char array `a[]`.  It contains three characters: c-a-t. This array is not a string.
- The following char array, however, is a string:

```C
char b[4] = {'c', 'a', 't', '\0'};
```

- Array `b[]` contains four characters: c-a-t plus null character.
- This terminating null character makes the array a string.
- It can be processed by any C language string function or output as a string.



To save us time, the C compiler lets us craft strings by enclosing characters in double quotes:

```C
char c[4] = "cat";
```

- Array `c[]` is a string. It consists of four characters, c-a-t plus the null character added automatically by the compiler.



But if we declare  a string like this:

```C
char d[3] = "cat";
```

- The compiler allocates three characters for c-a-t, but none for the null character.
- This declaration might be flagged by the compiler or it might not.
- Either way, the string is malformed, and minus the terminating character, manipulating or outputting the string yields unpredictable and potentially wacky results.



Because the compiler automatically allocates storage for a string, the following declaration format is used most often:

```C
char e[] = "cat";
```

- With empty brackets, the compiler calculates the string's storage and assigns the proper number of elements to the array, including the null character.



#### String Considerations

- When allocating string storage, always add one for the null character. Strings are allocated directly as a char array declaration or via a memory-allocation function such as `malloc()`.
- When using string storage, the final character in storage must be the null character, whether or not the buffer is full.
- The `fgets()` function, often used to read string input, automatically accounts for the null character in its second argument, `size`.
  - So, if we use the value 32 as the `size` argument in an `fgets()` statement, the function stores up to 31 characters before it automatically adds the null character to terminate the input string.
- Without the terminating null character, string functions continuing processing bytes until the next random null character is encountered.
  - The effect could be garbage output or worse a segmentation fault.
- One problem with forgetting the null is that often memory is already packed with null characters.
  - A buffer can overflow, but the random null characters already in memory prevent output from looking bad and from our mistake being detected.
  - Never rely upon null characters sitting in memory.



### Measuring a string

- The `strlen()` counts the number of characters in the string ,with escaped characters counted as a single character.

  - For example, the newline `\n` is a single character, though it occupies two character positions.
  - The tab `\t` is also a single character, though the terminal may translate it into multiple spaces when output.

- The `strlen()` can be used elsewhere in the code to manipulate all characters in the string without violating the terminating null character or double-counting escaped characters.

  - ```C
    #include <stdio.h>
    #include <string.h>
    
    int main() {
        char str[] = "Hello, World!";
        size_t len = strlen(str);
    
        printf("Length of the string: %zu\n", len);
    
        // Manipulate characters in the string
        for (size_t i = 0; i < len; i++) {
            if (str[i] == 'o') {
                str[i] = '0';
            }
        }
    
        printf("Modified string: %s\n", str);
    
        return 0;
    }
    ```

- If we want to include the null character in the string's size, we can use the `sizeof` operator, but this trick only works on statically allocated strings (otherwise, the pointer size is returned).

  - The `sizeof` operator returns the size of the array, including the terminating null character. This works for statically allocated strings. For dynamically allocated strings, `sizeof` returns the size of the pointer.

  - ```C
    #include <stdio.h>
    
    int main() {
        char static_str[] = "Hello, World!";
        char *dynamic_str = "Hello, World!";
    
        // Size of statically allocated string (includes null character)
        size_t static_size = sizeof(static_str);
    
        // Size of dynamically allocated string (size of pointer)
        size_t dynamic_size = sizeof(dynamic_str);
    
        printf("Size of static string (including null character): %zu\n", static_size);
        printf("Size of dynamic string (pointer size): %zu\n", dynamic_size);
    
        return 0;
    }
    ```

  - ```sh
    chan@CMA:~/C_Programming/test$ ./final
    
    Size of static string (including null character): 14
    Size of dynamic string (pointer size): 8
    
    ```



In the following code snippets, a comparison is made between values returned by `strlen()` and `sizeof`.

- A string `s[]` is declared which contains 10 characters.

```C
int main(){
    char s[] = "0123456789";
    
    printf("%s is %lu characters long\n", s, strlen(s));
    printf("%s occupies %zu bytes of storage\n", s, sizeof(s));
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
0123456789 is 10 characters long
0123456789 occupies 11 bytes of storage
```

- The `strlen()` function returns the number of characters in the string.
- The `sizeof` returns the amount of storage the string occpies - essentially `strlen() + 1` though, if the string is smaller than its allocated buffer size, `sizeof` returns the buffer size and not `strlen() + 1`.



If we make this change to `s[]` in the code:

```C
char s[20] = "0123456789";
```

```sh
chan@CMA:~/C_Programming/test$ ./final
0123456789 is 10 characters long
0123456789 occupies 20 bytes of storage

```

- Despite the larger buffer size, the null character still sits at element 10 (the 11th character) in the `s[]` array.
- The remainder of the buffer is considered garbage but is still reported as the string's "size" by the `sizeof` operator.



In the following code snippet, empty `a[]` and null `b[]` are tested whether the compiler notices the difference between a null string or an empty string.

- The `strcmp()` is used, which returns zero when both strings are identical.

```C
int main()
{

    char a[5] = {'\0'};
    char b[5];

    if (strcmp(a, b) == 0)
    {
        puts("Strings the the same");
    }
    else
    {
        puts("Strings are not the same");
    }

    // Size according to strlen()
    printf("Length: a = %lu b = %lu\n", strlen(a), strlen(b));

    // Size according to sizeof
    printf("Storage: a = %zu b = %zu\n", sizeof(a), sizeof(b));

    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
Strings are not the same
Length: a = 0 b = 4
Storage: a = 5 b = 5

```

- There's always a random chance that the garbage in memory for string `b[]` may match up with the contents of string `a[]`. 
- Therefore, even this output can't truly be trusted.
- Why does `strlen(b)` return the value 4?
- It's completely legitimate in C to have a string that contains only the terminating null character: such a string's length is zero.
- It can be manipulated by all string functions.



### Returning vs. Modifying directly

- Functions that manipulate strings in C have two ways they can make their changes.
- The first is to return a modified version of the string.
- The second is to manipulate the passed string directly.

For example, the `strcat()` function appends one string to another.

```C
char *strcat(char *dest, const char *src);
```

- String `src` (source) is appended to the end of string `dest` (destination).
- The function assumes enough room is available in the `dest` buffer to successfully append the string.
- Upon success, string `dest` contains both `dest` plus `src`.
- The function returns a pointer to `dest`. 
- The `strcat()` function is an example of manipulating a passed string directly.

```C
char *strappend(char *dest, const char *src){
    return strcat(dest, src);
}

int main(){
     // Array s1[] contains enough storage for both strings
    char s1[32] = "This is another ";
    char s2[] = "fine mess!";
    
    // Pointer to hold the result of the concatenation
    char *s3;
	
    // Append s2 to s1 and store the result in s3
    s3 = strappend(s1, s2);
    printf("%s\n", s3);

    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
This is another fine mess!
```



**Exercise 7.1**

Modify the source code for the above code snippet. Remove the `strcat()` function from the code, replacing it with your own code that sticks the contents of argument `src` to the end of argument `dest`. Do not use the `strcat()` function to accomplish this task! Instead, determine the size of the resulting string and allocate storage for it. The `strappend()` function returns the address of the created string.



**1st Solution**

`main.c`

```C
char *strappend(char *dest, const char *src){
    size_t dest_len = strlen(dest);
    size_t src = strlen(src);
    
    char *result = malloc(sizeof(char *) * (dest_len + src_len + 1));
    
    if(result == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Copy dest to result
    strcpy(result, dest);
    
    // Copy src to the end of result after dest
    strcpy(result + dest_len, src);
    
    return result;
}

int main(){
    char s1[32] = "This is another ";
    char s2[] = "fine mess!";
    char *s3;
    
    s3 = strappend(s1, s2);
    printf("%s\n", s3);
    
    free(s3);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
This is another fine mess!

```



**2nd Solution**

```C
char *strappend(char *dest, char *src){
    char *s, *index;
    
    s = malloc(strlen(dest) + strlen(src) + 1);
    if(s == NULL){
        fprintf(stderr, "Memory Allocation Failed!\n");
        exit(1);
    }
    
    // Pointer to traverse the new string
    index = s;
    
    // Copy dest to the new string
    while(*dest){  //Loop until \0 
        *index = *dest;
        index++;
        dest++;
    }
    
    // Copy src to the end of the new string
    while(*src){
        *index = *src;
        index++;
        src++;
    }
    
    // Null-terminate the new string
    *index = '\0';
    
    return s;
}

int main(){
    char s1[32] = "This is another ";
    char s2[] = "fine mess!";
    char *s3;
    
    s3 = strappend(s1, s2);
    printf("%s\n", s3);
    
    free(s3);
    return 0;
}

```

**Notes**

- `index = s` is an assignment where `index` is set to point to the same memory location as `s`. 
  - This allows us to use `index` to traverse and modify the newly allocated memory without losing the original starting address stored in `s`.
- We return `s` because it holds the address of the newly allocated memory where the concatenated string is stored.
  - If we were to return `index`, it would point to the end of the string after the copying operations, which is not useful.
- `*index = *s` would be incorrect in this context because `*index` and `*s` are dereferencing the pointers, meaning they access the values stored at the memory locations pointed to by `index` and `s`.
  - We want to assign the pointer itself, not the value it points to.
- Condition `while(*dest)`:
  - `*dest` dereferences the pointer `dest` to get the character it points to.
- `*index = *dest`: This line copies the character from the memory location pointed to by `dest` to the memory location pointed to by `index`.
- **Pointer Arithmetic vs. Dereferencing**
  1. **Pointer Arithmetic**:
     - `index++` increments the pointer `index` to point to the next memory location.
     - `dest++` increments the pointer `dest` to point to the next character in the string.
  2. **Deferencing and Incrementing**:
     - `*index++` increments the pointer `index` and then dereferences the new address. This is equivalent to `*(index++)`.
     - `*dest++` increments the pointer `dest` and dereferences the new address. This is equivalent to `*(dest++)`.
- **Why Not Use `*index++`** or `*dest++` In this case?
  - **Correct Usage**: We want to increment the pointers themselves to move to the next character in the string, not the values they point to.
  - **Clarity**: Using `index++` and `dest++` makes it clear that we are moving the pointers to the next position.
  - Using `*index++` or `*dest++` would increment the pointers and then dereference the new address which is not what we want in this context.

```sh
chan@CMA:~/C_Programming/test$ ./final
This is another fine mess!

```



### Changing Case

Changing the 5th bit (counting from 0)  of an ASCII character converts it between uppercase and lowercase.

- **Explanation:**

  - In ASCII, the uppercase letters 'A' to 'Z' have values from 65 to 90.
  - The lowercase letters 'a' to 'z' have values from 97 to 122.
  - The difference between the uppercase and lowercase letters is 32, which corresponds to the 5th bit (0x20 in hexadecimal).

- **Example:**

  - 'A' (65 in decimal) is `01000001` in binary.

  - 'a' (97 in decimal) is `01100001` in binary.

  - The difference is the 5th bit (0x20).



```C
void strupper(char *s){
    // Loops until *s references the null character
    while(*s){
        
        // Converts only lowercase letters
        if(*s >= 'a' && *s <= 'z'){
            // Resets the sixth bit(count from 1) to convert to uppercase
            *s &= 0xdf;
        }
        
        // Proceed to the next character
        s++;
    }
}

int main(){
    char string[] = "Random STRING sample 123@#$";
    printf("Original string: %s\n", string);
    strupper(string);
    printf("Uppercase string: %s\n", string);
    
    return 0;
}
```

- 

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: Random STRING sample 123@#$
Uppercase string: RANDOM STRING SAMPLE 123@#$

```

**Notes**:

- `0xdf`: The hexadecimal value `0xdf` is `11011111` in binary. Using the bitwise AND operator (`&`), this clears the 5th bit of the character effectively converting it to uppercase.
- `char *s` in `void strupper(char *s)` is a pointer to a character, which means ***it points to the first character of the string.***
- `*s` inside the code: This deferences the pointer `s` , giving us the value of the characters it points to.



Due to the layout of the ASCII table, the following statement also works:

```C
*s -= 32; 
```

- Subtracting 32 from each character's ASCII value also converts it to lowercase.

Let's modify our `strupper()` function to create a function that converts characters to lowercase.

```C
void strlower(char *s){
    while(*s){
        if(*s >= 'A' && *s <= 'Z'){
            *s += 32;
        }
        s++;
    }
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: Random STRING sample 123@#$
Uppercase string: random string sample 123@#$

```



**Exercise 7.2**

Write a function, `strcaps()` that capitalizes the first letter of every word in a string. Process the text "This is a sample string" or a similar string that contains several words written in lowercase, including at least one one-letter word. The function modifies the string directly as opposed to generating a new string.



**Solution**

`main.c`

```C
void strcaps(char *s){
    int i = 0;
    
    // Capitalize the first letter
    if(s[0] >= 'a' && s[0] <= 'z'){
        s[0] -= 32;
    }
    
    // Process the rest of the string
    while(s[i] != '\0'){
        // If current character is space and the next character is a letter
        if(s[i] == ' ' && s[i+1] >= 'a' && s[i+1] <= 'z'){
            s[i+1] -= 32; // Convert the next character to uppercase
        }
        i++;
    }
}

int main()
{

    char string[] = "This is a sample string";

    printf("Original string: %s\n", string);
    strcaps(string);
    printf("Uppercase string: %s\n", string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string
Uppercase string: This Is A Sample String
```

**Solution by the author**

`main.c`

```C
void strcaps{
    // Create TRUE/FALSE constants, 0 and 1
    enum{FALSE, TRUE};
    int inword = FALSE;
    
    // Loop thru the string until *s == '\0'
    while(*s){
        if(isalpha(*s)){
            // is a word being processed? If no, a new word has started
            if(!inword){
                *s = toupper(*s);
            	inword = TRUE; // currently inside a word
            }
        }else{ // non-alphabet char here
            inword = FALSE; // not in a word
        }
        s++; // Continue processing the string
    }
}

int main()
{

    char string[] = "This is a sample string";

    printf("Original string: %s\n", string);
    strcaps(string);
    printf("Uppercase string: %s\n", string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string
Uppercase string: This Is A Sample String
```



### Reversing a string

- The key to changing the order of characters in a string is knowing the string's length - where it starts and where it ends.
- For the string's start, the string's variable name is used, which holds the base address.
- The string's ending address isn't stored anywhere; the code must find the string's terminating null character and then use math to calculate the string's size.

![Screenshot from 2024-11-09 15-14-43](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-09 15-14-43.png)

- Figure 7.1 illustrates a string lounging in memory, with both array and pointer notation calling out some of its parts.

- The terminating null character marks the end of the string ,wherever its location may be, measured as offset `n` from the string's start.

- The easiest way to locate the end of a string is to use the `strlen()` function.

  - Add the function's return value to the string's starting location in memory to find the string's end.

- Assume that the `char` pointer `s` references the string's start and that int variable `len` is initialized to zero. 

- If so, this `while` loop locates the string's end where the null character dwells:

  ```C
  while(*s++){
      len++;
  }
  ```

- After this loop is complete, pointer `*s` references the string's terminating null-character, and the value of `len` is equal to the string's length (minus the null character).

- A more readable version of the loop:

  ```C
  while(*s != '\0'){
      len++;
      s++;
  }
  ```

â€‹	

```C
#include <stdio.h>

int main() {
    char str[] = "Hello, World!";
    char *s = str; // Pointer s references the start of the string
    int len = 0; // Initialize len to zero

    // Loop to count the length of the string
    while (*s++) {
        len++;
    }

    // After the loop, s points to the null character
    printf("Length of the string: %d\n", len); // Print the length of the string

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Length of the string: 13
```



- The stupidest way to find the end of a string is to use the `sizeof` operator.
- The operator is not dumb, but when used on a `char` pointer argument, `sizeof` returns the number of bytes the pointer (memory address variable) occupies, not the size of the buffer the pointer references.
- For example, on my computer, a pointer is 8 bytes wide, so no matter what size buffer `*s` refers to, `sizeof(s)` always returns 8.

```C
#include <stdio.h>

int main() {
    char str[] = "Hello, World!";
    char *s = str; // Pointer s references the start of the string

    // Using sizeof on a char pointer
    printf("Size of pointer s: %zu bytes\n", sizeof(s)); // Print the size of the pointer

    // Using sizeof on the actual array
    printf("Size of array str: %zu bytes\n", sizeof(str)); // Print the size of the array

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Size of pointer s: 8 bytes
Size of array str: 14 bytes
```

**Explanation:**

- `char *s = str;` : The pointer `s` references the start of the string `str`.
- `sizeof(s)` : When used on a `char` pointer, `sizeof` returns the size of the pointer itself, not the size of the string it points to.
  - On most systems, this is typically 4 bytes (on a 32-bit system) or 8 bytes (on a 64-bit system).
- `sizeof(str)`: When used on the actual array `str`, `sizeof` returns the total size of the array, including the null character.
  - For the string "Hello, World!", this would be 14 bytes (13 characters + 1 null character).



After obtaining the string's length, the reversing process works backgrounds through the string, copying each character into another buffer, front to back.

- The result is a new string containing the reverse character order of the original.



`hello.h`

```C
char *strrev(char *s);
```

`hello.c`

```C
char *strrev(char *s){
    int len, i;
    char *reversed;
    
    len = 0;
    while(*s){
        len++;
        s++;
    }
    
    // Allocate storage for the reversed string
    // same length as the passed string
    reversed = malloc(sizeof(char) * len);
    
    if(reversed == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Move the pointer s back to the last char of the original string from the null character
    s--;
    i = 0;
    
    // Copies the number of characters from the original string to the reversed string in reverse order
    while(len){
        
        // Copies the character
        *(reversed + i) = *s;
        i++;
        
        // Decrement the offset for the original string & back up the pointer s
        len--;
        s--;
    }
    
    // caps a newly constructed string with the null character!
    *(reversed + i) = '\0';
    
    return reversed;
}
```

- The `strrev()` creates a new string, `reversed`.
- First, a `while` loop calculates the string's size (argument *s).
- Second, storage is allocated for the new string based on the original string's size.
- We don't need to +1 in the `malloc()` to make room for the null character because variable `len` already references the null character's offset.
- Finally, a `while` loop process string `s` backward as it fills string `reversed` with characters.

`main.c`

```C
int main()
{
    char str[] = "A string dwelling in memory";
    printf("Before: %s\n", str);
    printf("After: %s\n", strrev(str));
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Before: A string dwelling in memory
After: yromem ni gnillewd gnirts A
```



#### Reversing a string (Iterative Method)

- Uses two pointers (start and end)
- Swaps characters from both ends moving towards the center
- More space-efficient as it doesn't use the call stack
- Generally preferred in practice

`main.c`

```C
void strrev(char *str){
    int length = strlen(str);
    int start = 0;
    int end = length - 1;
    char temp;
    
    // Loop to reverse the string
    while(start < end){
        // Swaping characters at start and end indices
        temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        
        // Move towards the middle of the string
        start++;
        end--;
    }
}
```

**Walkthrough**:

- **Initial State**:

  - `str = "This is a sample string 123@#!"`
  - `start = 0`, `end = 29`
  - Characters to swap: `str[0] = 'T'` and `str[29] = '!'`

- **First Swap**:

  - Swap `str[0]` and `str[29]`
  - `temp = str[0]` (temp = 'T')
  - `str[0] = str[29]` (str[0] = '!')
  - `str[29] = temp` (str[29] = 'T')
  - Increment `start` to `1`, decrement `end` to `28`
  - `str = "!his is a sample string 123@#T"`

- **Second Swap**:

  - Swap `str[1]` and `str[28]`
  - `temp = str[1]` (temp = 'h')
  - `str[1] = str[28]` (str[1] = '#')
  - `str[28] = temp` (str[28] = 'h')
  - Increment `start` to `2`, decrement `end` to `27`
  - `str = "!#is is a sample string 123@hT"`

- ...And so on until start is less than the end.

- **Final State:**

  - `str = "!#@321 gnirts a elpmas a sihT"`
  - `start = 15`, `end = 14`

  At this point, the `start` index is greater than the `end` index, so the loop terminates. The string has been successfully reversed.

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string 123@#!
Reversed string: !#@321 gnirts elpmas a si sihT

```

#### Reversing a string (Recursive Method):

- More elegant but uses more memory due to recursive calls
- Needs start and end indices as parameters
- Base case is when start >= end

`main.c`

```C
void strrev_recursive(char *str, int start, int end){
    char temp;
    
    // Base case
    if(start >= end){
        return;
    }
    
    // Swap characters
    temp = str[start];
    str[start] = str[end];
    str[end] = temp;
    
    // Recursive call for remaining characters
    strrev_recursive(str, start + 1, end - 1);
}

int main(){
    char str[] = "This is a sample string 123@#!";
    printf("Original string: %s\n", str);
    strrev_recursive(str, 0, strlen(str) - 1);
    printf("Reversed string (recursive): %s\n", str);
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string 123@#!
Reversed string (recursive): !#@321 gnirts elpmas a si sihT
```



###### Things to Note:

Both methods:

- Modify the string in place
- Don't create a new string
- Handle strings of any length
- Are time complexity O(n/2) which simplifies to O(n).

The iterative method is generally preferred because:

1. It is more efficient in terms of space complexity
2. It avoids stack overflow for very long strings
3. It's easier to understand and debug



### Trimming a string

**Extracting portions of a string: left, middle and right**

| Left      | Mid      | Right                |
| --------- | -------- | -------------------- |
| Slice me, | dice me, | make julienne fries! |



- Each function requires at least two arguments: 
  - A string to slice and
  - A character count.
- The middle extraction function also requires an offset.



`left() function`

The following function:

- Extracts `len` characters from the passed string `s`.
- Storage is allocated for a new string.
- The `left()` is easier to code because it copies the first `len` characters of the passed string `s` into the target string `buf`.
- The address of `buf` is returned.

```C
char *left(char *s, int len){
    // storage for the new string
    char *buf;
    int x;
    
    buf = malloc(sizeof(char) * len + 1);
    if(buf == NULL){
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    // Copy the len characters
    // *(s+x) = s[x], *(buf+x) = buf[x]
    for(x = 0; x < len; x++){
        if(*(s+x) == '\0'){
            break;
        }
        
        // copy the charactes to buf
        *(buf+x) = *(s+x);
    }
    
    return buf;
}
```



`right() function`

- Unlike the `left()` function, chopping off the right side of a string requires that the program knows where the string ends.
- Our code must hunt down that terminating null character.
- For the `right()` function, we count backward from the null character to lop off the right side of the string.
- The following function:
  - Borrows its allocation routine from the `left()` function.
  - After the buffer is created, the code hunts for the end of the string, moving the pointer `start` to this location.
  - Then the value of `len` is subtracted from `start` to reposition the pointer to the beginning of the right-end string chunk desired.
  - Then `len` number of characters are copied into the new string.

```C
char *right(char *s, int len){
    char *buf;
    char *start;
    int x;
    
    buf = (char *)malloc(sizeof(char) * len + 1);
    if(buf == NULL){
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    // Initialize start to the beginning of the string
    start = s;
    
    // Move start to the end of the string
    while(*start != '\0'){
        start++;
    }
    
    // Move start back by 'len' characters
    start -= len;
    
    // Check if start is before the beginning of the string
    if(start < s){
        // Exit if len > the length of the string
        exit(1);
    }
    
    // Copy len characters from start to buf
    for(x = 0; x < len; x++){
        *(buf + x) = *(start + x); // same as buf[x] = start[x]
    }
    
    *(buf + x) = '\0';
    
    return buf;
}
```

**Visualization**:

Let's visualize the process with the example string `"Slice me, dice me, make julienne fries!"` and `len = 20`.

1. **Initial State**:
   - `str = "Slice me, dice me, make julienne fries!"`
   - `len = 20`
2. **Find the End of the String**:
   - `start` moves to the end of the string (points to the null character).
3. **Move Back by `len` Characters**:
   - `start` moves back by 20 characters.
   - `start` now points to the character `'m'` in `"make julienne fries!"`.
4. **Copy Characters**:
   - Copy the characters from `start` to `buf`.
   - `buf` will contain `"make julienne fries!"`.
5. **Result**:
   - The rightmost 20 characters are `"make julienne fries!"`.

By following these steps, the function correctly extracts the rightmost `len` characters from the input string.

![Screenshot from 2024-11-10 22-06-37](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-10 22-06-37.png)

`mid() function`

- The `mid()` function has three arguments:

  - ```C
    char *mid(char *s, int offset, int len);
    ```

  - Pointer `s` references the string to slice.

  - Integer `offset` is the character position to start extraction.

  - Integer `len` is the number of characters to extract.

- The `mid()` function performs a straight character-by-character copy from the passed string `s` into the new string buffer `buf`.

- The key is adding the `offset` value when passing the characters:

  - ```C
    *(buf + x) = *(s + offset - 1 + x);
    ```

  - The `offset` value must be reduced by 1 to account for the fact that characters in the string start at offset 0, not offset 1.

```C
char *mid(char *s, int offset, int len){
    char *buf;
    int x;
    
    buf = (char *)malloc(sizeof(char) * len + 1);
    if(buf == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    for(x = 0; x < len; x++){
        *(buf + x) = *(s + offset - 1 + x);
        if(*(buf + x) == '\0'){
            break;
        }
    }
    
    *(buf + x) = '\0';
    
    return buf;
}
```

**Visualization**

Let's visualize the process with the example string `"Slice me, dice me, make julienne fries!"`, `offset = 11`, and `len = 7`.

1. **Initial State**:
   - `str = "Slice me, dice me, make julienne fries!"`
   - `offset = 11`
   - `len = 7`
2. **Memory Allocation**:
   - Allocate memory for 7 characters plus one for the null terminator.
3. **Copy Characters**:
   - Start copying from `str + offset - 1` (which is `str + 10` or `str[10]`).
   - Copy 7 characters from the original string to the buffer.
4. **Characters Copied**:
   - Characters copied: `"dice me"`
   - Buffer after copying: `"dice me"`
5. **Result**:
   - The substring starting at offset 11 and of length 7 is `"dice me"`.



![Screenshot from 2024-11-10 22-25-39](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-10 22-25-39.png)



**Combined Version**

`hello.h`

```C
char *left(char *s, int len);
char *right(char *s, int len);
char *mid(char *s, int offset, int len);
```

`hello.c`

```C
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include "hello.h"
char *left(char *s, int len)
{
    char *buf;
    int x;

    buf = (char *)malloc(sizeof(char) * len + 1);
    if (buf == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    for (x = 0; x < len; x++)
    {
        if (*(s + x) == '\0')
        {
            break;
        }

        *(buf + x) = *(s + x);
    }
	*(buf + x) = '\0';
    return buf;
}
char *right(char *s, int len)
{
    char *buf;
    char *start;
    int x;

    buf = (char *)malloc(sizeof(char) * len + 1);
    if (buf == NULL)
    {
        fprintf(stderr, "Memory allocation error\n");
        exit(1);
    }
    
	// Initialize start to the beginning of the string
    start = s;
    
    // Move start to the end of the string
    while(*start != '\0'){
        start++;
    }
    
    // Move start back by 'len' characters
    start -= len;
    
    // Check if start is before the beginning of the string
    if(start < s){
        // Exit if len > the length of the string
        exit(1);
    }
    
    // Copy len characters from start to buf
    for(x = 0; x < len; x++){
        *(buf + x) = *(start + x); // same as buf[x] = start[x]
    }
    
    *(buf + x) = '\0';
    
    return buf;
}

char *mid(char *s, int offset, int len)
{
    char *buf;
    int x;

    buf = (char *)malloc(sizeof(char) * len + 1);
    if (buf == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    for (x = 0; x < len; x++)
    {
        // The offset value is decreased by 1 because the first character is offset 0, not offset 1.
        // We will copy characters starting from offset until length
        // same as buf[x] = s[offset - 1 + x]
        *(buf + x) = *(s + offset - 1 + x);

        if (*(buf + x) == '\0')
        {
            break;
        }
    }

    *(buf + x) = '\0';
    return buf;
}
```

`main.c`

```C
int main()
{
	char string[] = "Slice me, dice me, make Julienne fries!";

	printf("Original string: %s\n",string);
	printf("Left %d characters: %s\n",8,left(string,8));
	printf("Middle %d characters: %s\n",7,mid(string,11,7));
	printf("Right %d characters: %s\n",20,right(string,20));

	return(0);
}
```

`Output`

```C
chan@CMA:~/C_Programming/test$ ./final
Original string: Slice me, dice me, make Julienne fries!
Left 8 characters: Slice me
Middle 7 characters: dice me
Right 20 characters: make Julienne fries!

```

### Difference between `char *s` and `char **s`

`char *s`:

- Single pointer to a character/string
- Points directly to a sequence of characters
- It can point to a single character or first character of a string
- Common use: storing/manipulating single strings

```C
char *s = "Hello";  // Points to string literal
// or
char str[] = "Hello";
char *s = str;      // Points to first character of array
```

`char **s`:

- Pointer to a pointer to character (double pointer)
- It can hold the address of a `char *` (i.e., the address of a pointer to a character), which can be used to represent an **array of strings** or a **2D array of characters**.
- Can point to an array of strings
- Common use: array of strings or dynamic string arrays
- This is commonly used in situations where we need multiple strings, like an array of command-line arguments (`argv` in `main(int argc, char **argv)`).

```C
// Example of char **s:
char *strings[] = {"Hello", "World"};
char **s = strings;  // Points to array of strings

// Accessing elements:
printf("%s\n", s[0]);  // Prints "Hello"
printf("%s\n", s[1]);  // Prints "World"
```

Complete Program Showing Both

```C
#include <stdio.h>

int main() {
    // char *s example
    char *single = "Hello";
    printf("Single pointer:\n");
    printf("%s\n", single);
    
    // char **s example
    char *array[] = {"Hello", "World"};
    char **double_ptr = array;
    
    printf("\nDouble pointer:\n");
    printf("First string: %s\n", double_ptr[0]);
    printf("Second string: %s\n", double_ptr[1]);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Single pointer: 
Hello

Double pointer:
First string: Hello
Second string: World

```

**Key Differences**:

1. Memory Structure:

   - `char *s` : s -> "Hello"
   - `char **s` : s -> ptr -> "Hello" -> ptr -> "World"

2. Common Uses:

   - `char *s` : Single strings
   - `char **s`: Arrays of strings, 2D character arrays

3. Dereferencing:

   - `char *s` : Use `*s` to get a character
   - `char **s` : Use `*s` to get a string, `**s` to get a character.

4. **`char \*s`**: Points to a single string.

   **`char \**s`**: Points to multiple strings or an array of `char *` pointers, each potentially pointing to a different string.

In terms of memory, `char *s` is a single-level pointer, while `char **s` is a double-level pointer, allowing for more complex structures like lists of strings.



### Splitting a string

To write a string-splitting function in C with fewer than 20 lines of code, we need to pass at least 4 arguments:

```C
int strsplit(char *org, int offset, char **s1, char **s2);
```

- Pointer `org` references the string to split.
- Integer `offset` is the location of the split.
- The last two pointers, `s1` and `s2` contains two sides of the split.
  - These pointers are passed by reference, which allows the function to access and modify their contents.



In the following function:

- the size of the original string is obtained and used to allocate storage for `s1` and `s2`.
- Then the `strncpy()` function copies the separate portions of the original string into the separate strings.
- The function returns 1 upon success, and 0 when things foul up.

```C
int strsplit(char *org, int offset, char **s1, char **s2){
    int len;
    
    len = strlen(org);
    
    // If the offset arg is out of range, return zero - error.
    if(offset > len){
        return 0;
    }
    
    // Allocate storage for split string 1, argument s1 dereferenced
    *s1 = malloc(sizeof(char) * offset + 1);
    
    // Allocate storage for split string 2, calcuating the proper size
    *s2 = malloc(sizeof(char) * len - offset + 1);
    if(s1 == NULL || s2 == NULL){
        return 0;
    }
    
    // copy the first offset characters to the first substring
    strncpy(*s1, org, offset);
    (*s1)[offset] = '\0';
    
    // copy the remaining characters to the second substring
    strncpy(*s2, org + offset, len - offset);
    (*s2)[len - offset] = '\0';
    
    return 1;
}

int main(){
    char string[] = "When this baby hits 88 miles per hour";
    
    // Pointers to hold the two substrings
    char *first, *second;
    
    // Variable to hold the result of the split
    int r;
    
    // Split the string at offset 15
    r = strsplit(string, 15, &first, &second);
    
    if(r == 1){
        printf("Split successful\n");
        printf("'%s' split into:\n", string);
        printf("'%s'\n", first); // Print the first substring
        printf("'%s'\n", second); // Print the second substring
    }else{
        puts("The function was unable to split the string");
    }
    
    //Free the allocated memory
    free(first);
    free(second);
    
    return 0;
}
```

- `*s1 = malloc(sizeof(char) * (offset + 1));`: Allocate memory for the first substring, including space for the null terminator. The first string is until the offset.
- `*s2 = malloc(sizeof(char) * (len - offset + 1));`: Allocate memory for the second substring, including space for the null terminator. The second string is the remaining characters based on the offset.

### Visualization

Let's visualize the process with the example string `"When this baby hits 88 miles per hour"` and `offset = 15`.

1. **Original String**:

   string = "When this baby hits 88 miles per hour"

2. **Offset Calculation**:

   - `offset = 15`
   - The string will be split at the 15th character (0-based index).

3. **Memory Allocation**:

   - Allocate memory for the first substring (`"When this baby "`), including space for the null terminator.
   - Allocate memory for the second substring (`"hits 88 miles per hour"`), including space for the null terminator.

4. **Copy Characters**:

   - Copy the first 15 characters to the first substring:

   - ```
     first = "When this baby "
     ```

   - Copy the remaining characters to the second substring:

   - ```
     second = "hits 88 miles per hour"
     ```

```sh
chan@CMA:~/C_Programming/test$ ./final
Split successful
'When this baby hits 88 miles per hour' split into:
'When this baby '
'hits 88 miles per hour'
```



### Inserting one string into another

```c
char *strinsert(char *org, char *ins, int offset);
```

- The function's return value is a newly created string, which avoids the necessity that string `org` be large enough to also accommodate inserting string `ins`.
- Returning the string, that is, creating it within the function, also avoids having to temporarily store the remainder of string `org` for concatenation later.
- In this approach, the new string is built character by character, inserting string `ins` at `offset` characters as the new string is built. `offset` refers to the location where we want to insert the character.
- Rather than use the `strcat()` and `strcpy()`, this version of `strinsert()` function copies characters sequentially from string `org` into a newly created buffer.
- Once the character count is equal to `offset`, characters are copied from string `ins` into the newly created buffer. 
- After that, the count continues from string `org`.

![Screenshot from 2024-11-11 17-16-49](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-11 17-16-49.png)

```C
char *strinsert(char *org, char *ins, int offset){
    char *new;
    int size, index, append;
    
    size = strlen(org) + strlen(ins);
    
    if(offset < 0){
        return NULL;
    }
    
    new = malloc(sizeof(char) * size + 1);
    if(new == NULL){
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    offset -= 1; // adjust offset to be zero-based
    
    // Indexes to track prograss thru new string
    index = 0;
    
    // Status variable to track whether ins string has been inserted
    append = 0;
    
    // Loop thru the original string
    while(*org){
        // if the current index matches the offset, insert ins 
        if(index == offset){
            while(*ins){
                // copy char from ins to new
                *(new + index) = *ins;
                index++;
                ins++;
            }
            // set append flag to indicate 'ins' has been appended
            append = 1;
        }
        // copy char from 'org' to 'new' to continue building the new string
        *(new + index) = *org;
        index++;
        org++;
    }
    
    // Confirms that a string was inserted; if not, string ins is appended
    if(!append){
        while(*ins){
            *(new + index) = *ins;
            index++;
            ins++;
        }
    }
    *(new + index) = '\0';
    
    return new;
}
```

`main.c`

```C
int main(){
    char s1[] = "Well, this is another mess!";
    char s2[] = "fine ";
    
    printf("Before: %s\n", s1);
    // Insert s2 into s1 at offset 23
    char *result = strinsert(s1, s2, 23);
    printf("After: %s\n", result);
    
    free(result);
    return 0;
}
```



`Output`

- This is the program's output where the string "fine " (plus a space) is inserted into the string "Well, this is another mess!" at offset 23.

```sh
chan@CMA:~/C_Programming/test$ ./final
Before: Well, this is another mess!
After: Well, this is another fine mess!
```



### Counting words in a string

- To solve the puzzle of counting words in a string, we must write code that recognizes when a word starts.

```C
int strwords(char *s){
    
    
    // Create the constants FALSE = 0 and TRUE = 1
    enum{FALSE, TRUE};
    
    // Starts out assuming the code isn't reading inside of a word
    int inword = FALSE;
    int count;
    
    count = 0;
    while(*s){
        if(isalpha(*s)){
            
            // Confirms that a word isn't being processed
            if(!inword){
                count++;
                inword = TRUE;
            }
        }else{
            // For non-alpha char, inword is FALSE
            inword = FALSE;
        }
        s++;
    }
    return count;
}

int main(){
    char string[] = "This is a sample string";
    printf("The string '%s' contains %d words\n", string, strwords(string));
    return (0);
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'This is a sample string' contains 5 words
```



But if we change is to isn't, the output is 

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'This isn't a sample string' contains 6 words
```



**Exercise 7.3**

Modify the `strwords()` function so that it accounts for contractions. 

`main.c`

```C
int strwords(char *s){
    // Create the constants FALSE = 0 and TRUE = 1
    enum{FALSE, TRUE};
    
    // Variable to track if we are inside a word
    int inword = FALSE;
    int count;
    
    count = 0;
    
    // Loop thru the string
    while(*s){
        if(isalpha(*s)){
            // If s is an alphabet & if we are not already in a word
            if(!inword){
                count++;
                inword = TRUE;
            }
        }
        // Check for contractions
        else if(*s == '\'' && isalpha(*(s + 1))){
            // Skip the apostrophe and the following alphabetic characters
            s++;
        }else{
            inword = FALSE; // If the character is not alphabetic, we are not in a word
        }
        s++;
    }
    return count;
}

int main(){
    char string[] = "This is a sample string";
    printf("The string '%s' contains %d words\n", string, strwords(string));
    return (0);
}
```

**Things to Note**:

```C
else if (*s == '\'' && isalpha(*(s + 1)))
```

Check if the character is an apostrophe followed by an alphabetic character.

- `s++`: Skip the apostrophe and the following alphabetic character.

### Visualization

Let's visualize the process with the example string `"This isn't a sample string"`.

1. **Initial State**:

   string = "This isn't a sample string"

2. **Loop Through the String**:

   - `T` is alphabetic, increment word count to 1.
   - `h` is alphabetic, continue.
   - `i` is alphabetic, continue.
   - `s` is alphabetic, continue.
   - ` ` is not alphabetic, set `inword` to `FALSE`. (Space)
   - `i` is alphabetic, increment word count to 2.
   - `s` is alphabetic, continue.
   - `'` is an apostrophe followed by `n`, skip the apostrophe.
   - `n` is alphabetic, continue.
   - `t` is alphabetic, continue.
   - ` ` is not alphabetic, set `inword` to `FALSE`.
   - `a` is alphabetic, increment word count to 3.
   - ` ` is not alphabetic, set `inword` to `FALSE`. (Space)
   - `s` is alphabetic, increment word count to 4.
   - `a` is alphabetic, continue.
   - `m` is alphabetic, continue.
   - `p` is alphabetic, continue.
   - `l` is alphabetic, continue.
   - `e` is alphabetic, continue.
   - ` ` is not alphabetic, set `inword` to `FALSE`. (Space)
   - `s` is alphabetic, increment word count to 5.
   - `t` is alphabetic, continue.
   - `r` is alphabetic, continue.
   - `i` is alphabetic, continue.
   - `n` is alphabetic, continue.
   - `g` is alphabetic, continue.

3. **Result**:

   - The string `"This isn't a sample string"` contains 5 words.

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'This isn't a sample string' contains 5 words
```



### Converting tabs to spaces

To set a tab stop, we must know where text output is going across the screen - the current column value. This value is compared with the tab stop width desired, using the following equation:

```C
spaces = tab - (column % tab)
```

![Screenshot from 2024-11-11 20-56-55](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-11 20-56-55.png)

- The `(column % tab)` expression returns the number of spaces since the last tab stop interval (tab) based on the cursor's current column offset (column).
- To obtain the number of spaces until the next tab stop, this value is subtracted from the tab stop width.
- The result is the number of spaces required to line up the next character output with a tab stop.



```C
void strtabs(const char *s, int tab){
    int column, x, spaces;
    
    // The column variable tracks the current column position.
    column = 0;
    
    // Loop thru the string
    while(*s){
        if(*s == '\t'){
            // Calculates the number of spaces to output to line up at the next tab stop
            spaces = tab - (column % tab);
            
            // Output the required spaces
            for(x = 0; x < spaces; x++){
                putchar(' ');
            }
            
            // update the column offset
            column += spaces;
        }else{ // if the character is not a tab
            putchar(*s);
            
            // reset the column if the character is a newline, otherwise increment the column counter
            if(*s == '\n'){
                column = 0;
            }else{
                column++;
            }
        }
        s++;
    }
}

int main()
{
    const char *text[3] = {"Hello\tHi\tHowdy\n", "\tLa\tLa\n", "Constantinople\tConstantinople\n"};
    int x, y;
    
    // Nested loop to output the three sample strings at three different tab stops: 4, 8 and 16 spaces
    for (y = 4; y < 32; y *= 2)
    {
        // Print the current tab width
        printf("Tab width: %d\n", y);
        
        // Loop thru each string in the array
        for (x = 0; x < 3; x++)
        {
            // Replace tabs with spaces in the current strings
            strtabs(text[x], y);
        }
    }

    return (0);
}
```

### Visualization

Let's visualize the process with the example strings and different tab widths.

1. **Initial State**:

   ```C
   text[0] = "Hello\tHi\tHowdy\n"
   
   text[1] = "\tLa\tLa\n"
   
   text[2] = "Constantinople\tConstantinople\n"
   ```

2. **Loop Through Tab Widths**:

   - Tab widths: 4, 8, 16

3. **Tab Width 4**:

   - For `text[0] = "Hello\tHi\tHowdy\n"`:
     - Replace `\t` with spaces to the next tab stop (4 spaces).
     - Result: `"Hello Hi Howdy\n"`
   - For `text[1] = "\tLa\tLa\n"`:
     - Replace `\t` with spaces to the next tab stop (4 spaces).
     - Result: `" La La\n"`
   - For `text[2] = "Constantinople\tConstantinople\n"`:
     - Replace `\t` with spaces to the next tab stop (4 spaces).
     - Result: `"Constantinople Constantinople\n"`

4. **Tab Width 8**:

   - For `text[0] = "Hello\tHi\tHowdy\n"`:
     - Replace `\t` with spaces to the next tab stop (8 spaces).
     - Result: `"Hello Hi Howdy\n"`
   - For `text[1] = "\tLa\tLa\n"`:
     - Replace `\t` with spaces to the next tab stop (8 spaces).
     - Result: `" La La\n"`
   - For `text[2] = "Constantinople\tConstantinople\n"`:
     - Replace `\t` with spaces to the next tab stop (8 spaces).
     - Result: `"Constantinople Constantinople\n"`

5. **Tab Width 16**:

   - For `text[0] = "Hello\tHi\tHowdy\n"`:
     - Replace `\t` with spaces to the next tab stop (16 spaces).
     - Result: `"Hello Hi Howdy\n"`
   - For `text[1] = "\tLa\tLa\n"`:
     - Replace `\t` with spaces to the next tab stop (16 spaces).
     - Result: `" La La\n"`
   - For `text[2] = "Constantinople\tConstantinople\n"`:
     - Replace `\t` with spaces to the next tab stop (16 spaces).
     - Result: `"Constantinople Constantinople\n"`

```sh
chan@CMA:~/C_Programming/test$ ./final
Tab width: 4
Hello   Hi  Howdy
    La  La
Constantinople  Constantinople
Tab width: 8
Hello   Hi      Howdy
        La      La
Constantinople  Constantinople
Tab width: 16
Hello           Hi              Howdy
                La              La
Constantinople  Constantinople

```

- When the terminal window encounters a tab, it doesn't convert the tab into multiple spaces like the program does.
- For the terminal window, the cursor itself moves the required number of character positions across the screen: spaces aren't output.

