## Chapter 10 - Directory tree

- The point of the directory tree utility is to output a map of the directory structure.
- The map details which directories are parents and children of each other.



### The filesystem

- The filesystem's duty is to organize storage.
- It takes a file's data and writes it to one or more locations on the media.
- This information is recorded along with other file details, such as the file's name, size, dates (created, modified, accessed), permissions, and so on.
- In a Linux terminal window, use the `man fs` command to review details on how Linux uses a filesystem and the different filesystems available.
- The `/proc/filesystems` directory lists available filesystems for your Linux installation.



### File and directory details

- To gather directory details at the command prompt, use the `ls` command.
- The output is a list of filenames in the current directory.
- For more details, the `-l` (long) switch is specified.

```shell
chan@CMA:~/C_Programming/test$ ls
alphabeta.wtxt  cyrillic.wtxt  hello.c  libs    Makefile  sonnet18.txt
bytes.dat       final          hello.h  main.c  obj
chan@CMA:~/C_Programming/test$ ls -l
total 64
-rw-rw-r-- 1 chan chan    49 Nov 13 22:56 alphabeta.wtxt
-rw-rw-r-- 1 chan chan   256 Nov 16 22:31 bytes.dat
-rw-rw-r-- 1 chan chan    65 Nov 14 20:07 cyrillic.wtxt
-rwxrwxr-x 1 chan chan 21216 Nov 18 21:00 final
-rw-rw-r-- 1 chan chan  1717 Nov 18 21:00 hello.c
-rw-rw-r-- 1 chan chan   497 Nov 18 21:00 hello.h
drwxrwxr-x 2 chan chan  4096 Nov 18 21:00 libs
-rw-rw-r-- 1 chan chan  1857 Nov 18 20:59 main.c
-rw-rw-r-- 1 chan chan   949 Nov 12 14:23 Makefile
drwxrwxr-x 2 chan chan  4096 Nov 18 21:00 obj
-rw-rw-r-- 1 chan chan   620 Nov 17 19:48 sonnet18.txt

```

- The details output by the `ls -l` command are stored in the directory like a database.
- In face, directories on storage media are really database.
- Their records aren't specifically files, but rather inodes.
- `inodes` is a collection of data that describes a file.



### Gathering file info

- To obtain details about a file, as well as to read a directory, we need to access inode data.
- The command-line program that does so is called `stat`.
- Below is the sample output on the `stat` program file `libs` inside my current directory `test`.

```shell
chan@CMA:~/C_Programming/test$ ls
alphabeta.wtxt  cyrillic.wtxt  hello.c  libs    Makefile  sonnet18.txt
bytes.dat       final          hello.h  main.c  obj
chan@CMA:~/C_Programming/test$ stat libs
  File: libs
  Size: 4096      	Blocks: 8          IO Block: 4096   directory
Device: 8,4	Inode: 2102431     Links: 2
Access: (0775/drwxrwxr-x)  Uid: ( 1000/    chan)   Gid: ( 1000/    chan)
Access: 2024-11-18 21:00:54.003506081 +0700
Modify: 2024-11-18 21:00:53.554497165 +0700
Change: 2024-11-18 21:00:53.554497165 +0700
 Birth: 2024-11-12 14:11:39.733013969 +0700
```



- To read this same information in our C programs, we use the `stat()` function.

  - It's prototyped in the `sys/stat.h` header file.

  ```C
  int stat(const char *pathname, struct stat *statbuf);
  ```

  - The `pathname` is a filename or a full pathname.
  - Argument `statbuf` is the address of a `stat` structure.
  - Here is a typical `stat()` function statement, with the `filename` `char` pointer containing the filename, `fs` as a `stat` structure, and `int` variable `r` capturing the return value.

  ```C
  r = stat(filename, &fs);
  ```

  - Upon failure, value -1 is returned.
  - Otherwise, 0 is returned and the `stat` structure `fs` is joyously filled with details about the file - inode data.

- The following table lists the common members of the `stat` structure, though different filesystems and operating systems add or change specific members.

![Screenshot from 2024-11-18 21-32-58](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-18 21-32-58.png)

- Most of the `stat` structure members are integers.
- They are all `unsigned`, though some values are `unsigned long`.

### **`struct stat` Definition**

Defined in the `<sys/stat.h>` header, **`struct stat`** typically includes the following members (note that actual implementations may have additional members):

```C
struct stat {
    dev_t     st_dev;     // ID of device containing file
    ino_t     st_ino;     // Inode number
    mode_t    st_mode;    // File type and mode (permissions)
    nlink_t   st_nlink;   // Number of hard links
    uid_t     st_uid;     // User ID of owner
    gid_t     st_gid;     // Group ID of owner
    dev_t     st_rdev;    // Device ID (if special file)
    off_t     st_size;    // Total size, in bytes
    blksize_t st_blksize; // Block size for filesystem I/O
    blkcnt_t  st_blocks;  // Number of 512B blocks allocated
    time_t    st_atime;   // Time of last access
    time_t    st_mtime;   // Time of last modification
    time_t    st_ctime;   // Time of last status change
};

```





```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <time.h>
int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        fprintf(stderr, "Specify a filename\n");
        exit(1);
    }

    filename = argv[1];
    printf("Info for file '%s'\n", filename);
    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "Error reading '%s'\n", filename);
        exit(1);
    }

    // Outputs the members of the stat structure fs
    printf("Media ID: %lu\n", fs.st_dev);
    printf("Inode number: %lu\n", fs.st_ino);
    printf("Type and mode: %u\n", fs.st_mode);
    printf("Hard links = %lu\n", fs.st_nlink);
    printf("Owner ID: %u\n", fs.st_uid);
    printf("Group ID: %u\n", fs.st_gid);
    printf("Device ID: %lu\n", fs.st_rdev);
    printf("File size %lu bytes\n", fs.st_size);
    printf("Block size = %lu\n", fs.st_blksize);
    printf("Allocated blocks = %lu\n", fs.st_blocks);
    
    // The time structures use the ctime() function to output their values.
    printf("Access: %s", ctime(&fs.st_atime));
    printf("Modified: %s", ctime(&fs.st_mtime));
    printf("Changed: %s", ctime(&fs.st_ctime));
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final libs
Info for file 'libs'
Media ID: 2052
Inode number: 2102431
Type and mode: 16893
Hard links = 2
Owner ID: 1000
Group ID: 1000
Device ID: 0
File size 4096 bytes
Block size = 4096
Allocated blocks = 8
Access: Mon Nov 18 21:40:43 2024
Modified: Mon Nov 18 21:40:43 2024
Changed: Mon Nov 18 21:40:43 2024
```



### Exploring file type and permissions

- Examining a file's (or inode's) `st_mode` is how we determine whether a file is a regular old file, a directory, or some other special type of file.
- In the Linux environment, everything is a file.
- Using the `stat()` function is how our code can determine which type of file the inode represents.
- The bit fields in the `st_mode` member of the `stat` structure describe the file's permissions.
- The `S_ISREG()` macro returns TRUE for regular files.

```C
printf("Type and mode: %X\n", fs.st_mode);
if(S_ISREG(fs.st_mode)){
    printf("%s is a regular file\n", filename);
}else{
    printf("%s is not a regular file\n", filename);
}
```

- A directory isn't a regular file.



**Short definition of `fs.st_mode`**

"In C programming, particularly when dealing with file system operations, **`fs.st_mode`** refers to the **`st_mode`** member of the **`struct stat`** structure. This member plays a crucial role in providing information about a file's type and its permission settings. Understanding **`st_mode`** is essential for tasks such as checking if a file is a regular file, directory, symbolic link, or for verifying its read/write/execute permissions."





Table 10.2 Macros defined in `sys/stat.h` to help determine file type

| Macro        | True for this type of file                                  |
| ------------ | ----------------------------------------------------------- |
| `S_ISBLK()`  | Block special, such as mass storage in the `/dev` directory |
| `S_ISCHR()`  | Character special, such as a pipe or the `/dev/null` device |
| `S_ISDIR()`  | Directories                                                 |
| `S_ISFIFO()` | A FIFO (named pipe) or socket                               |
| `S_ISREG()`  | Regular files                                               |
| `S_ISLNK()`  | Symbolic link                                               |
| `S_ISSOCK()` | Socket                                                      |



```shell
chan@CMA:~/C_Programming/test$ ls -l sonnet18.txt
-rw-rw-r-- 1 chan chan 620 Nov 17 19:48 sonnet18.txt

```

- The first chunk of info `-rw-rw-r--` indicates the file type and permissions.
- Next is the number of hard links `1`.
- The owner `chan`.
- The group `chan`.
- The `620` is the file size in bytes.
- And then comes the date and timestamp, and finally the filename.



Three sets of file permissions octets are used for a file. These sets are based on user classification:

- Owner
- Group
- Other

You are the owner of the files you create.

As a user on the computer, you are also a member of a group.

We can use the `id` command to view our username and ID number, as well as the groups we belong to.

- View the `/etc/group` file to see the full list of groups on the system.

```shell
cat /etc/group
```



- The value (a file's owner and group) is interpreted from the `st_mode` member of the file's `stat` structure.



| Defined constant | Permission octet         |
| ---------------- | ------------------------ |
| `S_IRUSR`        | Owner read permission    |
| `S_IWUSR`        | Owner write permission   |
| `S_IXUSR`        | Owner execute permission |
| `S_IRGRP`        | Group read permission    |
| `S_IWGRP`        | Group write permission   |
| `S_IXGRP`        | Group execute permission |
| `S_IROTH`        | Other read permission    |
| `S_IWOTH`        | Other write permission   |
| `S_IXOTH`        | Other execute permission |

- These defined constants follow a naming pattern: 
  - each defined constants start with `S_I`.
  - The `I` is followed by `R`, `W`, or `X` for read, write or execute, respectively.
  - This letter is followed by `USR`, `GRP`, `OTH` for Owner(user), Group, and Other.
- For example, if we want to test the read permission for a group user, we use the `S_IRGRP` defined constant.
- This defined constant is used in an `if` test  with a bitwise `AND` operator to test the permission bit on the `st_mode` member.

```C
if(fs.st_mode & S_IRGRP)
```

- The line `if (fs.st_mode & S_IRGRP)` checks whether the **group** associated with the file has **read** permissions.

- **Bitwise AND Operation**:

  - `fs.st_mode & S_IRGRP` performs a bitwise AND between the file's mode and the group read permission bitmask.
  - This operation **isolates** the group read permission bit.

- **Condition Evaluation**:

  - **Non-Zero Result**: Indicates that the **group read permission** is **set**.
  - **Zero Result**: Indicates that the **group read permission** is **not set**.

- **Example**:

  - Suppose `fs.st_mode` has the value `0754` (in octal), which translates to:
    - **Owner**: Read, Write, Execute (`7` -> `rwx`)
    - **Group**: Read, Execute (`5` -> `r-x`)
    - **Others**: Read (`4` -> `r--`)
  - **`S_IRGRP`** corresponds to the bitmask for group read permission (`0040` in octal).

- **Operation**:

- `0754` in octal is `111 101 100` in binary.

- **`S_IRGRP`** (`0040` in octal) corresponds to the binary `000 100 000`.

  ```C
    111 101 100   (0754 - fs.st_mode)
  & 000 100 000   (0040 - S_IRGRP)
  = 000 100 000   (0040 - Non-zero, permission granted)
  ```

  

  ```C
  fs.st_mode = 0754;        // File permissions: rwxr-xr--
  S_IRGRP    = 0040;        // Group read permission bitmask
  
  fs.st_mode & S_IRGRP = 0754 & 0040 = 0040 (non-zero)
  ```

- **Result**:

  - Since the result is `0040` (non-zero), the condition `if (fs.st_mode & S_IRGRP)` evaluates to **true**, indicating that the group **has read permission** for this file.

#### The `st_mode` Member

##### **What is `st_mode`?**

- **Type:** `mode_t` (an integer type)
- **Purpose:** Encodes both the **file type** and the **file mode (permissions)**

##### **Components Encoded in `st_mode`:**

1. **File Type:** Indicates whether the file is a regular file, directory, symbolic link, etc.
2. **Permissions:** Specifies read, write, and execute permissions for the owner, group, and others.

```C
int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        puts("Filename required");
        exit(1);
    }

    filename = argv[1];

    printf("Obtaining permission mode for '%s'\n", filename);

    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "File error\n");
        exit(1);
    }

    printf("Permission bits: %X\n", fs.st_mode);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt
Obtaining permission mode for 'sonnet18.txt'
Permission bits: 81B4
```

- #### **Steps:**

  1. **Hex to Binary:**

     - `8` → `1000`
     - `1` → `0001`
     - `B` → `1011`
     - `4` → `0100`

     **Combined Binary:** `1000 0001 1011 0100`

  2. **Binary to Octal:**

     - Group the binary digits into sets of three (from the right):

       ```C
       1 000 000 110 110 100
       ```

     - Add leading zeros if necessary

       ```C
       001 000 000 110 110 100
       ```

     - Convert each group to its octal equivalent:

       - `001` → `1`
       - `000` → `0`
       - `000` → `0`
       - `110` → `6`
       - `110` → `6`
       - `100` → `4`

     **Combined Octal:** `0100664`

  3. **Decoding the Octal Value `0100664`**:

     - File Type (`0100000`):

     - **Octal Prefix:** `01`

     - **Meaning:** Represents a **regular file**.

     | Octal | File Type                |
     | ----- | ------------------------ |
     | `01`  | Regular File (`S_IFREG`) |

     - #### **File Permissions (`00664`):**

       - **Owner Permissions (`6`):**
         - **Read (`4`) + Write (`2`) = `6`** → `rw-`
       - **Group Permissions (`6`):**
         - **Read (`4`) + Write (`2`) = `6`** → `rw-`
       - **Others Permissions (`4`):**
         - **Read (`4`) = `4`** → `r--`
       - **Combined Permissions:** `rw-rw-r--`

     - **File Type:** Regular File

     - **Permissions:**

       - **Owner:** Read and Write
       - **Group:** Read and Write
       - **Others:** Read Only

     - **Symbolic Representation:** `-rw-rw-r--`

     ```shell
     chan@CMA:~/C_Programming/test$ ls -l sonnet18.txt
     -rw-rw-r-- 1 chan chan 620 Nov 17 19:48 sonnet18.txt
     ```

     

```C
int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        fprintf(stderr, "Specify a filename\n");
        exit(1);
    }

    filename = argv[1];
    printf("Info for file '%s'\n", filename);
    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "Error reading '%s'\n", filename);
        exit(1);
    }

    printf("File '%s' is a ", filename);
	
    // Determines the file type
    if (S_ISBLK(fs.st_mode))
    {
        printf("block special\n");
    }
    else if (S_ISCHR(fs.st_mode))
    {
        printf("character special\n");
    }
    else if (S_ISDIR(fs.st_mode))
    {
        printf("directory\n");
    }
    else if (S_ISFIFO(fs.st_mode))
    {
        printf("named pipe or socket\n");
    }
    else if (S_ISREG(fs.st_mode))
    {
        printf("regular file\n");
    }
    else if (S_ISLNK(fs.st_mode))
    {
        printf("symbolic link\n");
    }
    else if (S_ISSOCK(fs.st_mode))
    {
        printf("socket\n");
    }
    else
    {
        printf("type unknown\n");
    }
	
    // Tests owner permission bits
    printf("Owner permissions: ");
    if (fs.st_mode & S_IRUSR)
    {
        printf("read ");
    }
    if (fs.st_mode & S_IWUSR)
    {
        printf("write ");
    }
    if (fs.st_mode & S_IXUSR)
    {
        printf("execute");
    }
    putchar('\n');
	
    // Tests group permission bits
    printf("Group permissions: ");
    if (fs.st_mode & S_IRGRP)
    {
        printf("read ");
    }
    if (fs.st_mode & S_IWGRP)
    {
        printf("write ");
    }
    if (fs.st_mode & S_IXGRP)
    {
        printf("execute");
    }
    putchar('\n');
	
    // Tests other permission bits
    printf("Other permissions: ");
    if (fs.st_mode & S_IROTH)
    {
        printf("read ");
    }
    if (fs.st_mode & S_IWOTH)
    {
        printf("write ");
    }
    if (fs.st_mode & S_IXOTH)
    {
        printf("execute");
    }
    putchar('\n');
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final
Specify a filename
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt
Info for file 'sonnet18.txt'
File 'sonnet18.txt' is a regular file
Owner permissions: read write 
Group permissions: read write 
Other permissions: read 

chan@CMA:~/C_Programming/test$ ./final libs
Info for file 'libs'
File 'libs' is a directory
Owner permissions: read write execute
Group permissions: read write execute
Other permissions: read execute
```



**Exercise 10.1**

The `if-else` structures contain a lot of repetition. The task for this exercise is to write a  function that outputs a file's permissions.

Call the function `permissions_out()`. It takes a `mode_t` argument of the `st_mode` member in a `stat` structure.

```C
void permissions_out(mode_t stm);
```

Use the function to output a string of permissions for each of the three access levels, owner, group, other. Use characters r,w,x, for read, write and execute access if a bit is set; use a dash (-) for unset items. The output is the same as shown in the `ls -l` listing, but without the leading character identifying the file type.

**Solution**

```C
void permissions_out(mode_t stm)
{
    putchar(stm & S_IRUSR ? 'r' : '-');
    putchar(stm & S_IWUSR ? 'w' : '-');
    putchar(stm & S_IXUSR ? 'x' : '-');
    putchar(stm & S_IRGRP ? 'r' : '-');
    putchar(stm & S_IWGRP ? 'w' : '-');
    putchar(stm & S_IXGRP ? 'x' : '-');
    putchar(stm & S_IROTH ? 'r' : '-');
    putchar(stm & S_IWOTH ? 'w' : '-');
    putchar(stm & S_IXOTH ? 'x' : '-');
    putchar('\n');
}


int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        fprintf(stderr, "Specify a filename\n");
        exit(1);
    }

    filename = argv[1];
    printf("Info for file '%s'\n", filename);
    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "Error reading '%s'\n", filename);
        exit(1);
    }

    printf("File '%s' is a ", filename);

    permissions_out(fs.st_mode);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt
Info for file 'sonnet18.txt'
File 'sonnet18.txt' is a rw-rw-r--
chan@CMA:~/C_Programming/test$ ./final libs
Info for file 'libs'
File 'libs' is a rwxrwxr-x

```



### Reading a directory

- A directory is a database of files.
- Just like a file, a directory database is stored on media.
- But we can't use the `fopen()` to open and read the contents of a directory.
- Instead, we use the `opendir()` function.

```C
DIR *opendir(const char *filename);
```

- The `opendir()` function accepts a single argument, a string representing the pathname of the directory to examine.
- Specifying the shortcuts . and .. for the current and parent directory are also valid.
- The function returns a pointer to a `DIR` handle, similar to the `FILE` handle used by the `fopen()` command.
- As the `FILE` handle represents a file stream, the `DIR` handle represents a directory stream.
- Upon an error, the NULL pointer is returned.
- The global `errno` value is set, indicating the specific booboo the function encountered.
- The `opendir()` features a companion `closedir()` function.
- The `closedir()` requires a single argument, the `DIR` handle of an open directory stream, humorously called "dirp" in the `man` page format example:

```C
int closedir(DIR *dirp);
```

- `dirp` can be remembered as "directory pathname".
- Upon success, the `closedir()` returns 0. Otherwise the value -1 is returned and the global `errno` value is set.
- Both the `opendir()` and `closedir()` are prototyped in the `dirent.h` header file.

```C
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main(){
    // Directory handle
    DIR *dp;
    
    // Opens the current directory, whatever it may be
    dp = opendir(".");
    
    if(dp == NULL){
        puts("Unable to read directory");
        exit(1);
    }
    
    puts("Directory is opened!");
    
    closedir(dp);
    
    puts("Directory is closed!");
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
Directory is opened!
Directory is closed!

```

- To access the files stored in the directory, we use another function, `readdir()`.
- This function is also prototyped in the `dirent.h` header file.

```C
struct dirent *readdir(DIR *dirp);
```

- The function consumes an open DIR handle as its only argument.
- The return value is the address of a `dirent` structure, which contains details about a directory entry.
- This function is called repeatedly to read file entries (inodes) from the directory stream.
- The value NULL is returned after the final entry in the directory has been read.



Table 10.4 Common members of the `dirent` structure

| Member     | Data type (placeholder) | Description   |
| ---------- | ----------------------- | ------------- |
| `d_ino`    | `ino_t` (%lu)           | inode number  |
| `d_reclen` | `unsigned short` (%u)   | Record length |

- The best structure member to use, and one that's consistently available across all compilers and platforms, is `d_name`.

```C
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main(){
    DIR *dp;
    
    // The dirent structure is created as a pointer, a memory address.
    struct dirent *entry;
    
    dp = opendir(".");
    
    if(dp == NULL){
        puts("Unable to read directory");
        exit(1);
    }
    
    // The entry is read and stored in the dirent structure entry.
    entry = readdir(dp);
    
    // The d_name member is output
    printf("File %s\n", entry->d_name);
    
    closedir(dp);
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
File alphabeta.wtxt
```

- The program outputs only one file, most likely, the entry for the current directory itself, the single dot.
- If we want a real directory-reading program, we must modify the code.
- As with using the `fread()` function to read data from a regular file, the `readdir()` function is called repeatedly.
- When the function returns a pointer to a `dirent` structure, another entry is available in the directory.
- Only when the function returns NULL has the full directory been read.
- To achieve this, we must change the `readdir()` statement into a `while` loop condition.

```C
while( (entry = readdir(dp)) != NULL){
    printf("File %s\n", entry->d_name);
}
```

- With this update, the program now outputs all files in the current directory.
- To gather more information about files in a directory, use the `stat()` function.
- The `readdir()` function's `dirent` structure contains the file's name in the `d_name` member.
- When this detail is known, we use the `stat()` function to gather details on the file's type as well as other information.

```C
#include <stdio.h>
#include <stlib.h.
#include <sys/stat.h>
#include <dirent.h>
#include <time.h>

int main(){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    int r;
    char *filename;
    
    dp = opendir(".");
    if(dp == NULL){
        puts("Unable to read directory");
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        // Saves the directory entry's name for readibility and easy access.
        filename = entry->d_name;
        
        // Fills the stat structure for the current filename/directory entry
        r = stat(filename, &fs);
        
        if(r == -1){
            fprintf(stderr, "Error reading '%s'\n", filename);
            exit(1);
        }
        
        // Calls out directories from other file types
        if(S_ISDIR(fs.st_mode)){
            
            // Output the directory filename left-justified in a 16-character width
            printf(" Dir %-16s ",filename);
        }else{
            printf("File %-16s ", filename);
        }
        
        // Outputs the file size in an 8-character width
        printf("%8lu bytes ", fs.st_size);
        
        // Outputs the access time which automatically adds a newline
        printf("%s", ctime(&fs.st_atime));
    }
    
    closedir(dp);
    
    return 0;
}
```

- `r = stat(filename, &fs)` - The `stat()` function retrieves information about the file specified by `filename` and populates the provided `struct stat` structure with this data.
  - **Parameters:**
    1. **`filename`** (`char *`):
       - The name (path) of the file we want to inspect.
    2. **`&fs`** (`struct stat *`):
       - A pointer to a `struct stat` where the function will store the file's metadata.
  - **Return Value:**
    - **`0`**: Success. The file information has been successfully retrieved and stored in `fs`.
    - **`-1`**: Failure. An error occurred (e.g., the file does not exist), and `errno` is set to indicate the specific error.
- `-16%s` - Specifies the **minimum field width** ensuring that the string occupies at least **16 characters** in the output.
- If the string is shorter than 16 characters, it's padded with spaces.
- If the string is longer, it extends beyond 16 characters without truncation.
- The minus (-) sign indicates **left-justification** within the specified field width.
  - Aligns the string to the **left**, padding spaces to the **right** if necessary.
  - Without the minus sign(-), the string would be **right-justified**, padding spaces to the left.

```shell
chan@CMA:~/C_Programming/test$ ./final
File alphabeta.wtxt         49 bytes Sat Nov 16 22:29:34 2024
 Dir libs                4096 bytes Tue Nov 19 14:55:53 2024
File final               19136 bytes Tue Nov 19 15:23:56 2024
File main.c               1293 bytes Tue Nov 19 15:23:46 2024
File Makefile              949 bytes Mon Nov 18 20:58:48 2024
File sonnet18.txt          620 bytes Mon Nov 18 20:58:54 2024
 Dir ..                  4096 bytes Mon Nov 18 19:04:16 2024
File cyrillic.wtxt          65 bytes Sun Nov 17 19:47:36 2024
File hello.c               144 bytes Tue Nov 19 14:52:20 2024
 Dir obj                 4096 bytes Tue Nov 19 15:23:55 2024
 Dir .                   4096 bytes Tue Nov 19 15:23:55 2024
File hello.h               151 bytes Tue Nov 19 14:52:25 2024
File bytes.dat             256 bytes Sat Nov 16 22:32:09 2024

```

- To truly read a directory, we need both the `readdir()` and `stat()` functions.
- Together, they pull in details about files in the directory.



### Subdirectory exploration

Directories are referenced in three ways:

- As a named path
- As the ... shortcut to the parent directory
- As a directory entry in the current directory, a subdirectory
- Whatever the approach, pathnames are either direct or relative.
- A direct path is a fully named path, starting at the root directory, our home directory, or the current directory.
- A relative pathname uses the ... shortcut for the parent directory - sometimes a lot of them.

As an example, a full pathname could be:

```shell
/home/chan/documents/finances/bank/statements
```

- This direct pathname shows the directories as they branch from the root, through my home directory, down to the `statments` directory.
- If I have another directory, `/home/chan/documents/vacations`, but I'm using the `statements` directory, the relative path from `statements` to `vacations` is:

```shell
../../../vacations
```

- The first .. represents the `bank` directory. The second .. represents the `finances` directory. The third .. represents the `documents` directory, where `vacations` exists as a subdirectory.



### Using directory exploration tools

- Two C library functions that tells the program in which directory it's currently running: `chdir()` and `getcwd()`.

- The `getcwd()` function obtains the directory in which the program is operating.

  - Think of the name as Get the Current Working Directory.

  - It works like the `pwd` command in the terminal window.

  - This function is prototyped in the `unistd.h` header file.

  - ```C
    char *getcwd(char *buf, size_t size);
    ```

  - Buffer `buf` is a character array or buffer of `size` characters.

  - It's where the current directory string is saved, an absolute path from the root.

  - We can also use the `BUFSIZ` defined constant for the size of the buffer as well as the second argument to `getcwd()`.

  - The return value from `getcwd()` is the same character string saved in `buf`, or NULL upon an error.

  - For the specific error, check the global `errno` variable.

```C
#include <stdio.h>
#include <unistd.h>

int main(){
    char cwd[BUFSIZ];
    getcwd(cwd, BUFSIZ);
    printf("The current working directory is %s\n", cwd);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
The current working directory is /home/chan/C_Programming/test
```



#### `chdir()`

The second useful directory function is `chdir()` . 

- This function works like the `cd` command in Linux.
- Like `getcwd()`, the `chdir()` function is prototyped in the `unistd.h` header file.

```C
int chdir(const char *path);
```

- The sole argument is a string representing the directory (path) to change to.
- The return value is 0 upon success, with -1 indicating an error.

#### **What Is `struct dirent`?**

`struct dirent` is a structure defined in the `<dirent.h>` header file. It represents a directory entry, providing information about files and directories within a directory.

```C
struct dirent {
    ino_t          d_ino;       // Inode number
    off_t          d_off;       // Offset to the next dirent
    unsigned short d_reclen;    // Length of this record
    unsigned char  d_type;      // Type of file
    char           d_name[256]; // Null-terminated filename
};
```

### **Member Breakdown:**

1. **`d_ino` (`ino_t`):**
   - **Purpose:** Represents the inode number of the file.
   - **Inode Number:** A unique identifier for a file within a filesystem. It points to metadata about the file, such as permissions, ownership, and data block locations.
2. **`d_off` (`off_t`):**
   - **Purpose:** Indicates the offset to the next `dirent` structure in the directory stream.
   - **Usage:** Primarily used internally by the system; not commonly manipulated directly by user programs.
3. **`d_reclen` (`unsigned short`):**
   - **Purpose:** Specifies the length of this directory record.
   - **Usage:** Useful for systems that support variable-length records, ensuring correct traversal of directory entries.
4. **`d_type` (`unsigned char`):**
   - **Purpose:** Denotes the type of the file.
   - Common Values:
     - `DT_REG`: Regular file
     - `DT_DIR`: Directory
     - `DT_LNK`: Symbolic link
     - `DT_FIFO`: FIFO/pipe
     - `DT_SOCK`: Socket
     - `DT_CHR`: Character device
     - `DT_BLK`: Block device
     - `DT_UNKNOWN`: Unknown file type
5. **`d_name` (`char[256]`):**
   - **Purpose:** Stores the null-terminated name of the entry (file or directory).
   - **Note:** The maximum length (`256` in this example) can vary based on the system's `NAME_MAX` value.

##### **Common Usage**

`struct dirent` is primarily used with directory handling functions to read entries within a directory. Here's how it's typically used:

##### **1. Opening a Directory**

Before reading directory entries, you need to open the directory using `opendir()`:

```C
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    DIR *dir;
    struct dirent *entry;

    dir = opendir("/path/to/directory");
    if (dir == NULL) {
        perror("opendir");
        exit(EXIT_FAILURE);
    }

    // ... (reading entries)

    closedir(dir);
    return 0;
}
```

##### **2. Reading Directory Entries**

Use `readdir()` in a loop to read each entry:

```C
while ((entry = readdir(dir)) != NULL) {
    printf("Name: %s\n", entry->d_name);
    printf("Type: ");
    
    switch (entry->d_type) {
        case DT_REG:
            printf("Regular File\n");
            break;
        case DT_DIR:
            printf("Directory\n");
            break;
        case DT_LNK:
            printf("Symbolic Link\n");
            break;
        // Add cases for other types as needed
        default:
            printf("Other\n");
    }
}
```



### Diving into a subdirectory

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

int main(int argc, char *argv[]){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    int r;
    char *dirname, *filename;
    
    if(argc < 2){
        fprintf(stderr, "Missing directory name\n");
        exit(1);
    }
    
    dirname = argv[1];
    
    r = chdir(dirname);
    
    if(r == -1){
        fprintf(stderr, "Unable to change to '%s'\n", dirname);
        exit(1);
    }
    
    dp = opendir(dirname);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirname);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        
        // Obtain inode details
        r = stat(filename, &fs);
        if(r == -1){
            fprintf(stderr, "Error on '%s'\n", filename);
            exit(1);
        }
        
        // Test to see whether the file is a directory (subdirectory)
        if(S_ISDIR(fs.st_mode)){
            
            // Outputs the directory's name
            printf("Found directory: %s\n", filename);
        }
    }
    
    closedir(dp);
    
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final /home
Found directory: chan
Found directory: vincent
Found directory: ..
Found directory: .
chan@CMA:~/C_Programming/test$ ./final /home/chan
Found directory: .pki
Found directory: .gnupg
Found directory: Downloads
Found directory: Music
Found directory: .wallaby
Found directory: directory...
Found directory: .thunderbird
Found directory: .cache
Found directory: Photos
Found directory: .dotnet
Found directory: ..
Found directory: Pictures
Found directory: .ssh
Found directory: exercise_2
Found directory: .quokka
Found directory: .gphoto
Found directory: Desktop
Found directory: .mozilla
Found directory: C_Programming
Found directory: .fontconfig
Found directory: .
Found directory: Videos
Found directory: .vscode
Found directory: .local
Found directory: Documents
Found directory: Templates
Found directory: .gnome
Found directory: test
Found directory: .config
Found directory: github.com
Found directory: Public
Found directory: snap

```

**Exercise 10.2**

Every directory has the dot and dot-dot entries. Plus, many directories host hidden subdirectories. All hidden files in Linux start with a single dot. Your task for this exercise is to modify the source code to have the program not output any file that starts with a single dot. 



**Solution**

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

int main(int argc, char *argv[]){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    int r;
    char *dirname, *filename;
    
    if(argc < 2){
        fprintf(stderr, "Missing directory name\n");
        exit(1);
    }
    
    dirname = argv[1];
    r = chdir(dirname);
    
    if(r == -1){
        fprintf(stderr, "Unable to change to %s\n", dirname);
        exit(1);
    }
    
    dp = opendir(dirname);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirname);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        
        // Skip hiiden files (those starting with a dot)
        if(filename[0] == '.'){
            continue;
        }
        
        r = stat(filename, &fs);
        if(r == -1){
            fprintf(stderr,"Error on '%s'\n", filename);
            exit(1);
        }
        
        if(S_ISDIR(fs.st_mode)){
            printf("Found directory: %s\n", filename);
        }
    }
    
    closedir(dp);
    return 0;
}
```

**The Author's Solution**

```C
filename = entry->d_name;
/* after obtaining the entry/filename, compare
		   the first character with the dot */
		if( strncmp( filename,".",1)==0 )
			/* continue the while loop */
			continue;
```

- `strncmp` Function:

   

  Compares up to `n` characters of two strings.

  - **Syntax:** `strncmp(const char *s1, const char *s2, size_t n)`

- Parameters:

  - **`filename`**: The first string (file name).
  - **`"."`**: The second string (a single dot).
  - **`1`**: Number of characters to compare.

- **Comparison:** It **compares the first character** of `filename` with `'.'`.

- **Outcome:** If the first character is a dot, the `continue` statement **skips** the current iteration, thus **excluding hidden files**.

### **Step-by-Step Explanation:**

1. **Loop Begins:**
   - **`while ((entry = readdir(dp)) != NULL)`**
     Iterates over each directory entry in the opened directory `dp`.
2. **Retrieve Filename:**
   - **`filename = entry->d_name;`**
     Extracts the name of the current directory entry.
3. **Check for Hidden Files:**
   - **Condition:**
     **`if (filename[0] == '.')`**
     Checks if the first character of the filename is a dot (`.`), which signifies a hidden file in Unix-like systems.
   - **Action if True:**
     **`continue;`**
     - Effect:
       - **Skips Remaining Code in Loop Body:** The program **does not** execute any further statements within the loop for this iteration.
       - **Proceeds to Next Iteration:** The loop **moves directly** to fetch the next directory entry.
4. **Process Non-Hidden Files:**
   - If the filename does not start with a dot, the program proceeds to:
     - **Retrieve File Metadata:**
       **`r = stat(filename, &fs);`**
     - Error Handling:
       - If `stat` fails, print an error and exit.
     - Check if Entry Is a Directory:
       - If it is, print the directory name.

### **Why Use `continue` Here?**

- **Selective Processing:**
  By using `continue`, the program **excludes all hidden files** from being processed further. This ensures that only visible (non-hidden) files and directories are considered for actions like printing.
- **Efficiency:**
  - **Avoid Unnecessary Operations:**
    Skipping hidden files **prevents** the program from performing operations (like `stat` and printing) on files that the user might not be interested in viewing.
  - **Streamlined Output:**
    Results in a **cleaner and more relevant output**, focusing only on the files and directories that are visible to the user.



```shell
chan@CMA:~/C_Programming/test$ ./final
Missing directory name
chan@CMA:~/C_Programming/test$ ./final /home/chan
Found directory: Downloads
Found directory: Music
Found directory: directory...
Found directory: Photos
Found directory: Pictures
Found directory: exercise_2
Found directory: Desktop
Found directory: C_Programming
Found directory: Videos
Found directory: Documents
Found directory: Templates
Found directory: test
Found directory: github.com
Found directory: Public
Found directory: snap
```



### Mining deeper with recursion

`hello.h`

- The first is the full pathname to the directory to scan.
- The second is the full pathname to the parent directory.
- Both are const char types because neither string is modified within the function.

```C
void dir(const char *dirpath, const char *parentpath);
```

`hello.c`

```C
void dir(const char *dirpath, const char *parentpath){
    
    DIR *dp; // Directory pointer
    struct dirent *entry; // Directory entry structure
    struct stat fs; // Structure to hold file information
    
    // Storage for the new directory to change to, storing the full pathname
    char subdirpath[BUFSIZ];
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    // Outputs the current directory path
    printf("%s\n", dirpath);
    
    while((entry = readdir(dp)) != NULL){
        if(stncmp(entry->d_name, ".", 1) == 0){
            continue;
        }
        
        // Get info for each directory entry (inode)
        stat(entry->d_name, &fs);
        
        // Checks for a subdirectory entry
        if(S_ISDIR(fs.st_mode)){
            // Changes to the subdirectory
            if(chdir(entry->d_name) == -1){
                fprintf(stderr, "Unable o change to %s\n", entry->d_name);
                exit(1);
            }
            
            // Gets the subdirectory's full pathname for the recursive call
            getcwd(subdirpath, BUFSIZ);
            
            // Recursively calls the function with the subdirectory and current directory as arguments
            dir(subdirpath, dirpath);
        }
    }
    
    closedir(dp);
    
    // Changes back to the parent directory - full pathname
    if(chdir(parentpath) == -1){
        
        // Checks for NULL, in which case, just returns
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

- `void dir(const char *dirpath, const char *parentpath)`

  - **Purpose:** Recursively traverses directories starting from `dirpath`, ignoring hidden files, and prints directory paths.
  - Parameters:
    - `dirpath`: Path of the current directory to process.
    - `parentpath`: Path of the parent directory to return to after processing subdirectories.

- ```C
  stat(entry->d_name, &fs);
          
   
  if(S_ISDIR(fs.st_mode)){
              
      if(chdir(entry->d_name) == -1){
           fprintf(stderr, "Unable o change to %s\n", entry->d_name);
           exit(1);
      }
              
              
  getcwd(subdirpath, BUFSIZ);
              
  dir(subdirpath, dirpath);
  ```

  - Uses `stat` to retrieve information about the entry.
  - Checks if the entry is a **directory** using `S_ISDIR`.
  - If it's a directory:
    - Attempts to **change to the subdirectory** using `chdir`.
    - If unable to change, it prints an error and exits.
    - Retrieves the **absolute path** of the subdirectory.
    - **Recursively calls** `dir` on the subdirectory to process its contents.

`main.c`

```C
int main(int argc, char *argv[]){
    
    // Buffer to store the current directory path
    char current[BUFSIZ];
    
    if(argc < 2){
        // For no arguments obtains and stores the full path to the current directory
        getcwd(current, BUFSIZ);
    }else{
        
        // copies the first argument
        strcpy(current, argv[1]);
        
        // Change to the directory and check for errors
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access directory %s\n", current);
            exit(1);
        }
        
        // Get the directory full pathname
        getcwd(current, BUFSIZ);
    }
    
    // Calls the function; NULL is checked in dir()
    dir(current, NULL);
    
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final
/home/chan/C_Programming/test
/home/chan/C_Programming/test/libs
/home/chan/C_Programming/test/obj
```

##### Explanation of `dir()` function

##### **Detailed Step-by-Step Visualization on the output**

1. **Determine Current Directory**

- **Action:**
  - Since no command-line argument is provided, the program retrieves the **current working directory**.
- **Code Snippet (`main.c`):**

```C
if (argc < 2)
{
    getcwd(current, BUFSIZ); // Get current directory
}
```

- Result:
  - `current` is set to `test`.

2. **Traverse Directories Recursively**

   - Action:
     - The program calls the `dir` function to start traversing directories from the `current` path.
   - Code Snippet (`main.c`):

   ```C
   dir(current, NULL);
   ```

   - Function call (`hello.c`):
     - `void dir(const char *dirpath, const char *parentpath)`

3. **First Call:** `dir("/home/chan/C_Programming/test", NULL)`

   - Opening Directory:
     - Opens `test`
   - **Reading Entries**:
     - Iterates over each entry in the directory.
   - **Skipping Hidden Files:**
     - Skips any file or directory starting with a dot(`.`)
   - **Identifying Subdirectories:**
     - Finds:
       - `libs` (Directory)
       - `obj` (Directory)
   - **Recursion**:
     - For each subdirectory (`libs` and `obj` ), the program:
       - **Changes Directory**:
         - `chdir("libs")` and `chdir("obj")`
       - **Gets Absolute Path**:
         - libs
         - obj
       - **Recursive Call**:
         - `dir("/home/chan/C_Programming/test/libs", "/home/chan/C_Programming/test")`
         - `dir("/home/chan/C_Programming/test/obj", "/home/chan/C_Programming/test")`

4. **Recursive Calls**:

   - For `libs` :
     - **Opening Directory**:
       - Opens `libs`
     - **Reading Entries**:
       - No subdirectories found or subdirectores are hidden.
     - **Output**:
       - libs
   - For `obj`:
     - **Opening Directory**:
       - Opens `obj`
     - **Reading Entries**:
       - No subdirectories found or subdirectories are hidden.
     - **Output**:
       - obj

5. **Output Directory Paths**:

```sh
/home/chan/C_Programming/test
/home/chan/C_Programming/test/libs
/home/chan/C_Programming/test/obj
```



### Pulling out the directory name

`hello.h`

```C
const char *extract(const char *path);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    // If the string is empty, return NULL
    if(len == 0){
        return NULL;
    }
    
    // Perform a special test for the root directory
    if(len == 1 & path[0] == '/'){
        return path;
    }
    
    // Positions pointer p at the end of string path
    p = path+len;
    
    // Backs up p to find the separator; for Windows, uses \\ as the separator
    while(*p != '/'){
        p--;
        
        // If p backs up too far, returns NULL
        if(p == path){
            return NULL;
        }
    }
    
    // Increments p over the separator character
    p++;
    
    // Test to see if the string is empty or malformed and returns NULL
    if(*p == '\0'){
        return NULL;
    }else{
        // Returns the address where the final directory name starts
        return p;
    }
}
```

`main.c`

```C
#define COUNT 4

int main(){
    const char *pathname[COUNT] = {
        "/home/chan", "/usr/local", "/", "nothing here"
    };
    int x;
    for(x = 0; x < COUNT; x++){
        printf("%s -> %s\n", pathname[x], extract(pathname[x]));
    }
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
/home/chan -> chan
/usr/local -> local
/ -> /
nothing here -> (null)

```

- The `extract()` function successfully processes each string, returning the last part, the directory name. 
- It even catches the malformed string, properly returning NULL.



### Adding `extract()` function to the `dir()` program

`hello.h`

```C
const char *extract(const char *path);

void dir(const char *dirpath, const char *parentpath);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    if(len == 0){
        return NULL;
    }
    if(len == 1 && path[0] == '/'){
        return path;
    }
    
    p = path + len;
    while(*p != '/'){
        p--;
        
        if(p == path){
            return NULL;
        }
    }
    
    p++;
    
    if(*p == '\0'){
        return NULL;
    }else{
        return p;
    }
}



void dir(const char *dirpath, const char *parentpath){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[BUFSIZ];
    
    dp = opendir(dp);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    printf("%s\n", extract(dirpath));
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        if(strncmp(filename, ".", 1) == 0){
            continue;
        }
        
        stat(filename, &fs);
        
        if(S_ISDIR(fs_st_mode)){
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change directory to '%s'\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            dir(subdirpath, dirpath);
        }
    }
    
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        fprintf(stderr, "Parent direcotry lost\n");
        exit(1);
    }
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    char current[BUFSIZ];
    
    if(argc < 2){
        getcwd(current, BUFSIZ);
    }else{
        strcpy(current, argv[1]);
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access %s\n", current);
            exit(1);
        }
        getcwd(current, BUFSIZ);
    }
    dir(current, NULL);
    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
test
libs
obj
```



### Monitoring directory depth

- To monitor the directory depth (make the directory output a bit more "tree-like"), the `dir()` function is updated:

```C
void dir(const char *dirpath, const char *parentpath, int depth);
```

- Three arguments is the maximum for a function.
- Any more arguments and it becomes obvious that what should really be passed to the function is a structure.
- To complete the modification, three more changes are required. 
- First, in the `main()` function, the `dir()` function is originally called with zero as its third argument:

```C
dir(current, NULL, 0);
```

- The zero sets the indent depth as the program starts: the first directory is the top level.
- The second, the recursive call within the `dir()` function must be modified, adding the third argument `depth`:

```C
dir(subdirpath, dirpath, depth+1);
```

- For the recursive call, which means the program is diving down one directory level, the indent level `depth` is increased by one.
- Finally, something must be done with the `depth` variable within the `dir()` function. Adding a loop that outputs a chunk of three spaces for every depth level.

```C
for(i = 0; i < depth; i++){
    printf("   ");
}
```

- This loop appears before the `printf()` statement that outputs the directory's name, just before the `while` loop.
- The result is that each subdirectory is indented three spaces as the directory tree is output.



`hello.h`

```C
const char *extract(const char *path);

void dir(const char *dirpath, const char *parentpath, int depth);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    // If the string is empty, return NULL
    if(len == 0){
        return NULL;
    }
    
    // Perform a special test for the root directory
    if(len == 1 && path[0] == '/'){
        return path;
    }
    
    // Positions pointer p at the end of string path
    p = path + len;
    
    // Backs up p to find the separator;
    while(*p != '/'){
        p--;
        
        // If p backs up too far, returns NULL
        if(p == path){
            return NULL;
        }
    }
    
    // Increments p over the separator character
    p++;
    
    
    // Test to see if the string is empty or malformed and returns NULL
    if(*p == '\0'){
        return NULL;
    }else{
        // Returns the address where the final directory name starts
        return p;
    }
}


void dir(const char *dirpath, const char *parentpath, int depth){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[BUFSIZ];
    int i;
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    for(i = 0; i < depth; i++){
        printf("   "); // 3 spaces for each depth level
    }
    
    printf("%s\n", extract(dirpath));
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        if(strncmp(filename, ".", 1) == 0){
            continue;
        }
        
        stat(filename, &fs);
        if(S_ISDIR(fs.st_mode)){
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change directory to '%s'\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            dir(subdirpath, dirpath, depth + 1);
        }
    }
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

- **Functionality:**
  - **`chdir(parentpath)`:**
    Attempts to **change the current working directory back** to the **parent directory** after finishing the traversal of a subdirectory.
- **Reasoning:**
  - **Recursive Traversal Needs:**
    After entering a subdirectory and completing its processing, the program needs to **return to the parent directory** to continue processing other entries.
  - **Maintaining Directory State:**
    Ensures that each recursive call to `dir` operates within the correct directory context.

### **2. **Handling Edge Cases and Errors**

- **`if (chdir(parentpath) == -1)`:**
  Checks if changing back to the parent directory **fails**.
- **Sub-Conditions:**
  - **`if (parentpath == NULL)`:**
    - Scenario:
      - This condition is **true** when the `dir` function was initially called from `main` with `parentpath` set to `NULL`.
      - Implication:
        - Since there's **no parent directory** to return to (the initial call), the function simply **returns**, effectively ending the traversal.
  - **`else` Block:**
    - Scenario:
      - Occurs when `parentpath` is **not `NULL`**, meaning the function was called recursively for a subdirectory.
    - Implication:
      - Error Handling:
        - Indicates a critical failure in changing back to the parent directory, which disrupts the traversal process.
      - Actions Taken:
        - **`fprintf`:**
          Prints an error message indicating that the program **cannot return to the parent directory**.
        - **`exit(1)`:**
          **Terminates the program** with a failure status, preventing further undefined behavior.

`main.c`

```C
int main(int argc, char *argv[]){
    char current[BUFSIZ];
    
    if(argc < 2){
        getcwd(current, BUFSIZ);
    }else{
        strcpy(current, argv[1]);
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access directory %s\n", current);
            exit(1);
        }
        getcwd(current, BUFSIZ);
    }
    
    dir(current, NULL, 0);
    return 0;
}
```

**Visualization of Execution Flow**

```
main.c
  |
  |-- Calls dir("/home/chan/C_Programming/test", NULL, 0)
        |
        |-- Opens "/home/chan/C_Programming/test"
        |-- Prints extracted path
        |-- Iterates through entries:
              |-- Entry: "libs" (Directory)
                    |-- chdir("libs")
                    |-- Calls dir("/home/chan/C_Programming/test/libs", "/home/chan/C_Programming/test", 1)
                          |
                          |-- Opens "/home/chan/C_Programming/test/libs"
                          |-- Prints extracted path
                          |-- Iterates through entries:
                                |-- (Assume no subdirectories)
                          |-- closedir(dp)
                          |-- chdir("/home/chan/C_Programming/test")
          |-- Entry: "obj" (Directory)
                    |-- chdir("obj")
                    |-- Calls dir("/home/chan/C_Programming/test/obj", "/home/chan/C_Programming/test", 1)
                          |
                          |-- Opens "/home/chan/C_Programming/test/obj"
                          |-- Prints extracted path
                          |-- Iterates through entries:
                                |-- (Assume no subdirectories)
                          |-- closedir(dp)
                          |-- chdir("/home/chan/C_Programming/test")
        |-- closedir(dp)
        |-- chdir(NULL) --> Fails
              |-- Since parentpath == NULL
                    |-- return;
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final /home/chan/github.com
github.com
   MyLearningNotes
      Data Structures & Algorithms
      Databases
         Supabase
         MongoDB
      Next.js
      C_Learning
      CS
      Linux
chan@CMA:~/C_Programming/test$ ./final 
test
   libs
   obj

```

- The output shows the directory and Subdirectory in a tree-like structure.
- Each subdirectory is indented three spaces. The sub-directories of the `MyLearningNotes` are further indented.
- In the second output, there is a test directory, inside the test directory, two subdirectories `libs` and `obj` are displayed with three spaces from the left forming a tree like structure.



**Exercise 10.3**

Modify the source code above so that instead of indenting with blanks, the subdirectories appear with text mode graphics.

`hello.h`

```C
const char *extract(const char *path);

void dir(const char *dirpath, const char *parentpath, int depth);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    // If the string is empty, return NULL
    if(len == 0){
        return NULL;
    }
    
    // Perform a special test for the root directory
    if(len == 1 && path[0] == '/'){
        return path;
    }
    
    // Positions pointer p at the end of string path
    p = path + len;
    
    // Backs up p to find the separator;
    while(*p != '/'){
        p--;
        
        // If p backs up too far, returns NULL
        if(p == path){
            return NULL;
        }
    }
    
    // Increments p over the separator character
    p++;
    
    
    // Test to see if the string is empty or malformed and returns NULL
    if(*p == '\0'){
        return NULL;
    }else{
        // Returns the address where the final directory name starts
        return p;
    }
}


void dir(const char *dirpath, const char *parentpath, int depth){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[BUFSIZ];
    int i;
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    for(i = 0; i < depth; i++){
        printf("   "); // 3 spaces for each depth level
    }
    
    printf("%s\n", extract(dirpath));
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        if(strncmp(filename, ".", 1) == 0){
            continue;
        }
        
        stat(filename, &fs);
        if(S_ISDIR(fs.st_mode)){
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change directory to '%s'\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            dir(subdirpath, dirpath, depth + 1);
        }
    }
    closedir(dp);
    
    // If no further subdirectories are found, change the directory back to the parentpath to furthur process the directories inside the parent.
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    char current[BUFSIZ];
    
    if(argc < 2){
        getcwd(current, BUFSIZ);
    }else{
        strcpy(current, argv[1]);
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access directory %s\n", current);
            exit(1);
        }
        getcwd(current, BUFSIZ);
    }
    
    dir(current, NULL, 0);
    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
test
+--libs
+--obj
chan@CMA:~/C_Programming/test$ ./final /home/chan/github.com
github.com
+--MyLearningNotes
|  +--Data Structures & Algorithms
|  +--Databases
|  |  +--Supabase
|  |  +--MongoDB
|  +--Next.js
|  +--C_Learning
|  +--CS
|  +--Linux

```

**Visual Representation of the output**:

- **Root Directory (`test`):**

  - **`depth = 0`**: No indentation or connectors.
  - **Output:** `test`

- **First Level (`libs`, `obj`):**

  - `depth = 1`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `+--libs`, `+--obj`

  

- **Root Directory (`github.com`):**

  - **`depth = 0`**: No indentation or connectors.
  - **Output:** `github.com`

- **First Level (`MyLearningNotes`):**

  - `depth = 1`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `+--MyLearningNotes`

- **Second Level (`Data Structures & Algorithms`, `Databases`, `Next.js`, `C_Learning`, `CS`, `Linux`):**

  - `depth = 2`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: False
      - **Output:** `|`
    - Iteration (`i = 1`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `| +--Data Structures & Algorithms`, `| +--Databases`, `| +--Next.js`, `| +--C_Learning`, `| +--CS`, `| +--Linux`

- **Third Level (`Supabase`, `MongoDB` under `Databases`):**

  - `depth = 3`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: False
      - **Output:** `|`
    - Iteration (`i = 1`):
      - **`i == depth - 1`**: False
      - **Output:** `|`
    - Iteration (`i = 2`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `| | +--Supabase`, `| | +--MongoDB`

---

