## Chapter 9 - Hex Dumper

- Hexdump is a Linux utility available as part of the default installation.
- In C, the 8-bit byte corresponds directly to the `char` data type.



```C
unsigned long byte = sizeof(char) * 8;
```

- The `sizeof` operator returns the number of bytes used by a specific C language data type, `char` .
- This value is multiplied by eight to obtain the number of bits.
- The result is stored in `unsigned long` variable `byte`.

```sh
chan@CMA:~/C_Programming/test$ ./final
Size of char: 8
```

- We don't need to perform the math and overhead.

- The reason is that the compiler itself has a limit.
- Specifically, the limit values are set as defined constants in the appropriately named `limits.h` header file.
- Memory capacity, media storage, file size - all these quantities are measured in 8-bit bytes, `char` values.
- This yardstick gives rise to two systems for counting bytes: one based on the powers of two (binary), the other on the powers of 10 (decimal).
- When we allocate 1 K (kilobyte) of memory, we are setting aside 1024 char-sized pieces of memory as a single chunk.
- All `char` or byte-size values easily fit within an integer-sized chunk.
- The `int` data type avoid any wrapping that occurs with a `char` which is probably one reason why functions like `getchar()` and `putchar()` use integers instead of `char` types.



The next listing stores the 256 `char` values in a char array, `data[]`.

- Two `for` loops process the array, the first to fill it and the second to output its values.
- Though the array stores only byte values, `int` variable `b` is used to store the values.

```C
int main(){
    // Room for the full variety of byte values
    unsigned char data[256];
    int b;
    
    for(b = 0; b < 256; b++){
        data[b] = b;
    }
    
    for(b = 0; b < 256; b++){
        printf("%d\n", data[b]);
    }
    return 0;
}
```

- With an array holding the values, allows for modifications and manipulations to be made to the stored data.
- The goal is to accurately present the data in a readable format. 
- The inelegant term for doing so is `dump`.



### Dumping data

- Dump is both a noun and a verb, neither of which is flattering.
- What's being dumped isn't considered useful unless it's data.
- In the digital realm, a *dump* is the movement of data from one place to another.
- To dump data in C, we copy it from one location to another.
- We can dump a chunk of memory, though only the memory the program has access to.



```C
int main()
{
    unsigned char data[256];
    int b;

    for (b = 0; b < 256; b++)
    {
        data[b] = b;
    }

    for (b = 0; b < 256; b++)
    {
        printf(" %02X", data[b]);
        // output a newline every 16 bytes
        if ((b + 1) % 16 == 0)
        {
            putchar('\n');
        }
    }
    return 0;
}
```

- One is added to the value of `b`, (b + 1), to avoid a newline popping out after the first value (zero).

![Screenshot from 2024-11-14 21-35-15](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-14 21-35-15.png)

- The output is better, but it could still use some improvement.
- Because the data dump is sequential, it's easy to see patterns and reference rows and columns.



**Exercise 9.2**

Improve the code in the previous program in two stages. First add an initial column showing the byte values' offset. Output this value as a 5-digit hexadecimal number. Then output the row of 16 bytes.

Second, add an extra space to separate the eighth and ninth byte columns. This space makes the rows and columns more readable.

**Solution**

```C
int main(){
    unsigned char data[256];
    int b;
    
    // Initialize the 'data' array with values from 0 to 255
    for(b = 0; b < 256; b++){
        data[b] = b;
    }
    
    // Iterate thru the 'data' array to print its content
    for(b = 0; b < 256; b++){
        if(b % 16 == 0){
            // Print b as a 5-digit hexadecimal number with leading zeros
            printf("%05X ", b);
        }
        
        // Print the current byte in hexadecimal format 
        printf(" %02X", data[b]); //Print 'data[b]' as a 2-digit hexadecimal number with leading zeros
        
        // Insert a space after every 8 bytes for readability
        if((b + 1) % 8 == 0){
            putchar(' ');
        }
        
        // After every 16 bytes, print a newline character to move to the next line
        if((b + 1) % 16 == 0){
            putchar('\n');
        }
    }
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
00000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F 
00010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F 
00020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F 
00030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F 
00040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F 
00050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F 
00060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F 
00070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F 
00080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F 
00090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F 
000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF 
000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF 
000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF 
000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF 
000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF 
000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF 

```

- A final improvement is to add a third ASCII column after the byte values.
- This additional information cross-references the hex bytes of displayable ASCII text, providing a handy way for humans to quickly scan the dump for relevant information.
- The ordeal of adding an ASCII column to the output is complicated due to stream output.
- Each row must be processed sequentially: 16 bytes are output as hex values and then the same bytes are output as printable ASCII characters.
- To resolve this, the `line_out()` function features three arguements,
  - an offset representing a byte count,
  - the length of the data chunk,
  - and the data itself as an `unsigned char` pointer
- Variable `a` tracks progress in the `for` loops and is used with the data pointer to fetch specific byte values: `*(data + a)`.
- This function outputs a single row of the dump, so it is called from the `main` function to output all the data.

`hello.h`

```C
void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data){
    int a;
    
    // Print the offset in 5-digit hex format followed by a space
    printf("%05X ", offset);
    
    // Print each byte in hex format
    for(a = 0; a < length; a++){
        printf(" %02X", *(data + a));
        
        // After every 8 bytes, print an extra space for readability
        if((a + 1) % 8 == 0){
            putchar(' ');
        }
    }
    
    // Additional space between hex bytes and ASCII representation
    putchar(' ');
    
    // Print the ASCII representation of each byte
    for(a = 0; a < length; a++){
        
        // Check if byte is printable
        if(*(data + a) >= ' ' && *(data + a) <= '~'){
            putchar(*(data + a));
        }else{
            putchar(' ');
        }
    }
    putchar('\n');
}
```

`main.c`

```C
int main(){
    unsigned char data[256];
    int b;
    
    const int length = 16;
    
    for(b = 0; b < 256; b++){
        data[b] = b;
    }
    
    // Iterate over the data array in steps of length (16 bytes)
    for(b = 0; b < 256; b += length){
        // Call the line_out func to print each 16-byte chunk
        // Pass the current offset, the length, and a pointer to the current chunk
        line_out(b, length, data + b);
    }
    
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
00000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F                  
00010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F                  
00020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !"#$%&'()*+,-./
00030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;<=>?
00040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO
00050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_
00060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno
00070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~ 
00080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F                  
00090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F                  
000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF                  
000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF                  
000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF                  
000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF                  
000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF                  
000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF    
```

![Screenshot from 2024-11-16 21-36-10](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-16 21-36-10.png)

**Exercise 9.3**

The output from the preceding program is predictable  - awath of 256-byte values from 0x00 through 0xFF. Le

s modify the code to repopulate the `data[]` buffer with random values.

`hello.c`

```c#
void line_out(int offset, int length, unsigned char *data)
{
    int a;
    printf("%05X ", offset);

    for (a = 0; a < length; a++)
    {
        printf(" %02X", *(data + a));
        if ((a + 1) % 8 == 0)
        {
            putchar(' ');
        }
    }
    putchar(' ');

    for (a = 0; a < length; a++)
    {
        if (*(data + a) >= ' ' && *(data + a) <= '~')
        {
            putchar(*(data + a));
        }
        else
        {
            putchar(' ');
        }
    }

    putchar('\n');
}
```

`main.c`

```C
int main()
{
    unsigned char data[256];
    int b;
    const int length = 16;

    srand((unsigned)(time(NULL)));

    for (b = 0; b < 256; b++)
    {
        data[b] = rand() % 256;
    }

    for (b = 0; b < 256; b += length)
    {
        line_out(b, length, data + b);
    }
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
00000  BA A3 19 01 F1 24 4F 5D  1A 8A DD 1A 07 65 4B EF       $O]     eK 
00010  D9 AC 52 73 76 B9 BC 56  B8 0E 25 A3 BE 8B 18 78    Rsv  V  %    x
00020  2E 31 7A 1F 56 C9 7D 70  53 5A 8B 5A BF D6 4A 99  .1z V }pSZ Z  J 
00030  82 9C 0C F8 55 C8 4F 0D  D7 74 B1 95 FF C9 0E 2E      U O  t     .
00040  FA 88 4D 50 51 CA C1 A5  24 4C FF E4 22 49 7D A4    MPQ   $L  "I} 
00050  E5 89 9D 3B 51 EC 48 28  60 F9 BE 5F C2 CC 8D BD     ;Q H(`  _    
00060  54 DB 0D A5 A5 CE 4A CA  1A 4A AE 3C 93 2B E1 79  T     J  J < + y
00070  B4 7E B4 05 6A FC 2E CA  F6 EC 29 B8 B8 B7 75 0C   ~  j .   )   u 
00080  92 83 B1 37 51 FC 01 6C  46 AF A8 D9 DA 89 52 8E     7Q  lF     R 
00090  07 06 94 71 03 C2 3B F9  AE 65 B1 66 1C 27 72 AE     q  ;  e f 'r 
000A0  AA 23 E5 FB 1F E7 67 65  96 10 3F 71 99 91 FF A1   #    ge  ?q    
000B0  98 93 12 9B 55 4E 94 03  B3 45 69 CF 6C DB 7D 16      UN   Ei l } 
000C0  FF 62 12 1E 49 79 84 E0  89 C3 51 23 54 50 C4 EC   b  Iy    Q#TP  
000D0  E4 D6 87 39 24 1B 3D D7  61 A6 A6 CD 82 23 E4 81     9$ = a    #  
000E0  86 F6 9F CF 6F 23 AF F9  E6 00 1C 3B 51 E0 27 35      o#     ;Q '5
000F0  B6 AF 6E DB CA AB B2 2B  52 59 F9 D4 7C DD 55 02    n    +RY  | U 
chan@CMA:~/C_Programming/test$ ./final
00000  AB 5A 9F 73 61 3C C5 22  2B 2F 31 EB D5 3C 4A CE   Z sa< "+/1  <J 
00010  25 81 8C AB 57 11 2D 04  1A E1 37 11 78 CD B5 23  %   W -   7 x  #
00020  28 54 97 89 90 5C AB BC  8B DC A7 60 18 F1 2F 3D  (T   \     `  /=
00030  72 BB E9 CA CD 16 CE E7  F7 05 F9 70 D3 AE 93 FB  r          p    
00040  02 2A 84 92 86 2F 4E 12  0B F5 72 23 E7 A1 60 59   *   /N   r#  `Y
00050  5D 49 23 2A 5F F2 11 57  F7 0A C7 CA B8 5A C5 BA  ]I#*_  W     Z  
00060  85 49 4D 0B 78 9B 1D 83  91 90 A6 78 31 07 D1 8E   IM x      x1   
00070  50 F5 B8 B0 E7 CA 07 DE  D4 CE A9 8D 28 6E 47 AD  P           (nG 
00080  B8 94 B9 30 30 D6 B4 C1  66 5A 39 98 61 0A 26 B2     00   fZ9 a & 
00090  FF DF 62 E6 A9 69 C5 7D  37 6E 0A 5F DC 52 0D 94    b  i }7n _ R  
000A0  E6 C6 C5 16 9C 79 D7 03  D3 10 9B 35 1B C1 E7 1A       y     5    
000B0  A0 49 01 49 B2 C6 C7 E9  34 D1 48 10 23 55 A5 0A   I I    4 H #U  
000C0  1B 6A 20 B8 E3 F8 BB B6  08 56 EB 23 17 D2 3E B8   j       V #  > 
000D0  1B 3F 01 CD 05 C8 B6 39  9A FF 49 BD 54 EE C7 70   ?     9  I T  p
000E0  58 E8 28 3B E0 E3 F2 E8  39 DD 0C 50 B0 4A 08 CB  X (;    9  P J  
000F0  89 0A 99 8E D2 4F C7 6C  4E 10 2A A3 FF F1 13 57       O lN * 
```



### Reading file data

- A `dumpfile` utility could be written as a filter, just like Linux's `hexdump`.
- As a filter, `hexdump` chews through all input whether it originates from a file or is the output from some program.
- Utilities that read data from a file use two approaches.
  - The first is to specify the filename at the command prompt - usually, as the first (and often only) argument.
  - The second way is to prompt for a filename after the utility starts, or to prompt for the filename if it's missing as a command-line argument.
- `bytes.dat` test file is used for the following listing and it contains sequential byte values from 0x00 through 0xFF.



`hello.h`

```C
void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data)
{
    int a;
    
    // Print the offset in hexadecimal (5 digits with leading zeros)
    printf("%05X ", offset);

    // Iterate through each byte to format the ASCII representation
    for (a = 0; a < length; a++)
    {
        printf(" %02X", *(data + a));
        
        // Insert a space after every 8 bytes for readability
        if ((a + 1) % 8 == 0)
        {
            putchar(' ');
        }
    }
    
    // Additional space between hex and ASCII sections
    putchar(' ');

    // Iterate through each byte again to print ASCII characters
    for (a = 0; a < length; a++)
    {
        // Check if the byte is a printable ASCII character
        if (*(data + a) >= ' ' && *(data + a) <= '~')
        {
            putchar(*(data + a));
        }
        else
        {
            putchar(' ');
        }
    }

    putchar('\n');
}
```

- The condition `*(data + a) >= ' '` **and** `*(data + a) <= '~'` is used to determine whether a given byte in the `data` array represents a **printable ASCII character**.
- **Understanding the ASCII Range:**
  - **' ' (Space):** ASCII value **32**
  - **'~' (Tilde):** ASCII value **126**
  - **ASCII Printable Characters:** Range from **32** to **126**
  - This range includes all standard printable characters, such as letters, digits, punctuation marks, and common symbols.

`main.c`

```C
int main(int argc, char *argv[])
{
    const int length = 16;
    unsigned char buffer[length];
    char *filename;
    FILE *fp;
    
    // Variables for character reading, offset tracking, and buffer indexing
    int ch, offset, index;

    if (argc < 2)
    {
        fprintf(stderr, "Format: dumpfile filename\n");
        exit(1);
    }

    filename = argv[1];

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }
    
    offset = 0; // Initialize the offset (starting byte index) to zero
    index = 0;
    
    while (!feof(fp))
    {
        ch = fgetc(fp);
        if (ch == EOF)
        {
            // If there are remaining bytes in the buffer
            if (index != 0)
            {
                // Print the remaining bytes using line_out
                line_out(offset, index, buffer);
            }
            // Exit the loop as the file has been fully read
            break;
        }

        buffer[index] = ch; // Store the read byte into the buffer
        index++;
        
        // If the buffer is full (16 bytes)
        if (index == length)
        {
            // Print the buffer contents using line_out
            line_out(offset, length, buffer);
            
            // Update the offset for the next chunk
            offset += length;
            
            // Reset the buffer index for the next set of bytes
            index = 0;
        }
    }

    fclose(fp);

    return 0;
}

```

`Output`

```sh
 chan@CMA:~/C_Programming/test$ ./final
Format: dumpfile filename
chan@CMA:~/C_Programming/test$ ./final bytes.dat
00000 00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F                  
00010 10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F                  
00020 20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !"#$%&'()*+,-./
00030 30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;<=>?
00040 40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO
00050 50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_
00060 60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno
00070 70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~ 
00080 80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F                  
00090 90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F                  
000A0 A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF                  
000B0 B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF                  
000C0 C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF                  
000D0 D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF                  
000E0 E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF                  
000F0 F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF 
```



### Fixing uneven output

![Screenshot from 2024-11-17 19-52-09](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-17 19-52-09.png)

- At offset `0x00270` (the last line), the file's final byte, `0A` is immediately followed by the line's ASCII column,
- The text "to thee" is several spaces to the left of where it should line up - if the file ended exactly at 16-byte boundary.
- To resolve this problem, the `line_out()` function must know when a line of output doesn't match the default output length of 16 bytes.

In the next listing, we see how enum `SIZE` is used in the `line_out()` function to help test when the final line of output is shorter than 16 bytes.

- This change requires the addition of an `if` statement between the two existing `for` loops.
- The `if` decision helps to balance out the remainder of the last row of output so that the ASCII column lines up.

`hello.h`

```C
enum{
    SIZE = 16,
};

void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data){
    int a;
    
    printf("%05X ", offset);
    
    for(a = 0; a < length; a++){
        printf(" %02X", data[a]);
        if((a + 1) % 8 == 0){
            putchar(' ');
        }
    }
    
    // If the row has fewer than SIZE (16) bytes
    if(length < SIZE){
        
        // Continue the loop using variable a
        for(; a < SIZE; a++){
            
            // Outputs three spaces
            printf("   ");
            
            if((a + 1) % 8 == 0){
                putchar(' ');
            }
        }
    }
    
    putchar(' ');
    
    for(a = 0; a < length, a++){
        if(data[a] >= ' ' && data[a] <= '~'){
            putchar(data[a]);
        }else{
            putchar(' ');
        }
    }
    
    putchar('\n');
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int ch, offset, index;
    
    if(argc < 2){
        fprintf(stderr, "Format: dumpfile filename\n");
        exit(1);
    }
    
    filename = argv[1];
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }
    
    offset = 0;
    index = 0;
    while(!feof(fp)){
        ch = fgetc(ch);
        if(ch == EOF){
            if(index != 0){
                line_out(offset, index, buffer );
                
            }
            break;
        }
        
        buffer[index] = ch;
        index++;
        
        // If the buffer is full (16 bytes)
        if(index == SIZE){
            
            // Print the buffer contents using line_out
            line_out(offset, SIZE, buffer);
            // Update the offset for the next chunk
            offset += SIZE;
            index = 0;
        }
    }
    
    fclose(fp);
    return 0;
}
```

- Purpose of `offset` and `SIZE`

  - **`offset`**: This variable keeps track of the current byte position in the file. It represents the starting byte index of each line in the hexdump.
  - **`SIZE`**: This is a constant that defines the number of bytes to read and display per line. In our program, `SIZE` is typically set to `16`, meaning each line of the hexdump will display 16 bytes.

- **Why `offset += SIZE`?**

  - Every time we read a chunk of `SIZE` bytes from the file, we process and display those bytes in one line of the hexdump. 

  - After processing, we need to update the `offset` to reflect the position of the next chunk of bytes to be read. 

  - By adding `SIZE` to `offset`, we ensure that each subsequent line accurately represents the next set of bytes in the file.

- **Example Flow:**

  1. **First Line:**
     - **Offset**: `0`
     - **Bytes Displayed**: Bytes `0` to `15`
     - **After Processing**: `offset += 16` → `offset = 16`
  2. **Second Line:**
     - **Offset**: `16`
     - **Bytes Displayed**: Bytes `16` to `31`
     - **After Processing**: `offset += 16` → `offset = 32`
  3. **And so on...**

- Visualizing the Process with `sonnet18.txt`

  - **Step-by-Step Execution**

    1. **Program Start:**

       - Initial Variables:
         - `offset = 0`
         - `index = 0`
         - `buffer[16]` is empty.

    2. **Reading the First 16 Bytes:**

       - **Bytes Read:**

         ```
         S h a l l   I   c o m p a r e
         ```

       - **Buffer Contents (Hex):**

         ```
         53 68 61 6C 6C 20 49 20 63 6F 6D 70 61 72 65
         ```

       - **Calling `line_out(offset, 16, buffer)`**

         ```
         00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65     Shall I compare
         ```

       - Update Offset:

         - `offset += 16` → `offset = 16`

    3. **Reading the Next 16 bytes**:

       - Bytes Read:

         ```
          t o   a   s u m m e r ' s   d a y 
         ```

       - **Buffer Contents (Hex):**

         ```
         20 74 6F 20 61 20 73 75 6D 6D 65 72 27 73 20 64
         ```

       - **Calling `line_out(offset, 16, buffer)`:**

         - Prints:

         ```
         00010  20 74 6F 20 61 20 73 75  6D 6D 65 72 27 73 20 64   to a summer's d
         ```

       - Update Offset:

         - `offset += 16` → `offset = 32`

    4. **Continuing the Process:**

       This process repeats, reading 16 bytes at a time, calling `line_out` to display each chunk, and updating the `offset` accordingly.

    5. **Handling the Last Chunk:**

       If the total number of bytes isn't a multiple of `SIZE`, the remaining bytes are processed similarly, ensuring the hexdump is complete.

`sonnet18.txt`

```
Shall I compare thee to a summer's day?
Thou art more lovely and more temperate:
Rough winds do shake the darling buds of May,
And summer's lease hath all too short a date;
Sometime too hot the eye of heaven shines,
And often is his gold complexion dimm'd;
And every fair from fair sometime declines,
By chance or nature's changing course untrimm'd;
But thy eternal summer shall not fade,
Nor lose possession of that fair thou ow'st;
Nor shall death brag thou wander'st in his shade,
When in eternal lines to time thou grow'st:
So long as men can breathe or eyes can see,
So long lives this, and this gives life to thee.
```



`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final bytes.dat
00000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F                  
00010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F                  
00020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !"#$%&'()*+,-./
00030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;<=>?
00040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO
00050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_
00060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno
00070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~ 
00080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F                  
00090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F                  
000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF                  
000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF                  
000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF                  
000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF                  
000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF                  
000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF     


han@CMA:~/C_Programming/test$ ./final sonnet18.txt
00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65 20  Shall I compare 
00010  74 68 65 65 20 74 6F 20  61 20 73 75 6D 6D 65 72  thee to a summer
00020  27 73 20 64 61 79 3F 0A  54 68 6F 75 20 61 72 74  's day? Thou art
00030  20 6D 6F 72 65 20 6C 6F  76 65 6C 79 20 61 6E 64   more lovely and
00040  20 6D 6F 72 65 20 74 65  6D 70 65 72 61 74 65 3A   more temperate:
00050  0A 52 6F 75 67 68 20 77  69 6E 64 73 20 64 6F 20   Rough winds do 
00060  73 68 61 6B 65 20 74 68  65 20 64 61 72 6C 69 6E  shake the darlin
00070  67 20 62 75 64 73 20 6F  66 20 4D 61 79 2C 0A 41  g buds of May, A
00080  6E 64 20 73 75 6D 6D 65  72 27 73 20 6C 65 61 73  nd summer's leas
00090  65 20 68 61 74 68 20 61  6C 6C 20 74 6F 6F 20 73  e hath all too s
000A0  68 6F 72 74 20 61 20 64  61 74 65 3B 0A 53 6F 6D  hort a date; Som
000B0  65 74 69 6D 65 20 74 6F  6F 20 68 6F 74 20 74 68  etime too hot th
000C0  65 20 65 79 65 20 6F 66  20 68 65 61 76 65 6E 20  e eye of heaven 
000D0  73 68 69 6E 65 73 2C 0A  41 6E 64 20 6F 66 74 65  shines, And ofte
000E0  6E 20 69 73 20 68 69 73  20 67 6F 6C 64 20 63 6F  n is his gold co
000F0  6D 70 6C 65 78 69 6F 6E  20 64 69 6D 6D 27 64 3B  mplexion dimm'd;
00100  0A 41 6E 64 20 65 76 65  72 79 20 66 61 69 72 20   And every fair 
00110  66 72 6F 6D 20 66 61 69  72 20 73 6F 6D 65 74 69  from fair someti
00120  6D 65 20 64 65 63 6C 69  6E 65 73 2C 0A 42 79 20  me declines, By 
00130  63 68 61 6E 63 65 20 6F  72 20 6E 61 74 75 72 65  chance or nature
00140  27 73 20 63 68 61 6E 67  69 6E 67 20 63 6F 75 72  's changing cour
00150  73 65 20 75 6E 74 72 69  6D 6D 27 64 3B 0A 42 75  se untrimm'd; Bu
00160  74 20 74 68 79 20 65 74  65 72 6E 61 6C 20 73 75  t thy eternal su
00170  6D 6D 65 72 20 73 68 61  6C 6C 20 6E 6F 74 20 66  mmer shall not f
00180  61 64 65 2C 0A 4E 6F 72  20 6C 6F 73 65 20 70 6F  ade, Nor lose po
00190  73 73 65 73 73 69 6F 6E  20 6F 66 20 74 68 61 74  ssession of that
001A0  20 66 61 69 72 20 74 68  6F 75 20 6F 77 27 73 74   fair thou ow'st
001B0  3B 0A 4E 6F 72 20 73 68  61 6C 6C 20 64 65 61 74  ; Nor shall deat
001C0  68 20 62 72 61 67 20 74  68 6F 75 20 77 61 6E 64  h brag thou wand
001D0  65 72 27 73 74 20 69 6E  20 68 69 73 20 73 68 61  er'st in his sha
001E0  64 65 2C 0A 57 68 65 6E  20 69 6E 20 65 74 65 72  de, When in eter
001F0  6E 61 6C 20 6C 69 6E 65  73 20 74 6F 20 74 69 6D  nal lines to tim
00200  65 20 74 68 6F 75 20 67  72 6F 77 27 73 74 3A 0A  e thou grow'st: 
00210  53 6F 20 6C 6F 6E 67 20  61 73 20 6D 65 6E 20 63  So long as men c
00220  61 6E 20 62 72 65 61 74  68 65 20 6F 72 20 65 79  an breathe or ey
00230  65 73 20 63 61 6E 20 73  65 65 2C 0A 53 6F 20 6C  es can see, So l
00240  6F 6E 67 20 6C 69 76 65  73 20 74 68 69 73 2C 20  ong lives this, 
00250  61 6E 64 20 74 68 69 73  20 67 69 76 65 73 20 6C  and this gives l
00260  69 66 65 20 74 6F 20 74  68 65 65 2E              ife to thee.

```



![Screenshot from 2024-11-17 20-00-18](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-17 20-00-18.png)

**Exercise 9.4**

To further update the source code for the above program, modify the `main()` function so that if the filename argument is missing, the program prompts for it.

It's important that your code identify when the user just presses Enter or otherwise dismisses the filename prompt. There's no point in the program attempting to open a NULL string filename. Beyond this requirement, you don't need to otherwise validate the filename, because the `fopen()` statement does so automatically.

**Solution**

`hello.h`

```C
enum{
    SIZE = 16,
};

void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data){
    int a;
    
    printf("%05X ", offset);
    
    for(a = 0; a < length; a++){
        printf(" %02X", data[a]);
        if((a + 1) % 8 == 0){
            putchar(' ');
        }
    }
    
    // If the row has fewer than SIZE (16) bytes
    if(length < SIZE){
        
        // Continue the loop using variable a
        for(; a < SIZE; a++){
            
            // Outputs three spaces
            printf("   ");
            
            if((a + 1) % 8 == 0){
                putchar(' ');
            }
        }
    }
    
    putchar(' ');
    
    for(a = 0; a < length, a++){
        if(data[a] >= ' ' && data[a] <= '~'){
            putchar(data[a]);
        }else{
            putchar(' ');
        }
    }
    
    putchar('\n');
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int ch, offset, index;
    char fileinput[100];
    
    if(argc < 2){
        printf("Enter the filename: ");
        if(fgets(fileinput, sizeof(fileinput), stdin) != NULL){
            
            // ensures that the newline character from user input is removed properly
            fileinput[strcspn(fileinput, "\n")] = '\0';
        }
    }
    
    filename = (argc >= 2) ? argv[1] : fileinput;
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open file '%s'\n");
        exit(1);
    }
    
    offset = 0;
    index = 0;
    
    //Simplifed loop condition
    while((ch = fgetc(fp)) != EOF){
        buffer[index++] = (unsigned char)ch;
        
        if(index == SIZE){
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }
    
    // Handle remaining bytes after EOF
    if(index > 0){
        line_out(offset, index, buffer);
    }
    fclose(fp);
    return 0;
}
```

`main.c` (Author's solution)

```C
int main(int argc, char *argv[]){
    unsigned char buffer[SIZE];
    
    // the filename variable can now be an input buffer
    // BUFSIZ is defined in stdio.
    char filename[BUFSIZ];
    
    // For the fgets() function return value
    char *r;
    FILE *fp;
    int ch, offset, index;
    
    if(argc < 2){
        printf("Filename: ");
        r = fgets(filename, BUFSIZ, stdin);
        
        // a NULL return = nothing valid typed
        // if only '\n' in the buffer, nothing typed
        if(r == NULL || filename[0] == '\n'){
            exit(1);
        }
        
        // Remove the newline
        while(*r != '\n'){ // r = the string entered
            r++;
            
            // Check for overflow
            if(r - filename == BUFSIZ){
                exit(1);
            }
        }
        *r = '\0'l
    }else{
        strcpy(filename, argv[1]);
    }
    
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }
    
    offset = 0;
    index = 0;
    while((ch = fgetc(fp)) != EOF){
        buffer[index++] = (unsigned char)ch;
        
        if(index == SIZE){
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }
    
    if(index > 0){
        line_out(offset, index, buffer);
    }
    
    fclose(fp);
    
    return 0;
    
}
```



`Output`

```sh
han@CMA:~/C_Programming/test$ ./final
Enter the filename: hey
Unable to open file 'hey'

chan@CMA:~/C_Programming/test$ ./final
Enter the filename: sonnet18.txt
00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65 20  Shall I compare 
00010  74 68 65 65 20 74 6F 20  61 20 73 75 6D 6D 65 72  thee to a summer
00020  27 73 20 64 61 79 3F 0A  54 68 6F 75 20 61 72 74  's day? Thou art
00030  20 6D 6F 72 65 20 6C 6F  76 65 6C 79 20 61 6E 64   more lovely and
00040  20 6D 6F 72 65 20 74 65  6D 70 65 72 61 74 65 3A   more temperate:
00050  0A 52 6F 75 67 68 20 77  69 6E 64 73 20 64 6F 20   Rough winds do 
00060  73 68 61 6B 65 20 74 68  65 20 64 61 72 6C 69 6E  shake the darlin
00070  67 20 62 75 64 73 20 6F  66 20 4D 61 79 2C 0A 41  g buds of May, A
00080  6E 64 20 73 75 6D 6D 65  72 27 73 20 6C 65 61 73  nd summer's leas
00090  65 20 68 61 74 68 20 61  6C 6C 20 74 6F 6F 20 73  e hath all too s
000A0  68 6F 72 74 20 61 20 64  61 74 65 3B 0A 53 6F 6D  hort a date; Som
000B0  65 74 69 6D 65 20 74 6F  6F 20 68 6F 74 20 74 68  etime too hot th
000C0  65 20 65 79 65 20 6F 66  20 68 65 61 76 65 6E 20  e eye of heaven 
000D0  73 68 69 6E 65 73 2C 0A  41 6E 64 20 6F 66 74 65  shines, And ofte
000E0  6E 20 69 73 20 68 69 73  20 67 6F 6C 64 20 63 6F  n is his gold co
000F0  6D 70 6C 65 78 69 6F 6E  20 64 69 6D 6D 27 64 3B  mplexion dimm'd;
00100  0A 41 6E 64 20 65 76 65  72 79 20 66 61 69 72 20   And every fair 
00110  66 72 6F 6D 20 66 61 69  72 20 73 6F 6D 65 74 69  from fair someti
00120  6D 65 20 64 65 63 6C 69  6E 65 73 2C 0A 42 79 20  me declines, By 
00130  63 68 61 6E 63 65 20 6F  72 20 6E 61 74 75 72 65  chance or nature
00140  27 73 20 63 68 61 6E 67  69 6E 67 20 63 6F 75 72  's changing cour
00150  73 65 20 75 6E 74 72 69  6D 6D 27 64 3B 0A 42 75  se untrimm'd; Bu
00160  74 20 74 68 79 20 65 74  65 72 6E 61 6C 20 73 75  t thy eternal su
00170  6D 6D 65 72 20 73 68 61  6C 6C 20 6E 6F 74 20 66  mmer shall not f
00180  61 64 65 2C 0A 4E 6F 72  20 6C 6F 73 65 20 70 6F  ade, Nor lose po
00190  73 73 65 73 73 69 6F 6E  20 6F 66 20 74 68 61 74  ssession of that
001A0  20 66 61 69 72 20 74 68  6F 75 20 6F 77 27 73 74   fair thou ow'st
001B0  3B 0A 4E 6F 72 20 73 68  61 6C 6C 20 64 65 61 74  ; Nor shall deat
001C0  68 20 62 72 61 67 20 74  68 6F 75 20 77 61 6E 64  h brag thou wand
001D0  65 72 27 73 74 20 69 6E  20 68 69 73 20 73 68 61  er'st in his sha
001E0  64 65 2C 0A 57 68 65 6E  20 69 6E 20 65 74 65 72  de, When in eter
001F0  6E 61 6C 20 6C 69 6E 65  73 20 74 6F 20 74 69 6D  nal lines to tim
00200  65 20 74 68 6F 75 20 67  72 6F 77 27 73 74 3A 0A  e thou grow'st: 
00210  53 6F 20 6C 6F 6E 67 20  61 73 20 6D 65 6E 20 63  So long as men c
00220  61 6E 20 62 72 65 61 74  68 65 20 6F 72 20 65 79  an breathe or ey
00230  65 73 20 63 61 6E 20 73  65 65 2C 0A 53 6F 20 6C  es can see, So l
00240  6F 6E 67 20 6C 69 76 65  73 20 74 68 69 73 2C 20  ong lives this, 
00250  61 6E 64 20 74 68 69 73  20 67 69 76 65 73 20 6C  and this gives l
00260  69 66 65 20 74 6F 20 74  68 65 65 2E              ife to thee.
```

`Output` (Author's solution)

```sh
chan@CMA:~/C_Programming/test$ ./final
Filename: Good News
Unable to open file 'Good News'
chan@CMA:~/C_Programming/test$ ./final
Filename: sonnet18.txt
00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65 20  Shall I compare 
00010  74 68 65 65 20 74 6F 20  61 20 73 75 6D 6D 65 72  thee to a summer
00020  27 73 20 64 61 79 3F 0A  54 68 6F 75 20 61 72 74  's day? Thou art
00030  20 6D 6F 72 65 20 6C 6F  76 65 6C 79 20 61 6E 64   more lovely and
00040  20 6D 6F 72 65 20 74 65  6D 70 65 72 61 74 65 3A   more temperate:
00050  0A 52 6F 75 67 68 20 77  69 6E 64 73 20 64 6F 20   Rough winds do 
00060  73 68 61 6B 65 20 74 68  65 20 64 61 72 6C 69 6E  shake the darlin
00070  67 20 62 75 64 73 20 6F  66 20 4D 61 79 2C 0A 41  g buds of May, A
00080  6E 64 20 73 75 6D 6D 65  72 27 73 20 6C 65 61 73  nd summer's leas
00090  65 20 68 61 74 68 20 61  6C 6C 20 74 6F 6F 20 73  e hath all too s
000A0  68 6F 72 74 20 61 20 64  61 74 65 3B 0A 53 6F 6D  hort a date; Som
000B0  65 74 69 6D 65 20 74 6F  6F 20 68 6F 74 20 74 68  etime too hot th
000C0  65 20 65 79 65 20 6F 66  20 68 65 61 76 65 6E 20  e eye of heaven 
000D0  73 68 69 6E 65 73 2C 0A  41 6E 64 20 6F 66 74 65  shines, And ofte
000E0  6E 20 69 73 20 68 69 73  20 67 6F 6C 64 20 63 6F  n is his gold co
000F0  6D 70 6C 65 78 69 6F 6E  20 64 69 6D 6D 27 64 3B  mplexion dimm'd;
00100  0A 41 6E 64 20 65 76 65  72 79 20 66 61 69 72 20   And every fair 
00110  66 72 6F 6D 20 66 61 69  72 20 73 6F 6D 65 74 69  from fair someti
00120  6D 65 20 64 65 63 6C 69  6E 65 73 2C 0A 42 79 20  me declines, By 
00130  63 68 61 6E 63 65 20 6F  72 20 6E 61 74 75 72 65  chance or nature
00140  27 73 20 63 68 61 6E 67  69 6E 67 20 63 6F 75 72  's changing cour
00150  73 65 20 75 6E 74 72 69  6D 6D 27 64 3B 0A 42 75  se untrimm'd; Bu
00160  74 20 74 68 79 20 65 74  65 72 6E 61 6C 20 73 75  t thy eternal su
00170  6D 6D 65 72 20 73 68 61  6C 6C 20 6E 6F 74 20 66  mmer shall not f
00180  61 64 65 2C 0A 4E 6F 72  20 6C 6F 73 65 20 70 6F  ade, Nor lose po
00190  73 73 65 73 73 69 6F 6E  20 6F 66 20 74 68 61 74  ssession of that
001A0  20 66 61 69 72 20 74 68  6F 75 20 6F 77 27 73 74   fair thou ow'st
001B0  3B 0A 4E 6F 72 20 73 68  61 6C 6C 20 64 65 61 74  ; Nor shall deat
001C0  68 20 62 72 61 67 20 74  68 6F 75 20 77 61 6E 64  h brag thou wand
001D0  65 72 27 73 74 20 69 6E  20 68 69 73 20 73 68 61  er'st in his sha
001E0  64 65 2C 0A 57 68 65 6E  20 69 6E 20 65 74 65 72  de, When in eter
001F0  6E 61 6C 20 6C 69 6E 65  73 20 74 6F 20 74 69 6D  nal lines to tim
00200  65 20 74 68 6F 75 20 67  72 6F 77 27 73 74 3A 0A  e thou grow'st: 
00210  53 6F 20 6C 6F 6E 67 20  61 73 20 6D 65 6E 20 63  So long as men c
00220  61 6E 20 62 72 65 61 74  68 65 20 6F 72 20 65 79  an breathe or ey
00230  65 73 20 63 61 6E 20 73  65 65 2C 0A 53 6F 20 6C  es can see, So l
00240  6F 6E 67 20 6C 69 76 65  73 20 74 68 69 73 2C 20  ong lives this, 
00250  61 6E 64 20 74 68 69 73  20 67 69 76 65 73 20 6C  and this gives l
00260  69 66 65 20 74 6F 20 74  68 65 65 2E              ife to thee.

```



### Command-line options

- As a command-line utility, options and features are controlled by **switches** - additional command-line arguments that activate, deactivate, or specify quantities and limits.

- In Linux, these switches have a format: `-a`, where a letter is preceded by a dash or hyphen.

- In Linux, we can specify multiple switches:

  - ```sh
    dumpfile -a -b -c
    ```

  - These can be bunched together:

    - ```shell
      dumpfile -abc
      ```

  - And some switches can have options:

    ```sh
    dumpfile -q:5
    ```

- We can also take advantage of a handy C library feature: the `getopt()` function. 

  - It helps our program process switches so that we don't have to write the code.



### Using the `getopt()` function

- The `getopt()` function helps our code process command-line switches.

```C
int getopt(int argc, char* const argv[], const char *optstring);
```

- The first two arguments are identical to the `main()` function's `argc` and `*argv[]` arguments.

- The final argument `optstring`, is a list of valid switch characters.

- For example:

  - ```C
    getopt(argc, argv, "abc")
    ```

  - Valid switches here are `-a`, `-b` and `-c`.

  - The function is called repeatedly, each time returning the ASCII code for a valid character (an int value), the character '?' for an unknown option, or -1 when the function has exhausted command-line options.

- The companion `getopt_long()` function handles full word switches.

- Both `getopt()` and `getopt_long()` require that the `unistd.h` header file be included in our code.



In the next listing, shows code as a test before adding the `getopt()` function to our previous `dumpfile` code.

- Global variable `opterr` is set to zero to ensure that `getopt()` doesn't output its own error messages.
- The `getopt()` function itself resides inside a while loop's condition.
- The function's return value is compared with -1, meaning that all command-line arguments have been examined, which stops the loop.
- Otherwise, the value returned in variable `r` is used in a `switch-case` structure to indicate which option is set.
- This setup is how the `getopt()` function is typically implemented.

```C
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>

int main(int argc, char *argv[]){
    int r;
    
    // Suppresses error output from getopt()
    opterr = 0;
    
    // Scans the arguments, repeating the loop until every argument is processed
    while((r = getopt(argc, argv, "abc")) != -1){
        // Examines the character returned
        switch(r){
            case 'a':
            	puts("alfa option set");
            	break;
        	case 'b':
            	puts("bravo option set");
            	break;
        	case 'c':
            	puts("charlie option set");
            	break;
        	case '?':
            	printf("Switche '%c' is 						invalid\n", optopt);
        	default:
            	puts("Unknown option");   
        }
    }
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
chan@CMA:~/C_Programming/test$ ./final -a -b -c
alfa option set
bravo option set
charlie option set

chan@CMA:~/C_Programming/test$ ./final -c -a -b
charlie option set
alfa option set
bravo option set

chan@CMA:~/C_Programming/test$ ./final -cb
charlie option set
bravo option set

chan@CMA:~/C_Programming/test$ ./final -u -a
Switche 'u' is invalid
Unknown option
alfa option set


```

- The `getopt()` function allows us all the flexibility to read options in this manner without having to code the complex comparisons and processing ourselves.
- The next step is too add variables that represent on-off switches for what  the options attempt to accomplish.

```C
int main(int argc, char *argv[])
{
    int r;

    int alfa, bravo, charlie;

    // Each variable is initialized before the getopt() statement in the while loop
    opterr = 0;
    alfa = 0;
    bravo = 0;
    charlie = 0;

    while ((r = getopt(argc, argv, "abc")) != -1)
    {
        // Removes the puts() statement and replace them with statements that set the variables value to 1 (TRUE) for active
        switch (r)
        {
        case 'a':
            alfa = 1;
            break;
        case 'b':
            bravo = 1;
            break;
        case 'c':
            charlie = 1;
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    if (alfa)
        puts("alfa option set");
    if (bravo)
        puts("bravo option set");
    if (charlie)
        puts("charlie option set");
    if (alfa + bravo + charlie == 0)
        puts("No options set");

    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final
No options set
chan@CMA:~/C_Programming/test$ ./final -a -b -c
alfa option set
bravo option set
charlie option set
```

- Because the switches can be examined in this new code, a lack of options is easily identified.
- The remaining variations for the switches have the same output as the original program.
- The difference is that the program is now aware of the settings and can examine the variables to perform whatever magic is requested.



### Updating the `dumpfile` program code

- To add command-line options to a utility, we must know what the options do.

- Then we use a function like `getopt()` to scan for and set the options.

- For the `dumpfile` program, the appropriate suggestions are:

  - `-a` for abbreviated output
  - `-o` for octal output
  - `-h` for help

- The following code checks to see whether the `-h` "help" switch is specified first.

  - If not, the program may attempt to open the file `-h`.

  - So, a quick comparison is made for `-h` as the first argument.

  - If found, the `help()` function is called:

  - ```C
    filename = argv[1];
    
    if(strcmp(filename, "-h") == 0){
        help();
    }
    ```

  - Because the program assumes the first argument is a filename, this step is necessary even if we use the `getopt()` function elsewhere in the code to look for the `-h` switch.



In the next listing for the updated code for `dumpfile` , each of the three valid switches `-a`, `-o` and `-h` are tested for in a while loop.

- To process the rest of the switches, a single `int` variable `options`.
- It is initialized to zero, along with other variables used elsewhere in the main() function.
- For two of the switches, a macro alters the value of variable `options: set_abbr()` for `-a` and `set_oct()` for `-o`. 
- If the help switch is specified, the `help()` function is called where text is output and the program terminates.

#### Setting abbreviated output

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>

extern int options;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
    SIZE = 16, // 16 bytes per line
    ABBR = 1, // Abbreviation status is bit 1.
    OCT = 2, // Octal output status is bit 2.
};

// Uses the bitwise logical OR to set bit 1 (ABBR) in variable options
#define set_abbr() options |= ABBR

// Uses the bitwise logical AND to test bit 1 (ABBR) in variable options
#define test_abbr() ((options & ABBR) == ABBR)

// Uses the bitwise logical OR to set bit 2 (OCT) in variable options
#define set_oct() options |= OCT

// Uses the bitwise logical AND to test bit 2 (OCT) in variable options
#define test_oct() ((options & OCT) == OCT)

void line_out(int offset, int length, unsigned char *data);

void help(void);
#endif
```

- The defined constants `ABBR` and `OCT` represent bit positions in the variable `options` that don't overlap.
- Each bit can be set or examined without changing the other bits.
- The macro `set_abbr()` and `set_oct()` allow the code to modify the variable `options` by setting specific bits.
  - **`set_abbr()`**: Activates the **abbreviated output** mode by setting the `ABBR` flag in the `options` variable.
  - **`set_oct()`**: Activates the **octal output** mode by setting the `OCT` flag in the `options` variable.
  - **`test_abbr()`**: Checks if the **abbreviated output** mode is active by verifying if the `ABBR` flag is set in `options`.
  - **`test_oct()`**: Checks if the **octal output** mode is active by verifying if the `OCT` flag is set in `options`.

`hello.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int options = 0;

void line_out(int offset, int length, unsigned char *data)
{
    int a;
	
    // exectued when the test_abbr() returns zero
    if (!test_abbr())
    {

        printf("%05X ", offset);
    }

    for (a = 0; a < length; a++)
    {
        printf(" %02X", data[a]);

        if ((a + 1) % 8 == 0 && !test_abbr())
        {
            putchar(' ');
        }
    }

    if (length < SIZE)
    {
        for (; a < SIZE; a++)
        {
            printf("   ");
            if ((a + 1) % 8 == 0)
            {
                putchar(' ');
            }
        }
    }

    if (!test_abbr())
    {

        putchar(' ');
        for (a = 0; a < length; a++)
        {
            if (data[a] >= ' ' && data[a] <= '~')
            {
                putchar(data[a]);
            }
            else
            {
                putchar(' ');
            }
        }
    }
    putchar('\n');
}

void help(void)
{
    puts("dumpfile - output a file's raw data");
    puts("Format: dumpfile filename [options]");
    puts("Options:");
    puts("-a abbreviated output");
    puts("-o output octal instead of hex");
    puts("-h display this text");
    exit(1);
}
```

`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int r, ch, offset, index;

    if (argc < 2)
    {
        puts("Format: dumpfile filename [options]");
        exit(1);
    }

    filename = argv[1];

    if (strcmp(filename, "-h") == 0)
    {
        help();
    }

    fp = fopen(filename, "r");

    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }

    offset = index = opterr = options = 0;
	
    // Valid switches are a, o, s and h.
    while ((r = getopt(argc, argv, "aosh")) != -1)
    {
        switch (r)
        {
        case 'a':
            set_abbr();
            break;
        case 'o':
            set_oct();
            break;
        case 'h':
            help();
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    while ((ch = fgetc(fp)) != EOF)
    {
        buffer[index++] = ch;

        if (index == SIZE)
        {
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }

    // Handles remaining bytes after EOF
    if (index > 0)
    {
        line_out(offset, index, buffer);
    }

    fclose(fp);

    return 0;
}
```

- **Variables Initialized:**
  - `offset = 0`: Tracks the current byte position.
  - `index = 0`: Tracks the position within the buffer.
  - `buffer[16]`: Stores 16 bytes from the file.
- **Reading Loop:**
  - The program reads the file **one byte at a time** using `fgetc`.
  - Each byte is stored in `buffer[index]`.
  - When `index` reaches `16`:
    - Calls `line_out(offset, SIZE, buffer)` to process and print the chunk.
    - Updates:
      - `offset += SIZE` → Moves to the next byte position.
      - `index = 0` → Resets the buffer index.
- **End of File:**
  - After reading all bytes, if `index > 0` (last partial chunk), it calls `line_out(offset, index, buffer)` to process remaining bytes.

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt -h
dumpfile - output a file's raw data
Format: dumpfile filename [options]
Options:
-a abbreviated output
-o output octal instead of hex
-h display this text

chan@CMA:~/C_Programming/test$ ./final sonnet18.txt -a
 53 68 61 6C 6C 20 49 20 63 6F 6D 70 61 72 65 20
 74 68 65 65 20 74 6F 20 61 20 73 75 6D 6D 65 72
 27 73 20 64 61 79 3F 0A 54 68 6F 75 20 61 72 74
 20 6D 6F 72 65 20 6C 6F 76 65 6C 79 20 61 6E 64
 20 6D 6F 72 65 20 74 65 6D 70 65 72 61 74 65 3A
 0A 52 6F 75 67 68 20 77 69 6E 64 73 20 64 6F 20
 73 68 61 6B 65 20 74 68 65 20 64 61 72 6C 69 6E
 67 20 62 75 64 73 20 6F 66 20 4D 61 79 2C 0A 41
 6E 64 20 73 75 6D 6D 65 72 27 73 20 6C 65 61 73
 65 20 68 61 74 68 20 61 6C 6C 20 74 6F 6F 20 73
 68 6F 72 74 20 61 20 64 61 74 65 3B 0A 53 6F 6D
 65 74 69 6D 65 20 74 6F 6F 20 68 6F 74 20 74 68
 65 20 65 79 65 20 6F 66 20 68 65 61 76 65 6E 20
 73 68 69 6E 65 73 2C 0A 41 6E 64 20 6F 66 74 65
 6E 20 69 73 20 68 69 73 20 67 6F 6C 64 20 63 6F
 6D 70 6C 65 78 69 6F 6E 20 64 69 6D 6D 27 64 3B
 0A 41 6E 64 20 65 76 65 72 79 20 66 61 69 72 20
 66 72 6F 6D 20 66 61 69 72 20 73 6F 6D 65 74 69
 6D 65 20 64 65 63 6C 69 6E 65 73 2C 0A 42 79 20
 63 68 61 6E 63 65 20 6F 72 20 6E 61 74 75 72 65
 27 73 20 63 68 61 6E 67 69 6E 67 20 63 6F 75 72
 73 65 20 75 6E 74 72 69 6D 6D 27 64 3B 0A 42 75
 74 20 74 68 79 20 65 74 65 72 6E 61 6C 20 73 75
 6D 6D 65 72 20 73 68 61 6C 6C 20 6E 6F 74 20 66
 61 64 65 2C 0A 4E 6F 72 20 6C 6F 73 65 20 70 6F
 73 73 65 73 73 69 6F 6E 20 6F 66 20 74 68 61 74
 20 66 61 69 72 20 74 68 6F 75 20 6F 77 27 73 74
 3B 0A 4E 6F 72 20 73 68 61 6C 6C 20 64 65 61 74
 68 20 62 72 61 67 20 74 68 6F 75 20 77 61 6E 64
 65 72 27 73 74 20 69 6E 20 68 69 73 20 73 68 61
 64 65 2C 0A 57 68 65 6E 20 69 6E 20 65 74 65 72
 6E 61 6C 20 6C 69 6E 65 73 20 74 6F 20 74 69 6D
 65 20 74 68 6F 75 20 67 72 6F 77 27 73 74 3A 0A
 53 6F 20 6C 6F 6E 67 20 61 73 20 6D 65 6E 20 63
 61 6E 20 62 72 65 61 74 68 65 20 6F 72 20 65 79
 65 73 20 63 61 6E 20 73 65 65 2C 0A 53 6F 20 6C
 6F 6E 67 20 6C 69 76 65 73 20 74 68 69 73 2C 20
 61 6E 64 20 74 68 69 73 20 67 69 76 65 73 20 6C
 69 66 65 20 74 6F 20 74 68 65 65 2E    
```

**Macro Execution:**

- `-a` Switch Detected:

  - The program calls the macro `set_abbr()`.

  - Macro Definition (`hello.h`):

    ```C
    #define set_abbr() options |= ABBR
    ```

  - Effect:

    - Sets the `ABBR` flag in the `options` variable.
    - **`options` Before:** `0000` (binary)
    - **`ABBR` Value:** `0001` (binary)
    - **`options` After:** `0001` (binary)

**Macro Checks:**

- **`test_abbr()` Macro (`hello.h`):**

- ```C
  #define test_abbr() ((options & ABBR) == ABBR)
  ```

- **Result:** Returns `true` since `ABBR` flag is set.

- ```C
  if (!test_abbr())
  {
      printf("%05X ", offset);
  }
  ```

- Since `test_abbr()` is `true`:

  - Offset (`%05X`) and ASCII Representation are not printed.

- **Hexadecimal Printing:**

  - Iterates through each byte in `buffer` and prints its hexadecimal value.

  - Extra Space After 8 Bytes:

    ```C
    if ((a + 1) % 8 == 0 && !test_abbr())
    
    {
    
      putchar(' ');
    
    }
    ```

  - Since `test_abbr()` is `true`:

    - **No extra space added.**



#### Activating octal output

- To specify octal, we use the zero prefix: `01` is octal 1, `010` is octal 10 (decimal 8), and so on.

- The `printf()` and `scanf()` placeholder for octal values is `%o`.

- Like other placeholders, it features width values and zero-padding.

- Three changes are required to activate the `-o` switch.

  1. When the octal switch is active, the first column needs to output octal values instead of hex. The decision is in addition to whether the column is output when `test_abbr()` macro is true (or false).

     ```C
     if(!test_abbr()){
         if(test_oct()){
             printf("%05o ", offset);
         }else{
             printf("%05X ", offset);
         }
     }
     ```

     - The `%05o` placeholder outputs the value of variable offset as an octal number five digits wide with zeros padded on the left.

  2. The next change takes place in the `for` loop that outputs the bytes.

     - When the `test_oct()` macro returns TRUE, octal values are output instead of decimal:

     ```C
     if(test_oct()){
         printf(" %03o", data[a]);
     }else{
         printf(" %02X", data[a]);
     }
     ```

     - The placeholder `%03o` outputs an octal value three digits wide with zeros padded on the left.

  3. The final change is made when the last line of output is shorter than 16 bytes. 

     - Because the octal values are output three characters wide instead of two, four spaces are needed for each missing byte to line up the ASCII column.

     ```C
     if(test_oct()){
         printf("    ");
     }else{
         printf("   ");
     }
     ```

     

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>

extern int options;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
    SIZE = 16,
    ABBR = 1,
    OCT = 2,
};

#define set_abbr() options |= ABBR
#define test_abbr() ((options & ABBR) == ABBR)
#define set_oct() options |= OCT
#define test_oct() ((options & OCT) == OCT)

void line_out(int offset, int length, unsigned char *data);

void help(void);
#endif
```

`hello.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int options = 0;

void line_out(int offset, int length, unsigned char *data)
{
    int a;

    if (!test_abbr())
    {
        if (test_oct())
        {
            printf("%05o ", offset);
        }
        else
        {

            printf("%05X ", offset);
        }
    }

    for (a = 0; a < length; a++)
    {
        if (test_oct())
        {
            printf(" %03o", data[a]);
        }
        else
        {

            printf(" %02X", data[a]);
        }

        if ((a + 1) % 8 == 0 && !test_abbr())
        {
            putchar(' ');
        }
    }

    if (length < SIZE)
    {
        for (; a < SIZE; a++)
        {
            if (test_oct())
            {
                printf("    ");
            }
            else
            {

                printf("   ");
            }
            if ((a + 1) % 8 == 0)
            {
                putchar(' ');
            }
        }
    }

    if (!test_abbr())
    {

        putchar(' ');
        for (a = 0; a < length; a++)
        {
            if (data[a] >= ' ' && data[a] <= '~')
            {
                putchar(data[a]);
            }
            else
            {
                putchar(' ');
            }
        }
    }
    putchar('\n');
}

void help(void)
{
    puts("dumpfile - output a file's raw data");
    puts("Format: dumpfile filename [options]");
    puts("Options:");
    puts("-a abbreviated output");
    puts("-o output octal instead of hex");
    puts("-h display this text");
    exit(1);
}
```

`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int r, ch, offset, index;

    if (argc < 2)
    {
        puts("Format: dumpfile filename [options]");
        exit(1);
    }

    filename = argv[1];

    if (strcmp(filename, "-h") == 0)
    {
        help();
    }

    fp = fopen(filename, "r");

    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }

    offset = index = opterr = options = 0;

    while ((r = getopt(argc, argv, "aoh")) != -1)
    {
        switch (r)
        {
        case 'a':
            set_abbr();
            break;
        case 'o':
            set_oct();
            break;
        case 'h':
            help();
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    while ((ch = fgetc(fp)) != EOF)
    {
        buffer[index++] = ch;

        if (index == SIZE)
        {
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }

    // Handles remaining bytes after EOF
    if (index > 0)
    {
        line_out(offset, index, buffer);
    }

    fclose(fp);

    return 0;
}
```



`Output`

![Screenshot from 2024-11-18 19-40-21](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-18 19-40-21.png)

**Exercise 9.5**

How about adding one more switch to the dumpfile program? The `-v` switch is commonly used to output the program’s version number. I would recommend setting these values as defined constants: separate major and minor version numbers, or a complete version number string. Add both the -v switch as well as the code (the version() function) to output the
version number. The program can quit after performing this task. And remember that
some users may use the -v switch as the program’s only argument.

**Solution**

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>

extern int options;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
    SIZE = 16,
    ABBR = 1,
    OCT = 2,
    VERSION_MAJOR = 1,
    VERSION_MINOR = 0,
};

#define set_abbr() options |= ABBR
#define test_abbr() ((options & ABBR) == ABBR)
#define set_oct() options |= OCT
#define test_oct() ((options & OCT) == OCT)

void line_out(int offset, int length, unsigned char *data);

void help(void);

void version(void);
#endif
```

`hello.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int options = 0;

void line_out(int offset, int length, unsigned char *data)
{
    int a;

    if (!test_abbr())
    {
        if (test_oct())
        {
            printf("%05o ", offset);
        }
        else
        {

            printf("%05X ", offset);
        }
    }

    for (a = 0; a < length; a++)
    {
        if (test_oct())
        {
            printf(" %03o", data[a]);
        }
        else
        {

            printf(" %02X", data[a]);
        }

        if ((a + 1) % 8 == 0 && !test_abbr())
        {
            putchar(' ');
        }
    }

    if (length < SIZE)
    {
        for (; a < SIZE; a++)
        {
            if (test_oct())
            {
                printf("    ");
            }
            else
            {

                printf("   ");
            }
            if ((a + 1) % 8 == 0)
            {
                putchar(' ');
            }
        }
    }

    if (!test_abbr())
    {

        putchar(' ');
        for (a = 0; a < length; a++)
        {
            if (data[a] >= ' ' && data[a] <= '~')
            {
                putchar(data[a]);
            }
            else
            {
                putchar(' ');
            }
        }
    }
    putchar('\n');
}

void help(void)
{
    puts("dumpfile - output a file's raw data");
    puts("Format: dumpfile filename [options]");
    puts("Options:");
    puts("-a abbreviated output");
    puts("-o output octal instead of hex");
    puts("-h display this text");
    exit(1);
}

void version(void){
    printf("DumpFile Utility Version %d.%d\n", VERSION_MAJOR, VERSION_MINOR);
    exit(1);
}
```

`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int r, ch, offset, index;

    if (argc < 2)
    {
        puts("Format: dumpfile filename [options]");
        exit(1);
    }

    filename = argv[1];

    if (strcmp(filename, "-h") == 0)
    {
        help();
    }

    fp = fopen(filename, "r");

    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }

    offset = index = opterr = options = 0;

    while ((r = getopt(argc, argv, "aohv")) != -1)
    {
        switch (r)
        {
        case 'a':
            set_abbr();
            break;
        case 'o':
            set_oct();
            break;
        case 'h':
            help();
            break;
        case 'v':
            version();
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    while ((ch = fgetc(fp)) != EOF)
    {
        buffer[index++] = ch;

        if (index == SIZE)
        {
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }

    // Handles remaining bytes after EOF
    if (index > 0)
    {
        line_out(offset, index, buffer);
    }

    fclose(fp);

    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt -v
DumpFile Utility Version 1.0
```

