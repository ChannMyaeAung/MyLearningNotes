# Tiny C Projects

- I have decided to put all the contents and projects from the book called "Tiny C Projects" written by Dan Gookin to later review and revise what I have learnt from the book as well as related information or improvements from external sources.
- We are going to be building upon the program's idea, often presenting a simple version and then expanding the program to offer more features.
- Sometimes other programs are introduced along the way, each of which follows the main theme or otherwise assists the primary program in its goal.

---

## 1. Daily greetings

### Instructions

- Write a simple greetings program.
- Modify your grettings program to add the time of day.
- Update the timestamp with the current moon phase.
- Enhance your grettings message with a `bon mot`.

### Solution 

#### Things to Keep in mind

- The C library is rife with time functions, all defined in the `time.h` header file.
- The `time_t` data type is also defined in the header.
- This positive integer value (long data type, `printf()` placeholder `%ld`) stores the Unix epoch, the number of seconds ticking away since midnight January 1, 1970.
- The Unix epoch is a great value to use in our grettings program.
- However, the `time_t` value must be manipulated into something a bit more useful.
- Be aware that many time functions, such as `time()` and `ctime()` used in the code for our program solution require the address of the `time_t` variable. 
- Yup, they are pointers.

```C
int main(){
    time_t now;
    
    // The time() function requires the time_t variable's address, prefixed here with the & address-of operator.
    time(&now);
    printf("The computer think it's %ld\n", now);
    
    // The ctime() function requires a pointer argument and returns a string appended with a newline.
    printf("%s", ctime(&now));
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
The computer thinks it's 1726504705
Tue Sep 17 00:38:25 2024
```

- The output shows the number of seconds tick-tocking since 1970.
- This same value is swallowed by the `ctime()` function to output a formatted time string.
- This result may be acceptable, but time data can be customized further.
- The key to unlocking specific time details is found in the `localtime()` function, as the following code here demonstrates.

```C
int main()
{
    time_t now;
    
    // because localtime() returns a pointer, it's best to declare the structure as a pointer
    struct tm *clock;
    time(&now);

    clock = localtime(&now);
    puts("Time details: ");
    printf("Day of the year: %d\n", clock->tm_year);
    
    // The first day of the week is 0 for Sunday
    printf("Day of the week: %d\n", clock->tm_wday);
    
    // We must add 1900 to the tm_year member to get the current year
    printf("Year %d\n", clock->tm_year + 1900);
    
    // The tm_mon member ranges from 0 to 11
    printf("Month: %d\n", clock->tm_mon + 1);
    printf("Day of the month: %d\n", clock->tm_mday);
    printf("Hour: %d\n", clock->tm_hour);
    printf("Minutes: %d\n", clock->tm_min);
    printf("Seconds: %d\n", clock->tm_sec);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Time details: 
Day of the year: 124
Day of the week: 2
Year 2024
Month: 9
Day of the month: 17
Hour: 0
Minutes: 46
Seconds: 7
```

- Based on the output, we can conclude that my machine at the time of practicing this is:
  - It's 124 day of the year 2024. 
  - It's Tuesday (as Day of the week is 2)
  - The month is September (Month: 9)
  - Hour, Minutes, Seconds (12:46:07 AM)
  - **Conclusion:** It is written at 12 AM midnight, on September 17th 2024, Tuesday.



**The code fetches the current hour of the day and outputs an appropriate time-of-day greeting**

```C
int main(int argc, char *argv[]){
    time_t now;
    struct tm *clock;
    int hour;
    
    time(&now);
    clock = localtime(&now);
    
    // This statement is a convenience to avoid using clock->tm_hour over and over
    hour = clock->tm_hour;
    
    printf("Good ");
    if(hour < 12){
        printf("morning");
    }else if(hour > 12){
        printf("afternoon");
    }else{
        printf("evening");
    }
    
    if(argc > 1){
        printf(", %s", argv[1]);
    }
    
    putchar('\n');
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Good morning
chan@CMA:~/C_Programming/test$ ./final Chan
Good morning, Chan
```



#### Adding specific time info

- A simple way to output a detailed time string is to output a greeting followed by a time string generated by the `ctime()` function.

```C
printf("Good day, %s\n", argv[1]);
printf("It's %s", ctime(&now));
```

- Still the program is lazy. Better to incorporate the `strftime()` function, which formats a timestamp string according to our specifications.
- The `strftime()` function works like `printf()`, with a special string that formats time information.
- The function's output is saved in a buffer, which our code can use later.

```C
int main(int argc, char *argv[]){
    time_t now;
    struct tm *clock;
    
    // Storage for the string filled by the strftime() function
    char time_string[64];
    
    time(&now);
    
    // We must fill a localtime() tm structure to make the strftime() function work
    clock = localtime(&now);
    
    strftime(time_string, 64, "Today is %A, %B %d, %Y%nIt is %r%n", clock);
    
    printf("Greetings");
    if(argc > 1){
        printf(", %s", argv[1]);
    }
    
    printf("!\n%s", time_string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final Chan
Greetings, Chan!
Today is Tuesday, September 17, 2024
It is 02:15:40 AM
chan@CMA:~/C_Programming/test$ ./final
Greetings!
Today is Tuesday, September 17, 2024
It is 02:15:44 AM
```

- `man strftime` in terminal to discover all the fun placeholders and what they do.
- Like the `printf()` function, the placeholders are prefixed by a % character.
- Any other text in the formatting string is output as is.
- `%A` - Full name for the current day of the week.
- `%B` - Full name for the current month.
- `%d` - Day of the month, 01 to 31.
- `%Y` - 4-digit year
- `%n` - Newline
- `%r` - Time with AM/PM
- The output reflects the time string generated and stored in the `time_string[]` buffer.
- The time string appears after the general greeting.



#### Writing the moon phase algorithm

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-09-19 01-33-14.png)

- Regardless of the time, the moon has a current phase.
- To determine the moon phase without looking outside or in a reference, we use an algorithm.
- The degree of accuracy of the algorithm depends on a lot of things such as our location.

```C
int moon_phase(int year, int month, int day)
{
    int d, g, e;

    d = day;
    if (month == 2)
    {
        d += 31;
    }
    else if (month > 2)
    {
        d += 59 + (month - 3) * 30.6 + 0.5;
    }

    g = (year - 1900) % 19;
    e = (11 * g + 29) % 30;

    if (e == 25 || e == 24)
    {
        ++e;
    }

    return ((((e + d) * 6 + 5) % 177) / 22 & 7);
}
```

##### Function Definition

```C
int moon_phase(int year, int month, int day)
```

- **Purpose**: This function calculates the moon phase for a given date.
- Parameters:
  - `year`: The year of the date.
  - `month`: The month of the date.
  - `day`: The day of the date.
- **Return Value**: An integer representing the moon phase.

##### Variable Declarations

int d, g, e;

- **d**: This variable will hold the day of the year.
- **g**: This variable will hold the golden number of the year in the Metonic cycle.
- **e**: This variable will hold an intermediate calculation used to determine the moon phase.

### Calculate Day of the Year

```C
d = day;
if (month == 2)
{
    d += 31;
}
else if (month > 2)
{
    d += 59 + (month - 3) * 30.6 + 0.5;
}
```

- **d = day**: Initialize `d` with the day of the month.
- **if (month == 2)**: If the month is February, add 31 to `d` to account for the days in January.
- **else if (month > 2):** If the month is after February:
  - **d += 59 + (month - 3) \* 30.6 + 0.5**: Add 59 to `d` to account for the days in January and February. Then, add the number of days in the months from March to the given month. The expression `(month - 3) * 30.6 + 0.5` approximates the number of days in these months.

##### Calculate Golden Number and Epact

```C
g = (year - 1900) % 19;
e = (11 * g + 29) % 30;
```

- **g = (year - 1900) % 19**: Calculate the golden number of the year in the Metonic cycle. The Metonic cycle is a period of 19 years after which the phases of the moon repeat on the same days of the year.
- **e = (11 \* g + 29) % 30**: Calculate the epact, which is the age of the moon in days on January 1st of the given year.

##### Adjust Epact for Special Cases

```C
if (e == 25 || e == 24)
{
    ++e;
}
```

- **if (e == 25 || e == 24)**: If the epact is 24 or 25, increment it by 1. This adjustment is made to correct the epact for certain years.

##### Calculate Moon Phase

```C
return ((((e + d) * 6 + 5) % 177) / 22 & 7);
```

- **(e + d)**: Add the epact to the day of the year.
- **(e + d) \* 6 + 5**: Multiply the sum by 6 and add 5. This scales the value to fit within a certain range.
- **((e + d) \* 6 + 5) % 177**: Take the result modulo 177 to wrap the value within a specific range.
- **(((e + d) \* 6 + 5) % 177) / 22**: Divide the result by 22 to get a value between 0 and 7.
- **(((e + d) \* 6 + 5) % 177) / 22 & 7**: Use bitwise AND with 7 to ensure the result is within the range 0 to 7, representing the moon phase.

##### Summary

- **0**: New Moon
- **1**: Waxing Crescent
- **2**: First Quarter
- **3**: Waxing Gibbous
- **4**: Full Moon
- **5**: Waning Gibbous
- **6**: Last Quarter
- **7**: Waning Crescent

This function uses a combination of calendar calculations and lunar cycle approximations to determine the moon phase for a given date.



#### Adding the moon phase to our greeting program

- We need to fetch time-based data, which the `moon_phase()` function requires to make its calculation.
- We also need an array of strings to output the current moon phase text based on the value the function returns.

```C
int mp;
```

- Variable `mp` to hold the value returned from the `moon_phase()` function.

`hello.h`

```C
int moon_phase(int year, int month, int day);
```

`hello.c`

```C
int moon_phase(int year, int month, int day)
{
    int d, g, e;

    d = day;
    if (month == 2)
    {
        d += 31;
    }
    else if (month > 2)
    {
        d += 59 + (month - 3) * 30.6 + 0.5;
    }

    g = (year - 1900) % 19;
    e = (11 * g + 29) % 30;

    if (e == 25 || e == 24)
    {
        ++e;
    }

    return ((((e + d) * 6 + 5) % 177) / 22 & 7);
}
```



`main.c`

```C

char *phase[8] = {
    "waxing crescent", "at first quarter", "waxing gibbous", "full", "waning gibbous", "at last quarter", "waning crescent", "new"};

int main(int argc, char *argv[])
{
    time_t now;
    struct tm *clock;
    int mp;

    char time_string[64];

    time(&now);
    clock = localtime(&now);

    mp = moon_phase(clock->tm_year + 1900, clock->tm_mon, clock->tm_mday);

    strftime(time_string, 64, "Today is %A, %B %d, %Y%nIt is %r%n", clock);

    printf("Greetings");
    if (argc > 1)
    {
        printf(", %s", argv[1]);
    }

    printf("!\n%s", time_string);
    
    printf("The moon is %s\n", phase[mp]);
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
Greetings!
Today is Thursday, September 19, 2024
It is 01:56:15 AM
The moon is waning gibbous
```



#### Randomly reading a pithy phrase

`pitchy.txt`

```
Politics exists so that uncoordinated people can play sports.
Water alone doesn't get you clean. You must use soap. That's because dirt and crud loves soap and sticks to it really well. The water then washes away the soap, along with the dirt, and the result is that you are clean.
You buy popcorn, soda, and candy so that you have something to eat before the movie starts.
Just wait until Starbucks figures out that you can snort coffee.
Nothing instills more doubt in the curious than the sign "Wet Paint."
You might dislike texting, but it certainly does get annoying people to shut up.
You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"
The middle of nowhere is equidistant from everywhere else.
Marketing wizards are looking for the human equivalent of what a dog feels at the sound of a can opener.
Having a pet ensures that you don't freak out over every noise in the house. Loud bang? It's the cat. So what if the cat is in the room with me. It's the cat.
The true experience at an amusement park is waiting in lines.
There is no logic in the computer industry.
The car's manual calls it the "check engine" lamp, but I call it the "This is going to cost at least $200" light.
You drive on a parkway and park on a driveway.
Do I take a break from work to play a video game, or take a break from a video game to get work done?
```

- In C, `feof` is a function that checks whether the end-of-file indicator associated with a given file stream is set. It is defined in the `<stdio.h>` header file.
- The `feof` function returns a non-zero value (true) if the end-of-file indicator is set for the specified stream.
- It returns zero (false) otherwise.
- The `feof` function is typically used in a loop to determine when the end of a file has been reached while reading from the file. 
- However, it is important to note that `feof` only returns true after an attempt to read past the end of the file has been made. Therefore, it is often used in conjunction with other file reading functions like `fgets`, `fscanf`, or `fread`.

```C
int main()
{
    const char filename[] = "pithy.txt";
    FILE *fp;

    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }

    // Loop as long as the file isn't empty
    while (!feof(fp))
    {
        // The variable r ensures that fgets() doesn't mess up and read beyond the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);

        if (r == NULL)
        {
            break;
        }

        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);

        if (entry == NULL)
        {
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }

        strcpy(entry, buffer);
        printf("%d: %s\n", items, entry);
        items++;
        // Outputs all the lines in the file
    }

    fclose(fp);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
0: Politics exists so that uncoordinated people can play sports.

1: Water alone doesn't get you clean. You must use soap. That's because dirt and crud loves soap and sticks to it really well. The water then washes away the soap, along with the dirt, and the result is that you are clean.

2: You buy popcorn, soda, and candy so that you have something to eat before the movie starts.

3: Just wait until Starbucks figures out that you can snort coffee.

4: Nothing instills more doubt in the curious than the sign "Wet Paint."

5: You might dislike texting, but it certainly does get annoying people to shut up.

6: You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"

7: The middle of nowhere is equidistant from everywhere else.

8: Marketing wizards are looking for the human equivalent of what a dog feels at the sound of a can opener.

9: Having a pet ensures that you don't freak out over every noise in the house. Loud bang? It's the cat. So what if the cat is in the room with me. It's the cat.

10: The true experience at an amusement park is waiting in lines.

11: There is no logic in the computer industry.

12: The car's manual calls it the "check engine" lamp, but I call it the "This is going to cost at least $200" light.

13: You drive on a parkway and park on a driveway.

14: Do I take a break from work to play a video game, or take a break from a video game to get work done?

```



- As the program sits now, it allocates a series of buffers to store the strings read.
- Yet the addresses for these buffers are lost in memory.
- To resolve this issue, a pointer-pointer is required.
- The pointer-pointer, or address of a pointer, keeps track of all the string's memory locations.

```C
#define BSIZE 256

int main(){
    const char filename[] = "pithy.txt";
    FILE *fp;
    
    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;
    int saying;
    char **list_base;
    
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }
    
    list_base = (char **)malloc(sizeof(char *) * 100);
    
    if(list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Loop as long as the file isn't empty
    while(!feof(fp)){
        // The variable r ensures that fgets() doesn't mess up and read beyong the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);
        
        if(r == NULL){
            break;
        }
        
        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);
        
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        // Copy the string from the buffer into the newly allocated memory pointed to by entry
        strcpy(entry, buffer);
        
        // Stores the pointer entry in the array list_base at the position indicated by items.
        // same as list_base[items] = entry;
        *(list_base + items) = entry;
        item++;
        
        // Every time items is exactly divisible by 100
        // means the file read contains more than 100 lines of text, reallocate memory to prevent memory overflow
        if(items % 100 == 0){
            // Existing storage is increased by 100 pointer-size chunks.
            lisst_base = (char **)realloc(list_base, sizeof(char *) * (items + 100));
            if(list_base == NULL){
                fprintf(stderr, "Unable to reallocate memory\n");
                exit(1);
            }
        }
    }
    
    fclose(fp);
    
    // Output a random line of text
    srand((unsigned)time(NULL));
    saying = rand() % (items - 1);
    printf("%s", *(list_base + saying));
}
```

1. **Line 67: `*(list_base + items) = entry;`**
   - **Purpose**: This line stores the pointer `entry` in the array `list_base` at the position indicated by `items`.
   - **Details:**
     - `list_base` is a pointer to an array of character pointers (`char **`), which is used to store the lines read from the file.
     - `items` is an integer that keeps track of the number of lines read so far.
     - `*(list_base + items)` is equivalent to `list_base[items]`, which accesses the `items`-th element of the array.
     - This line effectively stores the pointer to the copied string in the `items`-th position of `list_base`.
2. **Line 68: `items++;`**
   - **Purpose**: This line increments the `items` counter by 1.
   - **Details:**
     - After storing the pointer to the copied string in `list_base`, the `items` counter is incremented to reflect that another line has been read and stored.
     - This ensures that the next line read from the file will be stored in the next position in the `list_base` array.

Summary

- **Line 66** copies the content of the `buffer` into the newly allocated memory pointed to by `entry`.
- **Line 67** stores the pointer to the copied string in the `list_base` array at the position indicated by `items`.
- **Line 68** increments the `items` counter to keep track of the number of lines read and stored.

#### Purpose of `strcpy(entry, buffer)`

- **Function**: Copies the string from `buffer` to the memory location pointed to by `entry`.
- **Reason**: `entry` is a newly allocated memory block that will hold the string read from the file.

#### Purpose of `*(list_base + items) = entry`

- **Function**: Stores the pointer `entry` in the array `list_base` at the position indicated by `items`.
- **Reason**: `list_base` is an array of pointers (`char **`) that keeps track of all the lines read from the file. By storing `entry` in `list_base`, you are effectively saving the location of the copied string so that you can access it later.

#### Why Both are Needed

1. **Copying the String**: `strcpy(entry, buffer)` ensures that the content of the buffer is copied to a new memory location (`entry`). This is necessary because `buffer` will be reused in the next iteration of the loop to read the next line from the file.
2. **Storing the Pointer**: `*(list_base + items) = entry` (or equivalently `list_base[items] = entry`) stores the pointer to the newly copied string in the `list_base` array. This allows you to keep track of all the lines read from the file. Without this step, you would lose the reference to the copied string, and it would be impossible to access it later.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Nothing instills more doubt in the curious than the sign "Wet Paint."

chan@CMA:~/C_Programming/practice$ ./practice
You might dislike texting, but it certainly does get annoying people to shut up.

chan@CMA:~/C_Programming/practice$ ./practice
You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"
```

### Important Note regarding the pithy program

- The program doesn't release any memory directly. 
- Normally, the end of a function would be dotted with `free()` statements, one for each memory chunk allocated.
- Because the entire code dwells within the `main()` function, freeing memory isn't necessary.
- The memory allocated is freed when the program quits.
- Had the allocation taken place in a function, however, it's necessary to release the allocation or risk losing the memory chunk and potentially causing a memory overflow.
- However, we should always explicitly free the memory allocated in our program even if it is in the `main` function.
- While the operating system will reclaim the memory when the program exits, it is good practice to free all dynamically allocated memory to avoid memory leaks and to ensure that your program is well-behaved, especially in more complex applications where memory management is critical.

```C
#define BSIZE 256

int main()
{
    const char filename[] = "pithy.txt";
    FILE *fp;

    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;
    int saying;
    char **list_base;

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }

    list_base = (char **)malloc(sizeof(char *) * 100);

    if (list_base == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    // Loop as long as the file isn't empty
    while (!feof(fp))
    {
        // The variable r ensures that fgets() doesn't mess up and read beyond the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);

        if (r == NULL)
        {
            break;
        }

        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);

        if (entry == NULL)
        {
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }

        // Copy the string from the buffer into the newly allocated memory pointed to by entry
        strcpy(entry, buffer);

        // Stores the pointer entry in the array list_base at the position indicated by items.
        *(list_base + items) = entry;
        items++;

        // Every time items is exactly divisible by 100
        // means the file read contains more than 100 lines of text, reallocate memory to prevent memory overflow
        if (items % 100 == 0)
        {
            // Existing storage is increased by 100 pointer-size chunks.
            list_base = (char **)realloc(list_base, sizeof(char *) * (items + 100));

            if (list_base == NULL)
            {
                fprintf(stderr, "Unable to reallocate memory\n");
                exit(1);
            }
        }
    }
    fclose(fp);

    // Outputs a random line of text
    srand((unsigned)time(NULL));
    saying = rand() % (items - 1);
    printf("%s", *(list_base + saying));

    // Free the allocated memory
    for (int i = 0; i < items; i++)
    {
        free(list_base[i]);
    }

    free(list_base);
    return 0;
}
```



### Similar Small Program

```C
int main(){
    char *buffer = "Hello, World!";
    char *entry = (char*)malloc(strlen(buffer) + 1);
    // Outline: For each string in buffers, memory is allocated, the string is copied, and the pointer is stored in list_base.
    strcpy(entry, buffer);
    
    
    // Now entry points to a memory location containing "Hello, World!"
    // But we need to store this pointer somewhere to access it later
    char **list_base = (char**)malloc(10 * sizeof(char *));
    int items = 0;
    
    list_base[items] = entry; // Store the pointer in the array
    
    items++;
    
    printf("%s", list_base[0]); // Prints "Hello, World!"
    printf("%s", list_base[items]); // Prints (null)
    
    // Free allocated memory
    // We don't need a loop to free the memory like the pithy program because we are only allocating and storing a single string.
    free(entry);
    free(list_base);
    return 0;
}
```

##### Explanation

1. **Initialization**:
   - `buffer` is initialized to `"Hello, World!"`.
   - `entry` is allocated enough memory to hold the string in `buffer` plus the null terminator.
   - `strcpy(entry, buffer)` copies the string from `buffer` to `entry`.
2. **Array Allocation**:
   - `list_base` is allocated memory for 10 pointers to `char`.
   - `items` is initialized to 0.
3. **Storing the Pointer**:
   - `list_base[items] = entry;` stores the pointer `entry` in `list_base[0]`.
   - `items` is incremented to 1.
4. **Printing**:
   - `printf("%s", list_base[0]);` prints the string pointed to by `list_base[0]`, which is `"Hello, World!"`.
   - `printf("%s", list_base[items]);` prints the string pointed to by `list_base[1]`, which is `NULL` because `list_base[1]` has not been initialized.

##### Why `list_base[items]` is `NULL`

- After `items` is incremented to 1, `list_base[1]` is not assigned any value. Therefore, it contains `NULL` or an undefined value.
- When you try to print `list_base[1]`, it prints `(null)` because it points to `NULL`.

##### Important Notes

If we have multiple strings like we did in the pithy program, the `list_base[items] = entry;` would be like this:

let's say our entry will have the following strings:

"Hello, World!", "John Doe", the last item is "Prince Ali"

`n` here means the last element of entry.

| list_base[0] (items = 0) | list_base[1] (items = 1) | list_base[n] (items  = n) |
| ------------------------ | ------------------------ | ------------------------- |
| memory chunk [0]         | memory chunk [1]         | memory chunk [n]          |
| "Hello, World!"          | "John Doe"               | "Prince Ali"              |
|                          |                          |                           |



###### Memory Layout

| Index (`items`) | `list_base` Pointer              | Memory Chunk Content |
| --------------- | -------------------------------- | -------------------- |
| 0               | `list_base[0]`                   | "Hello, World!"      |
| 1               | `list_base[1]`                   | "John Doe"           |
| 2               | `list_base[2]` or `list_base[n]` | "Prince Ali"         |



---

## 2. NATO output

```C
const char *nato[] = {
    "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"
};
```

- The array's notation, `*nato[]` , implies an array of pointers, which is how the compiler builds this construction in memory.
- The array's data type is `char`, so the pointers reference character arrays - strings - stored in memory.
- The `nato[]` array is filled with the memory locations of the strings as illustrated below.

Figure: How an array of pointers references strings as they sit in memory

```
char *nato[] = {
	0x404020, 0x404025, 0x40402b, 
	...
	0x4040b8, 0x4040bf
}
```

```
What the array stores

Addresses		Strings in memory
0x404020 --> "A" "l" "f" "a" "\0"
0x404025 --> "B" "r" "a" "v" "o" "\0"
0x40402b --> "C" "h" "a" "r" "l" "i" "e" "\0"
...
0x4040b8 --> "Y" "a" "n" "k" "e" "e" "\0"
0x4040bf --> "Z" "u" "l" "u" "\0"
```

- The string `Alfa` (terminated with a null character, `\0`) is stored at address `0x404020`.
- This memory location is stored in the `nato[]` array, not the string itself.
- Yes, the string appears in the array's declaration, but it is stored elsewhere in memory at runtime.

### Nato Translator Program

```C
#include <stdio.h>
#include <ctype.h>
int main()
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    char phrase[64];
    char ch;
    int i = 0;

    printf("Enter a word or phrase: ");

    // stores into location phrase 63 characters + null character from stdin, standard input.
    fgets(phrase, 64, stdin);

    // Loop until the null character is found in the string
    while (phrase[i])
    {
        ch = toupper(phrase[i]);

        // True when character ch is alphabetic
        if (isalpha(ch))
        {

            // ch-'A' transforms the letters to values 0 through 25, matching the corresponding array element.
            printf("%s ", nato[ch - 'A']);
        }
        i++;
        if (i == 64)
        {
            break;
        }
    }

    putchar('\n');
    return 0;
}
```

- Any alphabetic characters are detected by the `isalpha()` function.

- If found, the letter is used as a reference into the `nato[]` array.

- ```C
  nato[ch - 'A']
  ```

  - `ch - 'A'` calculates the index for the `nato` array.
  - For example, if `ch` is 'A', then `ch - 'A'` is `0`, so `nato[0]` is "Alfa".
  - If `ch` is 'B', then `ch - 'A'` is `1`, so `nato[1]` is "Bravo".
  - This works because the ASCII value of 'A' is 65, 'B' is 66, and so on. Subtracting 'A' (65) from any uppercase letter gives a zero-based index corresponding to that letter.
  - Let's say the input is "ABZ":
    - **First Character ('A')**:
      - `toupper('A')` is 'A'.
      - `isalpha('A')` is true.
      - `ch - 'A'` is `0`.
      - `nato[0]` is "Alfa".
      - Output: "Alfa".
    - **Second Character ('B')**:
      - `toupper('B')` is 'B'.
      - `isalpha('B')` is true.
      - `ch - 'A'` is `1`.
      - `nato[1]` is "Bravo".
      - Output: "Bravo".
    - **Third Character ('Z')**:
      - `toupper('Z')` is 'Z'.
      - `isalpha('Z')` is true.
      - `ch - 'A'` is `25`.
      - `nato[25]` is "Zulu".
      - Output: "Zulu".

**So, if we say "Howdy"**

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word or phrase: Howdy
Hotel Oscar Whiskey Delta Yankee 
```

- This basically means H for "Hotel", o for "Oscar", w for "Whiskey", d for "Delta", and y for "Yankee".
- **First Character ('H')**:
  - `toupper('H')` is 'H'.
  - `isalpha('H')` is true.
  - `ch - 'A'` is `7` (ASCII value of 'H' is 72, 'A' is 65, so 72 - 65 = 7).
  - `nato[7]` is "Hotel".
  - Output: "Hotel ".
- **Second Character ('o')**:
  - `toupper('o')` is 'O'.
  - `isalpha('O')` is true.
  - `ch - 'A'` is `14` (ASCII value of 'O' is 79, 'A' is 65, so 79 - 65 = 14).
  - `nato[14]` is "Oscar".
  - Output: "Oscar ".
- **Third Character ('w')**:
  - `toupper('w')` is 'W'.
  - `isalpha('W')` is true.
  - `ch - 'A'` is `22` (ASCII value of 'W' is 87, 'A' is 65, so 87 - 65 = 22).
  - `nato[22]` is "Whiskey".
  - Output: "Whiskey ".
- **Fourth Character ('d')**:
  - `toupper('d')` is 'D'.
  - `isalpha('D')` is true.
  - `ch - 'A'` is `3` (ASCII value of 'D' is 68, 'A' is 65, so 68 - 65 = 3).
  - `nato[3]` is "Delta".
  - Output: "Delta ".
- **Fifth Character ('y')**:
  - `toupper('y')` is 'Y'.
  - `isalpha('Y')` is true.
  - `ch - 'A'` is `24` (ASCII value of 'Y' is 89, 'A' is 65, so 89 - 65 = 24).
  - `nato[24]` is "Yankee".
  - Output: "Yankee ".
- **Sixth Character ('\n')**:
  - `toupper('\n')` is '\n'.
  - `isalpha('\n')` is false.
  - The loop continues to the next character.
- **End of String**:
  - The loop terminates when it encounters the null character (`\0`).

**If we type a longer phrase such as "Hello, World!"**

```sh 
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word or phrase: Hello, World!
Hotel Echo Lima Lima Oscar Whiskey Oscar Romeo Lima Delta
```

- As we can see , and ! are ignored because nonalpha characters are ignored in the code, no output for them is generated.

### Reading and converting a file

```C
int main(int argc, char *argv[]){
    	const char *nato[] = {
        	"Alfa", "Bravo", "Charlie", "Delta", 			"Echo", "Foxtrot", "Golf", "Hotel", 			"India", "Juliett", "Kilo", "Lima", 			"Mike", "November", "Oscar", "Papa", 			"Quebec", "Romeo", "Sierra", "Tango", 			"Uniform", "Victor", "Whiskey", "X-ray", 			"Yankee", "Zulu"};
    FILE *n;
    int ch;
    
    if(argc < 2){
        fprintf(stderr, "Please supply a text file argument\n");
        exit(1);
    }
    
    // Open the filename supplied at the command prompt, referenced as argv[1]
    n = fopen(argv[1], "r");
    if(n == NULL){
        fprintf(stderr, "Unable to open %s\n", argv[1]);
        exit(1);
    }
    
    // Reads one character at a time from the file, storing it in variable ch. The EOF marks the ned of the file.
    while((ch = fgetc(n)) != EOF){
        // Process only text characters
        if(isalpha(ch)){
            // Uses the uppercase version of the character, minus the value of 'A' to index the nato[] array
            printf("%s ", nato[toupper(ch) - 'A']);
        }
    }
    
    putchar('\n');
    fclose(n);
    return 0;
    
}
```

`Output` (Opening our pithy.txt)

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Please supply a text file argument

chan@CMA:~/C_Programming/practice$ ./practice pithy.txt
Papa Oscar Lima India Tango India Charlie Sierra Echo X-ray India Sierra Tango Sierra Sierra Oscar Tango Hotel Alfa Tango Uniform November Charlie Oscar Oscar Romeo Delta India November Alfa Tango Echo Delta Papa Echo Oscar Papa Lima Echo C......
```

### Converting NATO input to character output

- We will be using `strtok()` function to parse words in a stream of text.
- `strtok()` can be assumed to be translated as "string tokenizer".
- The `strtok()` function parses a string into chunks based on one or more separator characters. Defined in `string.h` header file.

```C
char *strtok(char *str, const char *delim);
```

- The first argument `str` is the string to scan.
- The second argument `delim` (delimiter) is a string containing the individual characters that can separate or delimit, the character chunks we want to parse.
- The value returned is a `char` pointer referencing **the character chunk found.**

```C
match = strtok(string, " ");
```

- This statement scans characters held in buffer `string`, stopping when the space character is encountered.
- The `char` pointer `match` holds the address of the word (or text chunk) found, terminated with a null character where the space or another delimiter would otherwise be.
- The `NULL` constant is returned when nothing is found.
- To continue scanning the same string, the first argument is replaced with the `NULL` constant:

```C
match = strtok(NULL, " ");
```

- The `NULL` argument informs the function to use the string passed earlier and continue the tokenizing operation.

```C
int main(){
    char sometext[64];
    char *match;
    
    printf("Type some text: ");
    fgets(sometext, 64, stdin);
    
    // The initial call to strtok(), with the string to search.
    match = strtok(sometext, " ");
    
    // Loop as long as the return value is not NULL
    while(match){
        printf("%s\n", match);
        
        // In the second  call to strtok(), NULL is used to keep searching the same string which is our sometext string.
        match = strtok(NULL, " ");
    }
    
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Type some text: This is some text
This
is
some
text

chan@CMA:~/C_Programming/practice$ ./practice
Type some text: Hello, World!
Hello,
World!

```

- To avoid capturing the punctuation characters, we can set this delimiter string:

```C
match = strtok(sometext, " ,.!?:;\"'')
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Type some text: Hello, World!
Hello
World
```



`practice.h`

```C
char isterm(char *term);
```



`functions.c`

```C
char isterm(char *term)
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    int x;
    const char *n;
    char *t;

    for (x = 0; x < 26; x++)
    {
        // Set pointer n to the current nato word
        n = nato[x];
        // Pointer t references the term passed.
        t = term;

        // Loop until the NATO term ends
        while (*n != '\0')
        {
            // Logically converts each letter to uppercase and compares
            if ((*n | 0x20) != (*t | 0x20))
            {

                // For no match, the loop breaks and the next term in nato[] is compared.
                break;
            }
            // Increment through each letter
            n++;
            t++;
        }

        // When pointer n is the null character, the terms have matched.
        if (*n == '\0')
        {
            // Returns the first letter of the NATO term
            return (*nato[x]);
        }
    }
    return ('\0');
}
```

1. **`char isterm(char \*term)`**: Defines the `isterm` function that takes a string `term` and returns a character.
2. **`const char *nato[] = { ... }`**: Declares an array of strings containing the NATO phonetic alphabet.
3. **`int x;`**: Declares an integer `x` for looping through the NATO array.
4. **`const char *n;`**: Declares a pointer `n` to iterate through the NATO words.
5. **`char *t;`**: Declares a pointer `t` to iterate through the input term.
6. **`for (x = 0; x < 26; x++)`**: Loops through each NATO word.
7. **`n = nato[x];`**: Sets `n` to the current NATO word.
8. **`t = term;`**: Sets `t` to the input term.
9. **`while (*n != '\0')`**: Loops through each character of the NATO word.
10. **`if ((*n | 0x20) != (*t | 0x20))`**: Compares characters case-insensitively.
    - `*n | 0x20 ` and `*t | 0x20`:
      - The bitwise OR operation with `0x20` converts uppercase alphabetic characters to their lowercase equivalents.
      - In ASCII, the difference between uppercase and lowercase letters is the 6th bit (0x20). For example, the ASCII value of 'A' is 65 (0x41) and 'a' is 97 (0x61). The bitwise OR with `0x20` sets this bit, converting 'A' to 'a'.
      - This operation does not affect lowercase letters or non-alphabetic characters.
11. **`break;`**: Breaks the loop if characters don't match.
12. **`n++; t++;`**: Moves to the next character in both strings.
13. **`if (*n == '\0')`**: Checks if the end of the NATO word is reached.
14. **`return (*nato[x]);`**: Returns the first letter of the matching NATO word.
15. **`return ('\0');`**: Returns null character if no match is found.

###### Comparison:

- Bitwise OR with `0x20`:
  - Faster as it involves a single bitwise operation.
  - Works only for ASCII characters.
  - Does not handle locale-specific case conversions.
- `tolower`/`toupper`:
  - More readable and explicit.
  - Handles locale-specific case conversions.
  - Slightly slower due to function call overhead.

`practice.c` (Main)

```C
int main()
{

    char phrase[64];
    char *match;
    char ch;

    printf("NATO word or phrase: ");
    fgets(phrase, 64, stdin);

    match = strtok(phrase, " ");
    while (match)
    {
        if ((ch = isterm(match)) != '\0')
        {
            putchar(ch);
        }
        match = strtok(NULL, " ");
    }

    putchar('\n');
    return 0;
}
```

1. **`char phrase[64];`**: Declares a character array `phrase` with a size of 64 to store the input string.
2. **`char *match;`**: Declares a pointer `match` to hold tokens from the input string.
3. **`char ch;`**: Declares a character variable `ch` to store the result from `isterm`.
4. **`fgets(phrase, 64, stdin);`**: Reads a line of input from the standard input (keyboard) and stores it in `phrase`.
5. **`match = strtok(phrase, " ");`**: Tokenizes the input string `phrase` using space as the delimiter and stores the first token in `match`.
6. **`while (match)`**: Starts a loop that continues as long as `match` is not `NULL`.
7. **`if ((ch = isterm(match)) != '\0')`**: Calls the `isterm` function with `match` and checks if the result is not the null character.
8. **`putchar(ch);`**: If `isterm` returns a valid character, it prints that character.
9. **`match = strtok(NULL, " ");`**: Gets the next token from the input string.
10. **`putchar('\n');`**: Prints a newline character after the loop ends.



`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: india whiskey sierra bravo
IWSB
```

##### Input: "india whiskey sierra bravo"

1. Main Function Execution:
   - The input string is read and tokenized into words: "india", "whiskey", "sierra", "bravo".
   - Each word is passed to the `isterm` function.

##### Processing "india":

1. **Initialization**:
   - `term` = "india"
   - `x` starts at 0, iterating through the NATO phonetic alphabet.
2. **First Iteration (x = 0)**:
   - `n`= "Alfa"
   - `t`= "india"
   - Compare 'A' with 'i' (case-insensitive): no match, break.
3. **Second Iteration (x = 1)**:
   - `n` = "Bravo"
   - `t` = "india"
   - Compare 'B' with 'i': no match, break.
4. **Continue Iterations**:
   - This process continues until `x = 8`.
5. **Ninth Iteration (x = 8)**:
   - `n` = "India"
   - `t` = "india"
   - Compare 'I' with 'i': match.
   - Compare 'n' with 'n': match.
   - Compare 'd' with 'd': match.
   - Compare 'i' with 'i': match.
   - Compare 'a' with 'a': match.
   - `n` reaches null character, return 'I'.

##### Processing "whiskey":

1. **Initialization**:
   - `term` = "whiskey"
   - `x` starts at 0.
2. **Continue Iterations**:
   - This process continues until `x = 22`.
3. **Twenty-Third Iteration (x = 22)**:
   - `n` = "Whiskey"
   - `t` = "whiskey"
   - Compare 'W' with 'w': match.
   - Compare 'h' with 'h': match.
   - Compare 'i' with 'i': match.
   - Compare 's' with 's': match.
   - Compare 'k' with 'k': match.
   - Compare 'e' with 'e': match.
   - Compare 'y' with 'y': match.
   - `n` reaches null character, return 'W'.

##### Processing "sierra":

1. **Initialization**:
   - `term` = "sierra"
   - `x` starts at 0.
2. **Continue Iterations**:
   - This process continues until `x = 18`.
3. **Nineteenth Iteration (x = 18)**:
   - `n` = "Sierra"
   - `t` = "sierra"
   - Compare 'S' with 's': match.
   - Compare 'i' with 'i': match.
   - Compare 'e' with 'e': match.
   - Compare 'r' with 'r': match.
   - Compare 'r' with 'r': match.
   - Compare 'a' with 'a': match.
   - `n` reaches null character, return 'S'.

##### Processing "bravo":

1. **Initialization**:
   - `term` = "bravo"
   - `x` starts at 0.
2. **Second Iteration (x = 1)**:
   - `n` = "Bravo"
   - `t` = "bravo"
   - Compare 'B' with 'b': match.
   - Compare 'r' with 'r': match.
   - Compare 'a' with 'a': match.
   - Compare 'v' with 'v': match.
   - Compare 'o' with 'o': match.
   - `n` reaches null character, return 'B'.

##### Final Output:

The main function collects the results from `isterm` and prints them:

- "IWSB"

This is the step-by-step process of how the input "india whiskey sierra bravo" is processed by the code.

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: india tango whiskey oscar romeo kilo sierra
ITWORKS

```

- An input sentence with no matching characters outputs a blank line. Mixed characters are output like this:

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: Also starring Zulu as Kono
Z
```

#### Reading NATO input from a file

`practice.h`

```C
char isterm(char *term);
```

`functions.c`

```C
char isterm(char *term)
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    int x;
    const char *n;
    char *t;

    for (x = 0; x < 26; x++)
    {
        // Set pointer n to the current nato word
        n = nato[x];
        // Pointer t references the term passed.
        t = term;

        // Loop until the NATO term ends
        while (*n != '\0')
        {
            // Logically converts each letter to uppercase and compares
            if ((*n | 0x20) != (*t | 0x20))
            {

                // For no match, the loop breaks and the next term in nato[] is compared.
                break;
            }
            // Increment through each letter
            n++;
            t++;
        }

        // When pointer n is the null character, the terms have matched.
        if (*n == '\0')
        {

            // Returns the first letter of the NATO term
            return (*nato[x]);
        }
    }

    return ('\0');
}
```

- Explanations are above.

`practice.c`

```C
int main(int argc, char *argv[])
{

    FILE *n;
    char word[64];
    int ch, offset;

    if (argc < 2)
    {
        fprintf(stderr, "Please supply a text file arguments\n");
        exit(1);
    }

    n = fopen(argv[1], "r");
    if (n == NULL)
    {
        fprintf(stderr, "Unable to open '%s'\n", argv[1]);
        exit(1);
    }

    offset = 0;
    // Loop as long as the file has bytes to read
    while ((ch = fgetc(n)) != EOF)
    {
        if (isalpha(ch))
        {
            // Stores the character to build the word
            word[offset] = ch;
            offset++;
            // Checks for overflow; bails if so
            if (offset >= 64)
            {
                fprintf(stderr, "Buffer overflow\n");
                return (1);
            }
        }
        // A nonalphabetic character is found, meaning the end of a word
        else
        {
            // Confirm that the word[] buffer has some text in it
            if (offset > 0)
            {
                // Cap the strings
                word[offset] = '\0';

                // Process the word, returning a valid character or the null character (doesn't print)
                putchar(isterm(word));

                // Resets the offset to store the next word
                offset = 0;
            }
        }
    }
    putchar('\n');
    fclose(n);
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice functions.c
ABCDEFGHIJKLMNOPQRSTUVWYZ
```

---

## Caesarean cipher

- When `block buffering` mode is active, output doesn't appear until the buffer is full or when the program ends.
- Even if a newline appears in the stream, block buffering stores the character in the stream.
- Buffering for an I/O device is set by using the `setbuf()` function, defined in `stdio.h` header file.
- This function overrides the terminal's default line buffering and establishes block buffering using a specific chunk of memory.
- In effect, it disables line buffering for the given file handle ( or standard I/O device) and activates block buffering.

```C
int main()
{
    // A holding bin for standard output; BUFSIZ is defined in stdio.h
    char buffer[BUFSIZ];
    int a, b;

    // Commit standard output to block buffering
    setbuf(stdout, buffer);

    printf("Type a letter: ");
    // Read a single character from standard input
    a = getchar();
    printf("Type a letter: ");

    // Read the next single character from standard input
    b = getchar();

    printf("a='%c', b = '%c'\n", a, b);

    return 0;
}
```

- If we run this program, we see no output, instead the `getchar()` function prompts for input, so the program waits.
- The output is held back, stored in the character array `buffer`, waiting for text to fill the buffer or for the program to end.
- If we type `ab` at the blinking cursor, only after the Enter key is pressed, does the program end and the buffer is flushed, revealing standard output:

```sh
chan@CMA:~/C_Programming/practice$ ./practice
ab
Type a letter: Type a letter: a='a', b = 'b'
```

- Some C programmers use the `fflush()` function to force output or to clear the input stream which may be a workable solution but not the best.

#### Writing a simple filter

- Filters modify stream input and generate stream output.

- The `getchar()` function reads a single character from standard input.

- For most compilers, `getchar()` is a macro, equivalent to the `fgetc()` function:

  - ```C
    c = fgetc(stdin);
    ```

- The `fgetc()` function reads a single character (byte) from an open file handle. 

- On the preceding line, `stdin` is used as the standard input device. 

- The integer value returned is stored in the `int` variable `c`.

- This variable must be declared of the integer data type, not character.

- The reason is that important values, specifically the end-of-file (EOF) marker, are integer values.

- Assigning the function's return value to a `char` variable means the EOF won't be interpreted properly.

- The `putchar()` function sends a single character to standard output.

- `putchar()` is often defined as a macro that expands to the `fputc()` function.

- ```C
  r = fputc(c, stdout);
  ```

- The `fputc()` function sends an integer value `c` to the open file handle represented by `stdout`.

- The return value, `r` is the character written or EOF for an error.

- As with `fgetc()`, both variables `r` and `c` must be integers.

- In Linux, the EOF key is `Ctrl + D`.



A program to modify the input so that all vowels are detected and replaced with an asterisk.

```C
int main()
{
    // I/O deals with integers, not characters.
    int ch;

    while ((ch = getchar()) != EOF)
    {
        switch (ch)
        {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            putchar('*');
            break;
        default:
            putchar(ch);
        }
    }

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
hello
h*ll*
```

- The program will keep prompting, we just have to press `Ctrl + D` to mark the EOF thus end the program.



#### Exercise 4.1

"Now that you have the basic filter skeleton in `io_filter.c`, you can perform your own
modifications, testing your filter programming skills. Here is such a challenge you can
code on your own: write a filter that converts lowercase characters to uppercase. The
effect of such a filter is to generate output in ALL CAPS."

`practice.c`

```C
int main(){
    int ch;
    
    while((ch = getchar()) != EOF){
        if(islower(ch)){
            ch = toupper(ch);
        }
        putchar(ch);
    }
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
heLlO
HELLO
chan@CMA:~/C_Programming/practice$ ./practice
hey hey not bad
HEY HEY NOT BAD
```



#### Exercise 4.2

"Write a filter that randomizes character text, modifying standard input to generate
output in either upper- or lowercase, regardless of the original character’s case."

```C
int main(){
    int ch, r;
    
    // Seed the randomizer
    srand((unsigned)time(NULL));
    
    while((ch = getchar()) != EOF){
        // Generate a random value, 0 to 1
        r = rand() % 2;
        
        // If r == 1, make the character uppercase
        if(r){
            putchar(toupper(ch));
        }
        // Otherwise, it is converted to lower
        else{
            putchar(tolower(ch));
        }
        
        // touppper() and tolower() affect only letters.
    }
}
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice
Could be worse, oh wait no it couldn't.
couLd Be WORse, OH WaIT no iT COULdN'T.

```

```sh
chan@CMA:~/C_Programming/practice$ echo "Give me all your moeny" | ./practice
gIvE mE aLl yoUr mOeny
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice < file.txt
chan@CMA:~/C_Programming/practice$ echo "Give me all your moeny" | ./practice > file.txt
```

#### Rotating 13 characters

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-09-30 22-21-23.png)

```C
int main()
{
    int ch;
    while ((ch = getchar()) != EOF)
    {
        // Only process alphabet characters
        if (isalpha(ch))
        {

            // Searches for "A" thru "M" or "a" thru "m"
            if (toupper(ch) >= 'A' && toupper(ch) <= 'M')
            {
                // Rotates(shift) up for the lower half of the alphabet
                ch += 13;
            }
            else
            {
                // Otherwise, rotates (shift) down
                ch -= 13;
            }
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ echo "Hail, Caesar!" | ./practice
UnvyPnrfne
```

- Because the `rot13` filter decodes and encodes the same text, we can put the program to the test through it twice.
- In the command-line construction below, text is echoed through the program once and then again.
- The result is the original text, thanks to the magic of the `rot13` process.

```sh
chan@CMA:~/C_Programming/practice$ echo "Hail, Caesar!" | ./practice | ./practice
HailCaesar
```

```sh
chan@CMA:~/C_Programming/practice$ echo "Why did Caesar cross the Rubicon?" | ./practice 
JulqvqPnrfnepebffgurEhovpba
```

#### Devising a more Caesarean cipher

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-01 22-01-21.png)

- When a character is detected as out of range by the if statement, its value must be reduced by 26, wrapping it back to 'A' or 'a', depending on the letter's original case.
- Due to the proximity of uppercase 'Z' to lowercase 'a', this if statement test works because this particular shift is only three characters.
- From figure 4.7, we can see that the ASCII table sets only six characters between uppercase Z and lowercase a.
- For larger character shifts, more complex testing must be performed.

```C
int main(){
    int shift,ch;
    
    //Shifts from A to D which is done backward here because math
    shift = 'D' - 'A';
    
    while((ch = getchar()) != EOF){
        // Only process alphabet characters
        if(isalpha(ch)){
            // Shift the letter
            ch += shift;
            
            // Determines whether the new character is out of range
            if((ch > 'Z' && ch < 'a') || ch > 'z'){
                // If so, adjusts its value back within range
                ch -= 26;
            }
        }
    }
    
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Now is the time for all good men...
Qrz lv wkh wlph iru doo jrrg phq...
```

- Unlike with a `rot13` filter, we can't run the same program twice to decode the A-to-D shift.
- Instead, to decode the message, we must shift from D back to A.
- Two changes are required to make this change.

```C
shift = 'A' - 'D';
```

- Second, the out-of-bounds testing must check the underside of the alphabet, so see whether a character's value has dipped below 'A' or 'a':

```C
if(ch < 'A' || (ch > 'Z' && ch < 'a')){
    ch += 26;
}
```

- If the character wraps on the underside of the alphabet, its value is increased by 26, which wraps it back up to the Z end, correcting the overflow.



```C
int main(int argc, char *argv[])
{
    int shift, ch;
    char a, b;

    // If fewer than 3 arguments are provided, default shift is 13.
    if (argc < 3)
    {
        shift = 13;
    }
    else
    {
        // Get the first characters of the second and third arguments
        a = argv[2][0];
        b = argv[1][0];

        // Check if both characters are alphabetic
        if (isalpha(a) && isalpha(b))
        {
            // Convert both to uppercase
            a = toupper(a);
            b = toupper(b);

            // calculate the shift value
            shift = a - b;

            // Ensure the shift is within the range -25 to 25
            if (shift < -25 || shift > 25)
            {
                shift = 13;
            }
        }
        else
        {
            shift = 13;
        }
    }

    // Read characters from standard input until EOF
    while ((ch = getchar()) != EOF)
    {
        //If the character is an uppercase letter
        if (isupper(ch))
        {
            // Shift the letter
            ch += shift;

            // Adjusts appropriately for overflow in either direction
            // Adjust for overflow beyond 'Z'
            if (ch > 'Z')
                ch -= 26;
            // Adjust for overflow below 'A'
            if (ch < 'A')
                ch += 26;
            putchar(ch);
        }
        // If it is a lowercase letter
        else if (islower(ch))
        {
            ch += shift;
            if (ch > 'z')
                ch -= 26;
            if (ch < 'a')
                ch += 26;
            putchar(ch);
        }
        // If the character is not a letter, print it as is
        else
        {
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}

```

- **Shift Calculation**:
  - If fewer than 3 arguments are provided, the shift is set to 13.
  - If 3 or more arguments are provided, the first characters of the second and third arguments are used to calculate the shift.
  - For example, if the arguments are `./practice A D`, `a` is 'D' and `b` is 'A'. The shift is calculated as `shift = 'D' - 'A' = 3`.
- **Processing Each Character**:
  - For each character read:
    - If it is an uppercase letter (e.g., 'T'):
      - The character is shifted by the calculated shift value.
      - Adjustments are made if the shifted character goes beyond 'Z' or below 'A'.
    - If it is a lowercase letter (e.g., 'h'):
      - The character is shifted by the calculated shift value.
      - Adjustments are made if the shifted character goes beyond 'z' or below 'a'.
    - If it is not a letter (e.g., space ' '), it is printed as is.

```sh
chan@CMA:~/C_Programming/practice$ ./practice A R
This is a test
Kyzj zj r kvjk

chan@CMA:~/C_Programming/practice$ ./practice R A
Kyzj zj r kvjk
This is a test

```

##### Example Run 1: `./practice A R`

1. **Command-Line Arguments**:
   - `argv[1] = "A"`
   - `argv[2] = "R"`
2. **Shift Calculation**:
   - `a = 'R'`
   - `b = 'A'`
   - Convert both to uppercase (they are already uppercase).
   - `shift = 'R' - 'A' = 82 - 65 = 17`
3. **Input**: "This is a test"
4. **Character Processing**:
   - 'T' (uppercase):
     - Shifted: 'T' + 17 = 'K' (adjusted for overflow)
   - 'h' (lowercase):
     - Shifted: 'h' + 17 = 'y'
   - 'i' (lowercase):
     - Shifted: 'i' + 17 = 'z'
   - 's' (lowercase):
     - Shifted: 's' + 17 = 'j'
   - ' ' (space):
     - Printed as is
   - 'i' (lowercase):
     - Shifted: 'i' + 17 = 'z'
   - 's' (lowercase):
     - Shifted: 's' + 17 = 'j'
   - ' ' (space):
     - Printed as is
   - 'a' (lowercase):
     - Shifted: 'a' + 17 = 'r'
   - ' ' (space):
     - Printed as is
   - 't' (lowercase):
     - Shifted: 't' + 17 = 'k'
   - 'e' (lowercase):
     - Shifted: 'e' + 17 = 'v'
   - 's' (lowercase):
     - Shifted: 's' + 17 = 'j'
   - 't' (lowercase):
     - Shifted: 't' + 17 = 'k'
5. **Output**: "Kyzj zj r kvjk"

##### Example Run 2: `./practice R A`

1. **Command-Line Arguments**:
   - `argv[1] = "R"`
   - `argv[2] = "A"`
2. **Shift Calculation**:
   - `a = 'A'`
   - `b = 'R'`
   - Convert both to uppercase (they are already uppercase).
   - `shift = 'A' - 'R' = 65 - 82 = -17`
3. **Input**: "Kyzj zj r kvjk"
4. **Character Processing**:
   - 'K' (uppercase):
     - Shifted: 'K' - 17 = 'T' (adjusted for underflow)
   - 'y' (lowercase):
     - Shifted: 'y' - 17 = 'h'
   - 'z' (lowercase):
     - Shifted: 'z' - 17 = 'i'
   - 'j' (lowercase):
     - Shifted: 'j' - 17 = 's'
   - ' ' (space):
     - Printed as is
   - 'z' (lowercase):
     - Shifted: 'z' - 17 = 'i'
   - 'j' (lowercase):
     - Shifted: 'j' - 17 = 's'
   - ' ' (space):
     - Printed as is
   - 'r' (lowercase):
     - Shifted: 'r' - 17 = 'a'
   - ' ' (space):
     - Printed as is
   - 'k' (lowercase):
     - Shifted: 'k' - 17 = 't'
   - 'v' (lowercase):
     - Shifted: 'v' - 17 = 'e'
   - 'j' (lowercase):
     - Shifted: 'j' - 17 = 's'
   - 'k' (lowercase):
     - Shifted: 'k' - 17 = 't'
5. **Output**: "This is a test"

##### Summary:

- The program calculates the shift based on the difference between the first characters of the second and third command-line arguments.
- It then reads input characters, shifts alphabetic characters by the calculated amount, and prints the modified characters.
- Non-alphabetic characters are printed as is.
- The shift value can be positive or negative, depending on the order of the command-line arguments.

#### Building the hex output filter

```C
int main()
{
    int ch, wrap;

    // Initialize the wrap to zero
    wrap = 0;
    while ((ch = getchar()) != EOF)
    {
        // Outputs character as two-digit hex byte, with a leading zero.
        printf("%0.2X ", ch);
        wrap += 3; // Each printf() output is 3 characters wide

        // Assume that the terminal column width is 80
        // 77 because 77 + 3 = 80
        if (wrap > 77 || ch == '\n')
        {
            // Output a newline
            putchar('\n');
            // Reset the wrap value
            wrap = 0;
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
This is a test
54 68 69 73 20 69 73 20 61 20 74 65 73 74 0A
```



#### Creating a NATO filter

```c
int main()
{

    const char *nato[] = {"Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    char ch;

    while ((ch = getchar()) != EOF)
    {
        if (isalpha(ch))
        {
            // Translates a character into an offset within the nato[] array
            printf("%s ", nato[toupper(ch) - 'A']);
        }
        // Output a newline when encountered to keep the output clean
        if (ch == '\n')
        {
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
hello
Hotel Echo Lima Lima Oscar
```



#### Filtering words

```C
#define WORDSIZE 64

int main(){
    char word[WORDSIZE];
    int ch, offset;
    
    // Initializes the offset value
    offset = 0;
    
    while((ch = getchar()) != EOF){
        // The isspace() returns TRUE for white space characters, marking the end of a word
        if(isspace(ch)){
            // Capping the string with null 
            word[offset] = '\0';
            // Ensures that the buffer has text in it to print
            if(offset > 0){
                // Output the buffer's content on a line by itself
                printf("%s\n", word);
            }
            // Reset the offset
            offset = 0;
        }
        // Printable characters are handled here, filling the buffer.
        else{
            // Stores the character
            word[offset] = ch;
            // Increment the offset
            offset++;
            
            // Checks for potential overflow, a full buffer
            if(offset == WORDSIZE - 1){
                // Cap the string!
                word[offset] = '\0';
                // Output the word, dumping the buffer
                printf("%s\n", word);
                // reset the offset
                offset = 0;
            }
        }
    }
    
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Is this still the Caesarean Cipher chapter?
Is
this
still
the
Caesarean
Cipher
chapter?
```

##### Step-by-Step Process:

1. **Initial State**:
   - `word` buffer is empty.
   - `offset` is 0.
2. **Processing "Is"**:
   - 'I' is stored in `word[0]`, `offset` becomes 1.
   - 's' is stored in `word[1]`, `offset` becomes 2.
   - Space ' ' is encountered:
     - `word[2]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "Is".
     - `offset` is reset to 0.
3. **Processing "this"**:
   - 't' is stored in `word[0]`, `offset`becomes 1.
   - 'h' is stored in `word[1]`, `offset` becomes 2.
   - 'i' is stored in `word[2]`, `offset` becomes 3.
   - 's' is stored in `word[3]`, `offset` becomes 4.
   - Space ' ' is encountered:
     - `word[4]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "this".
     - `offset` is reset to 0.
4. **Processing "still"**:
   - 's' is stored in `word[0]`, `offset` becomes 1.
   - 't' is stored in `word[1]`, `offset` becomes 2.
   - 'i' is stored in `word[2]`, `offset` becomes 3.
   - 'l' is stored in `word[3]`, `offset` becomes 4.
   - 'l' is stored in `word[4]`, `offset` becomes 5.
   - Space ' ' is encountered:
     - `word[5]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "still".
     - `offset` is reset to 0.
5. **Processing "the"**:
   - 't' is stored in `word[0]`, `offset` becomes 1.
   - 'h' is stored in `word[1]`, `offset` becomes 2.
   - 'e' is stored in `word[2]`, `offset` becomes 3.
   - Space ' ' is encountered:
     - `word[3]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "the".
     - `offset` is reset to 0.
6. **Processing "Caesarean"**:
   - 'C' is stored in `word[0]`, `offset` becomes 1.
   - 'a' is stored in `word[1]`, `offset` becomes 2.
   - 'e' is stored in `word[2]`, `offset` becomes 3.
   - 's' is stored in `word[3]`, `offset` becomes 4.
   - 'a' is stored in `word[4]`, `offset` becomes 5.
   - 'r' is stored in `word[5]`, `offset` becomes 6.
   - 'e' is stored in `word[6]`, `offset` becomes 7.
   - 'a' is stored in `word[7]`, `offset` becomes 8.
   - 'n' is stored in `word[8]`, `offset`becomes 9.
   - Space ' ' is encountered:
     - `word[9]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "Caesarean".
     - `offset` is reset to 0.
7. **Processing "Cipher"**:
   - 'C' is stored in `word[0]`, `offset` becomes 1.
   - 'i' is stored in `word[1]`, `offset` becomes 2.
   - 'p' is stored in `word[2]`, `offset` becomes 3.
   - 'h' is stored in `word[3]`, `offset` becomes 4.
   - 'e' is stored in `word[4]`, `offset`becomes 5.
   - 'r' is stored in `word[5]`, `offset` becomes 6.
   - Space ' ' is encountered:
     - `word[6]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "Cipher".
     - `offset` is reset to 0.
8. **Processing "chapter?"**:
   - 'c' is stored in `word[0]`, `offset` becomes 1.
   - 'h' is stored in `word[1]`, `offset` becomes 2.
   - 'a' is stored in `word[2]`, `offset` becomes 3.
   - 'p' is stored in `word[3]`, `offset` becomes 4.
   - 't' is stored in `word[4]`, `offset` becomes 5.
   - 'e' is stored in `word[5]`, `offset` becomes 6.
   - 'r' is stored in `word[6]`, `offset` becomes 7.
   - '?' is stored in `word[7]`, `offset` becomes 8.
   - End of input:
     - `word[8]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "chapter?".



##### Notes

- It is vital that all strings in C end with the null character, `\0`, especially when we build our own strings, as done in the above program, confirm that the string that's created is capped.
- If not, we get an overflow and all kinds of ugly output and potentially bad things happening.

---

## Encoding and decoding

- To explore the concept of encoding and decoding, regardless of the thrills and dangers, we must:
  - Appreciate how characters are represented on computers
  - Learn various ASCII encoding tricks
  - Play with character representation
  - Translate plain text into hex bytes for data transfer
  - Reverse translate hex bytes back into text (or data)
  - Improve encoding techniques by adding checksums
  - Explore the URL encoding method

### The concept of plain text

- The computer doesn't know text.
- The `char` data type is merely a tiny integer, ranging in value from 0 through 255 (unsigned) or -128 to 127 (signed).
- It's only the presentation of the `char` data type that makes it look like a character.

### Understanding ASCII

![Screenshot from 2024-10-05 20-45-17](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-05 20-45-17.png)

- ASCII codes range from 0 through 127.
- These are binary values 000-0000 through 111-1111.
- For the C language `char` data type, these values are all positive whether the variable is signed or unsigned.

### Simple Program that prints ASCII value of a character

```C
int main()
{
    // Allocate memory for the input
    char *input = malloc(2 * sizeof(char));
    if (input == NULL)
    {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(1);
    }
    // Getting input from the user
    printf("Enter a word: ");
    if (fgets(input, 2, stdin) != NULL)
    {
        // Remove newline character if present
        size_t len = strlen(input);
        if (len > 0 && input[len - 1] == '\n')
        {
            input[len - 1] = '\0';
        }
    }
    printf("ASCII code for %s is %d\n", input, input[0]);
	
    // Free the memory
    free(input);
    // Assign our input pointer to NULL to avoid dangling pointer
    input = NULL;
    return 0;
}
```

### Implement the ASCII table as shown above

```C
int main()
{
    int x;

    // output the header row, all columns or "sticks"
    printf("Dec Oct Hex C \
    Dec Oct Hex C \
    Dec Oct Hex C \
    Dec Oct Hex C\n");

    // only need to process one stick, but use offsets to output the other three sticks
    for (x = 0; x < 32; x++)
    {
        // printing values in decimal %d, octal %o, hex %x wtih a minimum field width of 3 characters
        // first stick, don't output character values
        printf("%3d %3o %3x - | ", x, x, x);
        // each other stick in a 32, 64, 96 offset
        printf(" %3d %3o %3x  %c | ", x + 32, x + 32, x + 32, x + 32);

        printf(" %3d %3o %3x  %c | ", x + 64, x + 64, x + 64, x + 64);

        printf(" %3d %3o %3x  %c \n", x + 96, x + 96, x + 96, x + 96);
    }
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Dec Oct Hex C     Dec Oct Hex C     Dec Oct Hex C     Dec Oct Hex C
  0   0   0 - |   32  40  20    |   64 100  40  @ |   96 140  60  ` 
  1   1   1 - |   33  41  21  ! |   65 101  41  A |   97 141  61  a 
  2   2   2 - |   34  42  22  " |   66 102  42  B |   98 142  62  b 
  3   3   3 - |   35  43  23  # |   67 103  43  C |   99 143  63  c 
  4   4   4 - |   36  44  24  $ |   68 104  44  D |  100 144  64  d 
  5   5   5 - |   37  45  25  % |   69 105  45  E |  101 145  65  e 
  6   6   6 - |   38  46  26  & |   70 106  46  F |  102 146  66  f 
  7   7   7 - |   39  47  27  ' |   71 107  47  G |  103 147  67  g 
  8  10   8 - |   40  50  28  ( |   72 110  48  H |  104 150  68  h 
  9  11   9 - |   41  51  29  ) |   73 111  49  I |  105 151  69  i 
 10  12   a - |   42  52  2a  * |   74 112  4a  J |  106 152  6a  j 
 11  13   b - |   43  53  2b  + |   75 113  4b  K |  107 153  6b  k 
 12  14   c - |   44  54  2c  , |   76 114  4c  L |  108 154  6c  l 
 13  15   d - |   45  55  2d  - |   77 115  4d  M |  109 155  6d  m 
 14  16   e - |   46  56  2e  . |   78 116  4e  N |  110 156  6e  n 
 15  17   f - |   47  57  2f  / |   79 117  4f  O |  111 157  6f  o 
 16  20  10 - |   48  60  30  0 |   80 120  50  P |  112 160  70  p 
 17  21  11 - |   49  61  31  1 |   81 121  51  Q |  113 161  71  q 
 18  22  12 - |   50  62  32  2 |   82 122  52  R |  114 162  72  r 
 19  23  13 - |   51  63  33  3 |   83 123  53  S |  115 163  73  s 
 20  24  14 - |   52  64  34  4 |   84 124  54  T |  116 164  74  t 
 21  25  15 - |   53  65  35  5 |   85 125  55  U |  117 165  75  u 
 22  26  16 - |   54  66  36  6 |   86 126  56  V |  118 166  76  v 
 23  27  17 - |   55  67  37  7 |   87 127  57  W |  119 167  77  w 
 24  30  18 - |   56  70  38  8 |   88 130  58  X |  120 170  78  x 
 25  31  19 - |   57  71  39  9 |   89 131  59  Y |  121 171  79  y 
 26  32  1a - |   58  72  3a  : |   90 132  5a  Z |  122 172  7a  z 
 27  33  1b - |   59  73  3b  ; |   91 133  5b  [ |  123 173  7b  { 
 28  34  1c - |   60  74  3c  < |   92 134  5c  \ |  124 174  7c  | 
 29  35  1d - |   61  75  3d  = |   93 135  5d  ] |  125 175  7d  } 
 30  36  1e - |   62  76  3e  > |   94 136  5e  ^ |  126 176  7e  ~ 
 31  37  1f - |   63  77  3f  ? |   95 137  5f  _ |  127 177  7f 
```

#### Explaination:

The loop iterates from 0 to 31. For each value of `x`, it prints the ASCII values and their corresponding characters in four columns:

- **First Column**: Values from 0 to 31 (control characters, which are not printable, hence the `-`).  
  - Control characters are non-printable characters in the ASCII table that are used to control the behavior of devices such as printers or display screens. 
  - They are part of the ASCII standard and occupy the first 32 positions (0 to 31) in the ASCII table. 
  - These characters do not represent printable symbols but instead perform specific control functions.
- **Second Column**: Values from 32 to 63 (printable characters).
- **Third Column**: Values from 64 to 95 (printable characters).
- **Fourth Column**: Values from 96 to 127 (printable characters).

#### Examples of Control Characters

Here are some common control characters and their functions:

1. **NUL (Null Character)**: ASCII code 0. Used to signify the end of a string in C and other programming languages.
2. **SOH (Start of Header)**: ASCII code 1. Used to mark the beginning of a header in data transmission.
3. **STX (Start of Text)**: ASCII code 2. Used to mark the beginning of the text in data transmission.
4. **ETX (End of Text)**: ASCII code 3. Used to mark the end of the text in data transmission.
5. **EOT (End of Transmission)**: ASCII code 4. Used to indicate the end of data transmission.
6. **ENQ (Enquiry)**: ASCII code 5. Used to request a response from a remote station.
7. **ACK (Acknowledge)**: ASCII code 6. Used to acknowledge receipt of a message.
8. **BEL (Bell)**: ASCII code 7. Causes the device to emit a sound or "bell".
9. **BS (Backspace)**: ASCII code 8. Moves the cursor one position back.
10. **TAB (Horizontal Tab)**: ASCII code 9. Moves the cursor to the next tab stop.
11. **LF (Line Feed)**: ASCII code 10. Moves the cursor to the next line.
12. **VT (Vertical Tab)**: ASCII code 11. Moves the cursor to the next vertical tab stop.
13. **FF (Form Feed)**: ASCII code 12. Moves the cursor to the top of the next page.
14. **CR (Carriage Return)**: ASCII code 13. Moves the cursor to the beginning of the line.
15. **SO (Shift Out)**: ASCII code 14. Switches to an alternate character set.
16. **SI (Shift In)**: ASCII code 15. Switches back to the standard character set.
17. **DLE (Data Link Escape)**: ASCII code 16. Used to change the meaning of the following characters.
18. **DC1 (Device Control 1)**: ASCII code 17. Used for device control.
19. **DC2 (Device Control 2)**: ASCII code 18. Used for device control.
20. **DC3 (Device Control 3)**: ASCII code 19. Used for device control.
21. **DC4 (Device Control 4)**: ASCII code 20. Used for device control.
22. **NAK (Negative Acknowledge)**: ASCII code 21. Indicates a negative response to a message.
23. **SYN (Synchronous Idle)**: ASCII code 22. Used to synchronize transmission.
24. **ETB (End of Transmission Block)**: ASCII code 23. Indicates the end of a block of data.
25. **CAN (Cancel)**: ASCII code 24. Indicates that the previous data should be discarded.
26. **EM (End of Medium)**: ASCII code 25. Indicates the end of the medium.
27. **SUB (Substitute)**: ASCII code 26. Used to replace a character that is invalid or unreadable.
28. **ESC (Escape)**: ASCII code 27. Used to introduce an escape sequence.
29. **FS (File Separator)**: ASCII code 28. Used to separate files.
30. **GS (Group Separator)**: ASCII code 29. Used to separate groups of data.
31. **RS (Record Separator)**: ASCII code 30. Used to separate records.
32. **US (Unit Separator)**: ASCII code 31. Used to separate units of data.

![Screenshot from 2024-10-05 22-46-49](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-05 22-46-49.png)

![Screenshot from 2024-10-05 22-46-41](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-05 22-46-41.png)

### Generating a noncharacter output

`practice.h`

```C
char *binString(char a);
```

`functions.c`

```C
char *binString(char a)
{
    static char b[9];
    int i;

    i = 0;
    // Loops for each bit in the 8-bit byte
    while (i < 8)
    {
        // The ternary operator sets a 1 or 0 into the string, depending on the value of the far left bit in variable a.
        // The expression 'a & 0x80' checks if the most significant bit (leftmost bit) of 'a' is set. If it is, 'b[i]' is set to '1'; otherwise, it is set to '0'.
        b[i] = a & 0x80 ? '1' : '0';

        // Variable a's value is shifted one bit position to the left.
        a <<= 1;
        i++;
    }

    // At this point, i is equal to 8, so the string is capped.
    b[i] = '\0';

    return b;
}
```

`practice.c`

```C
int main()
{
    // Allocating memory
    char *testChar = malloc(2 * sizeof(char));
    if (testChar == NULL)
    {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(1);
    }
    
    // Prompting for input
    printf("Enter a word: ");
    if (fgets(testChar, 2, stdin) != NULL)
    {
        // Remove newline character
        size_t len = strlen(testChar);
        if (len > 0 && testChar[len - 1] == '\n')
        {
            testChar[len - 1] = '\0';
        }
    }
    
    char *binaryString = binString(testChar[0]);
    printf("Binary representation of '%s' is %s\n", testChar, binaryString);
    
    // Free the allocated memory and assign it to NULL to avoid dangling pointer
    free(testChar);
    testChar = NULL;
    return 0;
}
```

##### Explanation of Line 11:

```C
b[i] = a & 0x80 ? '1' : '0';
```

- `a & 0x80`: This performs a bitwise AND operation between `a`and `0x80` (which is `10000000` in binary). This operation isolates the most significant bit (MSB) of `a`.
- `a & 0x80 ? '1' : '0'`: This is a ternary operator. If the MSB of `a` is 1, the expression evaluates to `'1'`; otherwise, it evaluates to `'0'`.
- `b[i] = ...`: This assigns the result of the ternary operation to the `i`-th position in the array b.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word: A
Binary representation of 'A' is 01000001
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word: 1
Binary representation of '1' is 00110001
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word: a
Binary representation of 'a' is 01100001
```

1. **Character `'A'`**:
   - ASCII code: 65
   - Binary representation: `01000001`
2. **Character `'1'`**:
   - ASCII code: 49
   - Binary representation: `00110001`
3. **Character `'a'`**:
   - ASCII code: 97
   - Binary representation: `01100001`

#### Playing with ASCII conversion tricks

```C
printf("%d\n", '9' - '0');
```

- This `printf()` statement subtracts '0' from '9', which look like character values but are seen by the compiler as 0x39 - 0x30. 

- The result is output as decimal value nine, which is what '9' represents.

- The upper and lowercase characters differ by exactly 32 or 0x20. 

  - ```
    A  65  0x41   0010-0001
    		    ↓
    a   97  0x61   0110-0001
    
    /How the sixth bit in a byte affects letter case
    ```

  - To convert an uppercase letter to lowercase, you reset the sixth bit in the byte.

  - To convert a lowercase letter to uppercase, you set the sixth bit in the byte.

```C
char c = 'A';
c = c | 0x20; // or c |= 0x20;
```

- Above, the uppercase letter in `char` variable `c` is converted to its lowercase equivalent.

- To convert a lowercase letter to uppercase, we must reset (change to zero) the sixth bit in the byte.

- To handle this operation, use the & operator, which masks out bits:

  - ```C
    c = c & 0xdf; // c &= 0xdf;
    ```

  - ```C
    int main()
    {
        char c = 'a';
        c &= 0xdf;
        printf("%c\n", c);
        return 0;
    }
    ```

  - ```sh
    chan@CMA:~/C_Programming/test$ ./final
    A
    ```

- The binary representation of `0x20` is `01000000`. The binary representation of `0xdf` is `10111111`.



```C
int main()
{
    char sentence[] = "ASCII makes my heart beat faster\n";
    char *s;

    s = sentence;
    while (*s)
    {
        // Filters out uppercase text
        if (*s >= 'A' && *s <= 'Z')
        {
            // outputs the lowercase character
            putchar(*s | 0x20);
        }
        else
        {
            putchar(*s);
        }
        s++;
    }

    s = sentence;
    while (*s)
    {
        // filters out lowercase text
        if (*s >= 'a' && *s <= 'z')
        {
            // output the uppercase character
            putchar(*s & 0xdf);
        }
        else
        {
            putchar(*s);
        }
        s++;
    }
    return 0;
}
```

- The same string `sentence[]` is processed twice.
- The first time, a while loop plucks uppercase characters from the string, converting them to lowercase by the bitwise `| 0x20` operation.
- The second while loop targets lowercase letters, converting them to uppercase with `& 0xdf` operation.
- Pointer `s` is used to work through the `sentence[]` array one character at a time.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
ascii makes my heart beat faster
ASCII MAKES MY HEART BEAT FASTER
```

#### A simple hex encoder/decoder

```C

int main()
{
    int ch;
    while ((ch = getchar()) != EOF)
    {
        printf("%02X", ch);
    }
    putchar('\n');
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice
Hello there, hex!
48656C6C6F2074686572652C20686578210A
```

![Screenshot from 2024-10-07 23-22-47](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-07 23-22-47.png)

Figure 5.4 illustrates what's going on with the output, how each character of input is translated into the hex bytes.



#### Hexdefilter

```C

int tohex(c)
{
    // Eliminates the digits 0 thru 9
    if (c >= '0' && c <= '9')
    {
        // Returns the digit's integer value
        return (c - '0');
    }
    // Eliminates the letters A thru F
    if (c >= 'A' && c <= 'F')
    {
        // Returns the character's hex value: 'A' == 0x0A
        return (c - 'A' + 0xA);
    }

    // Anything out of range returns -1
    return -1;
}

int main()
{
    int ch, a, b;

    // The endless loop relies upon the presence of an EOF to terminate
    while (1)
    {
        // Reads a character
        ch = getchar();
        // check for EOF and breaks the loop if found
        if (ch == EOF)
            break;
        // convert the character to a hex value
        a = tohex(ch);

        // Exit if the character isn't hex
        if (a < 0)
            break;

        // Shifts value a four bits to represent the upperhalf of the byte in value
        a <<= 4;

        // Repeat the process for the next character, but without the shift
        ch = getchar();
        if (ch == EOF)
            break;
        b = tohex(ch);
        if (b < 0)
            break;

        // Outputs the resulting byte
        putchar(a + b);
    }
    putchar('\n');
    return 0;
}
```

### Explanation of Each Line

1. **Function `tohex`**:
   - `int tohex(c)`: Defines a function `tohex` that takes a single character `c` and returns its hexadecimal value.
   - `if (c >= '0' && c <= '9')`: Checks if `c` is a digit between '0' and '9'.
   - `return (c - '0');`: Converts the character digit to its integer value.
   - `if (c >= 'A' && c <= 'F')`: Checks if `c` is an uppercase letter between 'A' and 'F'.
   - `return (c - 'A' + 0xA);`: Converts the character letter to its hexadecimal value.
   - `return -1;`: Returns -1 if `c` is not a valid hexadecimal character.
2. The program stops when it encounters a nonhex digit or when the EOF is encountered.

##### Explanation

1. **Hexadecimal Values**:
   - `0x40` is the hexadecimal representation of the decimal number 64.
   - `0x08` is the hexadecimal representation of the decimal number 8.
2. **Addition**:
   - Adding these two values: `0x40 + 0x08` is equivalent to `64 + 8` in decimal, which equals 72.
3. **ASCII Character**:
   - The ASCII value 72 corresponds to the character 'H'.

##### Step-by-Step Execution with Input `48656C6C6F2C20776F726C64210A`

Let's break down the input `48656C6C6F2C20776F726C64210A` step by step:

1. **Input**: "48"
   - `a = tohex('4')`: `a = 4`
   - `a <<= 4`: `a = 4 << 4 = 64` (0x40)
   - `b = tohex('8')`: `b = 8`
   - `putchar(a + b)`: `putchar(0x40 + 0x08)`: Prints 'H'
2. **Input**: "65"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('5')`: `b = 5`
   - `putchar(a + b)`: `putchar(0x60 + 0x05)`: Prints 'e'
3. **Input**: "6C"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('C')`: `b = 12`
   - `putchar(a + b)`: `putchar(0x60 + 0x0C)`: Prints 'l'
4. **Input**: "6C"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('C')`: `b = 12`
   - `putchar(a + b)`: `putchar(0x60 + 0x0C)`: Prints 'l'
5. **Input**: "6F"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('F')`: `b = 15`
   - `putchar(a + b)`: `putchar(0x60 + 0x0F)`: Prints 'o'
6. **Input**: "2C"
   - `a = tohex('2')`: `a = 2`
   - `a <<= 4`: `a = 2 << 4 = 32` (0x20)
   - `b = tohex('C')`: `b = 12`
   - `putchar(a + b)`: `putchar(0x20 + 0x0C)`: Prints ','
7. **Input**: "20"
   - `a = tohex('2')`: `a = 2`
   - `a <<= 4`: `a = 2 << 4 = 32` (0x20)
   - `b = tohex('0')`: `b = 0`
   - `putchar(a + b)`: `putchar(0x20 + 0x00)`: Prints ' '
8. **Input**: "77"
   - `a = tohex('7')`: `a = 7`
   - `a <<= 4`: `a = 7 << 4 = 112` (0x70)
   - `b = tohex('7')`: `b = 7`
   - `putchar(a + b)`: `putchar(0x70 + 0x07)`: Prints 'w'
9. **Input**: "6F"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('F')`: `b = 15`
   - `putchar(a + b)`: `putchar(0x60 + 0x0F)`: Prints 'o'
10. **Input**: "72"
    - `a = tohex('7')`: `a = 7`
    - `a <<= 4`: `a = 7 << 4 = 112` (0x70)
    - `b = tohex('2')`: `b = 2`
    - `putchar(a + b)`: `putchar(0x70 + 0x02)`: Prints 'r'
11. **Input**: "6C"
    - `a = tohex('6')`: `a = 6`
    - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
    - `b = tohex('C')`: `b = 12`
    - `putchar(a + b)`: `putchar(0x60 + 0x0C)`: Prints 'l'
12. **Input**: "64"
    - `a = tohex('6')`: `a = 6`
    - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
    - `b = tohex('4')`: `b = 4`
    - `putchar(a + b)`: `putchar(0x60 + 0x04)`: Prints 'd'
13. **Input**: "21"
    - `a = tohex('2')`: `a = 2`
    - `a <<= 4`: `a = 2 << 4 = 32` (0x20)
    - `b = tohex('1')`: `b = 1`
    - `putchar(a + b)`: `putchar(0x20 + 0x01)`: Prints '!'
14. **Input**: "0A"
    - `a = tohex('0')`: `a = 0`
    - `a <<= 4`: `a = 0 << 4 = 0` (0x00)
    - `b = tohex('A')`: `b = 10`
    - `putchar(a + b)`: `putchar(0x00 + 0x0A)`: Prints newline '\n'

##### Final Output

The input `48656C6C6F2C20776F726C64210A` is converted to "Hello, world!\n".

```sh
chan@CMA:~/C_Programming/practice$ ./practice
48656C6C6F2C20776F726C64210A
Hello, world!
```

- In fact, the true test of encoding and decoding, we can pump output through both filters and end up with the original data.

#### Updated encoding & decoding program

`practice.h`

```C
int tohex(char c);
int is_hex_input();

void encode();
void decode();
```

`functions.c`

```C
// Function to convert a single character to its hexadecimal value
int tohex(char c){
    // for digits '0' to '9'
    if(c >= '0' && c <= '9'){
        return (c - '0');
    }

    // For uppercase letters 'A' to 'F'
    if(c >= 'A' && c <= 'F'){
        return (c - 'A' + 0xA);
    }

    // For lowercase letters 'a' to 'f'
    if(c >= 'a' && c <= 'f'){
        return (c - 'a' + 0xA);
    }

    // Anything else is invalid
    return -1;
}

// function to check if a string is in hex format
int is_hex_input(){
    int ch1 = getchar();
    int ch2 = getchar();
    ungetc(ch2, stdin); // push back second character
    ungetc(ch1, stdin); // push back first character

    // check if both characters are hex digits
    return isxdigit(ch1) && isxdigit(ch2);
}

// Function to encode input to hex
void encode(){
    int ch;

    // read each character and convert it to two hex digits
    while((ch = getchar()) != EOF){
        printf("%02X", ch);
    }
    printf("\n");
}

// function to decode hex input back to original characters
void decode(){
    int ch, a, b;

    // Loop until EOF or invalid hex input
    while(1){
        ch = getchar();
        if(ch == EOF){
            break;
        }


        // Convert the first hex character
        a = tohex(ch);
        if(a<0){
            break;
        }

        // Shift value to upper half of the byte
        a <<= 4;

        // Read the next hex character
        ch = getchar();
        if(ch == EOF){
            break;
        }
        b = tohex(ch);
        if(b < 0){
            break;
        }

        // combine the two hex digits and output the result
        putchar(a + b);
    }

    putchar('\n');
}
```

`practice.c`

```C
int main() {
    // Check if the input is hex-encoded
    if (is_hex_input()) {
        decode();  // If input is hex, decode it
    } else {
        encode();  // Otherwise, encode the input
    }
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/practice$ echo "48656C6C6F2C20776F726C64210A" | ./practice 
Hello, world!

chan@CMA:~/C_Programming/practice$ echo "48656C6C6F2C20776F726C64210A" | ./practice | ./practice
48656C6C6F2C20776F726C64210A0A

```



#### Hex Encode Program

```C
// set this value as a defined constant so that it can be updated easily
#define BYTES_PER_LINE 18

int main(){
    int ch, bytes;
    bytes = 0;
    printf("HEX ENCODE v1.0\n");
    
    while((ch = getchar()) != EOF){
        printf(" %02X", ch);
        bytes++;
        //check for the end of the line
        if(bytes == BYTES_PER_LINE){
            putchar("\n");
            bytes = 0;
        }
    }
    
    printf("\nHEX ENCODE END\n");
    return 0;
}
```

##### Example with Input "Hello, World!"

Let's break down the input "Hello, World!" step by step:

1. **Input**: "H"
   - `ch = 'H'` (ASCII 72)
   - `printf(" %02X", 72)`: Prints " 48"
   - `bytes = 1`
2. **Input**: "e"
   - `ch = 'e'` (ASCII 101)
   - `printf(" %02X", 101)`: Prints " 65"
   - `bytes = 2`
3. **Input**: "l"
   - `ch = 'l'` (ASCII 108)
   - `printf(" %02X", 108)`: Prints " 6C"
   - `bytes = 3`
4. **Input**: "l"
   - `ch = 'l'` (ASCII 108)
   - `printf(" %02X", 108)`: Prints " 6C"
   - `bytes = 4`
5. **Input**: "o"
   - `ch = 'o'` (ASCII 111)
   - `printf(" %02X", 111)`: Prints " 6F"
   - `bytes = 5`
6. **Input**: ","
   - `ch = ','` (ASCII 44)
   - `printf(" %02X", 44)`: Prints " 2C"
   - `bytes = 6`
7. **Input**: " "
   - `ch = ' '` (ASCII 32)
   - `printf(" %02X", 32)`: Prints " 20"
   - `bytes = 7`
8. **Input**: "W"
   - `ch = 'W'` (ASCII 87)
   - `printf(" %02X", 87)`: Prints " 57"
   - `bytes = 8`
9. **Input**: "o"
   - `ch = 'o'` (ASCII 111)
   - `printf(" %02X", 111)`: Prints " 6F"
   - `bytes = 9`
10. **Input**: "r"
    - `ch = 'r'` (ASCII 114)
    - `printf(" %02X", 114)`: Prints " 72"
    - `bytes = 10`
11. **Input**: "l"
    - `ch = 'l'` (ASCII 108)
    - `printf(" %02X", 108)`: Prints " 6C"
    - `bytes = 11`
12. **Input**: "d"
    - `ch = 'd'` (ASCII 100)
    - `printf(" %02X", 100)`: Prints " 64"
    - `bytes = 12`
13. **Input**: "!"
    - `ch = '!'` (ASCII 33)
    - `printf(" %02X", 33)`: Prints " 21"
    - `bytes = 13`
14. **Input**: "\n"
    - `ch = '\n'` (ASCII 10)
    - `printf(" %02X", 10)`: Prints " 0A"
    - `bytes = 14`

Since the input "Hello, World!" has 14 characters, it does not reach the `BYTES_PER_LINE` limit of 18, so no newline is printed within the loop.

##### Final Output

The final output is:

```sh
chan@CMA:~/C_Programming/test$ echo "Hello, World!" | ./final
HEX ENCODE v1.0
 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
HEX ENCODE END

```

This output shows the hexadecimal representation of each character in the input string "Hello, World!" followed by the header and footer messages.



#### Decoding Program

```C
// set this value as a defined constant so that it can be updated easily
#define BYTES_PER_LINE 18

// Calculates the buffer size for the num of bytes times the number of spaces used, plus one for the null character
#define LENGTH (BYTES_PER_LINE * 3 + 1)

int main()
{
    // buffer of size LENGTH to store input lines
    char line[LENGTH];

    // x = index for the buffer
    // ch = to store each char read from input
    // hex - to store the parsed hexadecimal value.
    int x, ch, hex;

    // This pointer holds the return value from the fgets() which is used to determine whether input is valid.
    char *r;

    r = fgets(line, LENGTH, stdin);
    // fgets() returns NULL on invalid input; otherwise, the strncmp() performs an exact comparison on the first line of text vs the required text
    if(r == NULL || strncmp(line, "HEX ENCODE", 10) != 0){
        fprintf(stderr, "Invalid HEX ENCODE data\n");
        exit(1);
    }

    x = 0;

    while((ch = getchar()) != EOF){
        // Stores incoming characters in the buffer
        line[x] = ch;

        // increment the offset
        x++;
        
        // Checks for newline (as the decoded file is formatted) or if the buffer is full
        if(ch == '\n' || x == LENGTH){
            // Replaces the newline with a null character; otherwise, caps the string
            if(line[x-1] == '\n'){
                line[x-1] = '\0';
            }else{
                line[x] = '\0';
            }

            // Checks if the line matches the string "HEX ENCODE END"
            // If true, it breaks out of the loop
            if(strncmp(line, "HEX ENCODE END", 13) == 0){
                break;
            }

            // Parses the string (input line of text), separating its content by spaces
            r = strtok(line, " ");

            // As long as the strtok() returns a non-NULL value, loop
            while(r){
                // Translate the 2-character hex string into an integer value
                sscanf(r, "%02X", &hex);

                // Output the integer value (which can be non-ASCII)
                printf("%c", hex);

                // Keeps scanning the same string
                r = strtok(NULL, " ");
            }
            x = 0;
        }

    }
    
    return 0;
}

```

- The difference between `scanf()` and `sscanf()` is that `scanf()` reads formatted input from the standard input usually from the user while `sscanf()` reads from a string rather than directly from the user input.

`sample.txt`

```
HEX ENCODE v1.0
54 68 69 73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65
20 6F 66 20 68 65 78 20 65 6E 63 6F 64 69 6E 67 20 69
6E 20 61 20 66 6F 72 6D 61 74 74 65 64 20 6D 61 6E 6E
65 72 2E 20 49 20 61 70 70 6C 61 75 64 20 79 6F 75 20
66 6F 72 20 62 65 69 6E 67 20 61 20 6E 65 72 64 20 61
6E 64 20 64 65 63 6F 64 69 6E 67 20 74 68 69 73 20 65
78 61 6D 70 6C 65 2E 0A
HEX ENCODE END
```

```sh
chan@CMA:~/C_Programming/test$ ./final < sample.txt
This is an example of hex encoding in a formatted manner. I applaud you for being a nerd and decoding this example.

chan@CMA:~/C_Programming/test$ echo -e "HEX ENCODE v1.0\n48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A\nHEX ENCODE END" | ./final
Hello, World!
```

##### Test Run Explanation

Let's walk through the test run step by step:

1. **Command**:

   ```sh
   echo -e "HEX ENCODE v1.0\n48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A\nHEX ENCODE END" | ./final
   ```

2. **Input**:

   - The input provided to the program is:

     ```
     HEX ENCODE v1.0
     
     48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
     
     HEX ENCODE END
     ```

3. **Execution**:

   - The program starts and reads the first line using `fgets`.
   - It checks if the first line is "HEX ENCODE v1.0". Since it matches, the program continues.
   - The program initializes `x` to 0 and enters the `while` loop to read characters using `getchar`.

4. **Processing Each Line**:

   - The program reads the characters `48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A` and stores them in the buffer `line`.
   - When it encounters the newline character, it replaces it with a null character and processes the line.
   - It tokenizes the line using `strtok` and parses each token as a hexadecimal value using `sscanf`.
   - The parsed hexadecimal values are:
     - `48` -> `H`
     - `65` -> `e`
     - `6C` -> `l`
     - `6C` -> `l`
     - `6F` -> `o`
     - `2C` -> `,`
     - `20` ->
     - `57` -> `W`
     - `6F` -> `o`
     - `72` -> `r`
     - `6C` -> `l`
     - `64` -> `d`
     - `21` -> `!`
     - `0A` -> `\n`
   - It prints the characters, resulting in "Hello, World!\n".

5. **End of Input**:

   - The program reads the next line "HEX ENCODE END".
   - It checks if the line matches "HEX ENCODE END". Since it matches, the program breaks out of the loop and exits.



#### Adding a wee bit of error-checking

- To help track entry errors, early hex dumps in magazines offered a checksum digit at the end of each orw.
- This checksum is merely the total of all the byte values in the row, sometimes modulo `0x100` to make it look like another two digit hex value.
- When the user typed in the code, they could run the checksum or (their hex decoder program would) to determine whether a mistake was made and which line had to be reread and whether the entire operation had to start all over again.

#### Checksum Program

```C
int main(){
    int hexbytes [] = {
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A
    };

    int x, checksum;

    checksum = 0;
    for(x = 0; x < 10; x++){
        checksum += hexbytes[x];
        printf(" %02X", hexbytes[x]);
    }

    // Output the checksum, but limited to a char-size value
    printf("\nChecksum = %02X\n", checksum% 0x100);
    
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final 
 41 42 43 44 45 46 47 48 49 4A
Checksum = B7

```



```C
// set this value as a defined constant so that it can be updated easily
#define BYTES_PER_LINE 18

// Calculates the buffer size for the num of bytes times the number of spaces used, plus one for the null character
#define LENGTH (BYTES_PER_LINE * 3 + 1)

int main()
{
    // line - of size LENGTH to store input lines
    char line[LENGTH];

    // x - index for the buffer, ch - to store each character read from input, hex - to store the parsed hex value
    int x, ch, hex;

    // checksum - to store the checksum, row - to track the number of rows, b - to monitor the byte count
    int checksum, row, b;

    // version - to store the version number
    // r - to hold the return value from fgets and strtok
    float version;
    char *r;

    // Reads the first line of input using fgets
    r = fgets(line, LENGTH, stdin);

    // checks if the input starts with "HEX ENCODE". if not, it prints an error msg and exits.
    if(r == NULL || strncmp(line, "HEX ENCODE", 10) != 0){
        fprintf(stderr, "Invalid HEX ENCODE data\n");
        exit(1);
    }

    // extracts the version number from the input line using sscanf
    sscanf(line, "HEX ENCODE v%f", &version);

    x = 0;

    row = 0; // track the number of rows
    while((ch = getchar()) != EOF){

        // stores each character in the buffer line
        line[x] = ch;

        // increment index x;
        x++;

        if(ch == '\n' || x == LENGTH){
            // properly terminate line
            if(line[x-1] == '\n'){
                line[x-1] = '\0';
            }else{
                line[x-1] = '\0';
            }

            // stop processing on the last line
            if(strncmp(line, "HEX ENCODE END", 13) == 0){
                break;
            }

            checksum = 0; // reset the checksum
            b = 0; // monitor the byte count

            r = strtok(line, " ");
            while(r){
                // parses each token as a hex value
                sscanf(r, "%02X", &hex);
                
                // if the byte count is < BYTES_PER_LINE
                if(b < BYTES_PER_LINE){
                    checksum += hex;
                    printf("%c", hex);
                    r = strtok(NULL, " ");

                    // increase byte count
                    b++;
                }else{
                    // validate
                    if(hex != (checksum%0x100)){
                        // bad checksum
                        fprintf(stderr, "\nChecksum error at Line %d\n", row);
                        fprintf(stderr, "Unable to decode data\n");
                        exit(1);
                    }

                    break;
                }
            }
            x = 0;
            // next row
            row++;
        }
    }

    // Print the final checksum if there are remaining bytes
    if(b > 0){
        printf(" %02X", checksum % 0x100);
    }

    printf("\nHEX ENCODE END\n");
    
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final < sample.txt
This is an example of hex encoding in a formatted manner. I applaud you for being a nerd and decoding this example.
 BF
HEX ENCODE END

```



#### URL encoding

- Specifically, for a web page address, URL encoding is used when referencing something that may otherwise be misinterpreted by the web server, such as a binary value, embedded web page, spaces, or other sneaky data.
- URL encoding allows this information to be sent as plain text and properly decoded later.
- Though various rules exist regarding this encoding method, the HTML 5 standard defines it as follows:
  - Alphanumeric characters are not translated (0 to 9, A to Z, upper-and lowercase).
  - The characters - (dash), . (period), _ (underscore), and * (asterisk) are retained.
  - Spaces are converted into + (plus) character, though the `%20` code is also used.
  - All other characters are represented as their hexadecimal ASCII value, prefixed with a percent sign.
  - If the data to encode is wider than a byte, such as a Unicode character, it's divided into byte-size values, each a 2-digit hex number prefixed with a percent sign. This final point may not be consistent for all wide-character values.

#### Writing a URL encoder

- The key to success with writing a URL-encoding program, a filter in this incarnation, is to catch the exceptions first.
- Output whatever characters need no translation just as they are.
- Once these items are eliminated, all other characters the program outputs must obey the percent-hexadecimal encoding method.

The following is a standard filter that processes input one character at a time. The four URL encoding exceptions are handled first (`-`, `.` , `_`, `*`) followed by the space.

- The `isalnum()` function weeds out all alphanumeric characters. Anything remaining is output using %-hexadecimal format.

```C
int main()
{
    int ch;

    while((ch = getchar()) != EOF){
        if(ch == '-' || ch == '.' || ch == '_' || ch == '*'){
            putchar(ch);
        }else if(ch == ' '){ // the space is output as a + character
            putchar('+');   
        }else if(isalnum(ch)){ // Alphanumeric characters are output as is
            putchar(ch);
        }else{

            // The %% is required to output a percent sign, followed by a 2-digit hex value, prefixed by a leading zero if necessary
            printf("%%%02X", ch);
        }
    }

    putchar('\n');
    
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
https://c-for-dummies.com/blog/
https%3A%2F%2Fc-for-dummies.com%2Fblog%2F%0A
```

- A few common codes regarding URL:
  - %3A for the colon :
  - %2F for the forward slash, /
  - %3F for the question mark, ?
  - %26 for an ampersand, &



#### Writing a URL decoder

```C
int tohex(int c){
    if(c >= '0' && c <= '9'){
        return (c- '0');
    }
    if(c >= 'A' && c <= 'F'){
        return (c - 'A' + 0xA);
    }   
    if(c >= 'a' && c <= 'f'){
        return (c - 'a' + 0xA);
    }
    return -1;

}
int main()
{
    int ch, a, b;

    while((ch = getchar()) != EOF){

        // checks for the % sign and grabs the next two characters
        if(ch == '%'){
            ch = getchar();
            // Bails on EOF
            if(ch == EOF) break;

            // convert the hex digit to an integer
            a = tohex(ch);

            // Grabs the next character
            ch = getchar();
            if(ch == EOF) break;
            b = tohex(ch);

            // Outputs the proper character value
            putchar((a << 4) + b);
        }else{
            putchar(ch);
        }
    }
    putchar('\n');
    
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
https%3A%2F%2Fc-for-dummies.com%2Fblog%2F%0A
https://c-for-dummies.com/blog/
```

---

## Password generators

### Exercise 6.1

Write a program that brute-force guesses the password "password". Have your code spin through all the letter combinations "aaaaaaaa"  through "zzzzzzzz" until it matches "password".

```C
#include <stdio.h>

/* This function rolls over the digits in the array from 'a' to 'z'. When 'z' is encountered, the column shift back to 'a', but the function is recursively called to the next position left, which is -1 element in the array. A check is made to ensure that the function doesn't attempt to modify array elements < 0. Argument 'c' is the char array. Argument 'pos' is the element position, highest first*/

int flip(char *c, int pos){
    *(c+pos) = *(c+pos) + 1; // increment the letter
    if(*(c+pos) > 'z'){
        *(c+pos) = 'a'; //reset back to a
        if(pos != 0){ // watch the overflow
            if(!flip(c, pos-1)){ // flip the next column's digit
                return 0; // echo down the FALSE return
            }
        }else{
            return 0; // last column, FALSE return
        }
    }
    
    // keep looping
    return 1;
}

int main(){
    char password[] = "password"; // password to guess
    char guess[] = "aaaaaaaa"; // initialized to make it easier
    char *p, *g;
    
    printf("Password cracking...\n");
    
    // do while loop so that the first iteration of guess[] isn't skipped
    do{
        // perform the comparison and exit if true
        // casue strcmp() is slow
        p = password;
        g = guess;
        while(*p){
            // compare each letter
            if(*p == *g){
                p++;
                g++;
            }else{
                break;
            }
            
            // if both characters are null here, the strings match.
            if(*p == '\0' && *g == '\0'){
                printf("Found password '%s'\n", guess);
                break;
            }
    }while(flip(guess, 7));
     return 0;
}


```



### Building a silly random password program

```C
int main()
{
    int x;
    char ch;

    // Makes the password 10 characters long
    const int length = 10;

    srand((unsigned) time(NULL));

    for(x = 0; x < length; x++){
        // Set the range of random values to printable characters
        ch = rand() % ('~' - '!' + 1);
        putchar(ch + '!');
    }
    putchar('\n');
    
    return 0;
}
```

- ```C
  srand((unsigned) time(NULL));
  ```

  - **Purpose**: This line seeds the random number generator used by `rand()`.
  - **Explanation:**
    - `time(NULL)`: Returns the current calendar time as a `time_t` object. If the argument is `NULL`, it returns the current time.
    - `(unsigned)`: Casts the `time_t` value to an `unsigned` integer.
    - `srand()`: Seeds the random number generator with the given seed value. By using the current time, it ensures that the sequence of random numbers generated by `rand()` will be different each time the program runs.

- ```C
  ch = rand() % ('~' - '!' + 1);
  ```

  - **Purpose**: This line generates a random printable ASCII character.
  - **Explanation:**
    - `rand()`: Generates a random integer.
    - `('~' - '!' + 1)` : Calculates the range of printable ASCII characters.
      - `'~'` is the ASCII value for the tilde character (`126`).
      - `'!'` is the ASCII value for the exclamation mark (`33`).
      - The range of printable characters is from `33` to `126`, inclusive. Therefore, the total number of printable characters is `126 - 33 + 1 = 94`.
    - `rand() % 94`: Generates a random integer between `0` and `93` (inclusive).
    - `ch = rand() % 94`: Assigns this random integer to the variable `ch`.

- ```C
  putchar(ch + '!');
  ```

  - **Purpose**: This line converts the random integer to a printable ASCII character and prints it.
  - **Explanation:**
    - `ch + '!'` : Adds the ASCII value of the exclamation mark (`33`) to the random integer `ch`.
      - Since `ch`is a random integer between `0` and `93`, adding `33` shifts it to the range of printable ASCII characters (`33` to `126`).
    - `putchar()`: Prints the resulting character to the standard output.

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
RSvz2YN*VG
```

### Adding conditions to the password program

To improve the silly password program and make it smarter, consider limiting the password's content to the following:

- One uppercase letter
- Six lowercase letters
- One number
- Two symbols

The total number of characters is 10, which is good for a password.

Symbols list : 

```
! @ # $ % * _ -
```

**Exercise 6.2**

Write code that generates a random password limited to the characters listed in this section.

#### Solution #1

```C
#define UPPER 1
#define LOWER 6
#define NUM 1
#define SYM 2

char uppercase(void){
    // Random number between 0 and 25, mapped to 'A' to 'Z'
    return (rand() % 26 + 'A');
}

char lowercase(void){
    // Random number between 0 and 25, mapped to 'a' to 'z'
    return (rand() % 26 + 'a');
}

char number(void){
    // Random number between 0 and 9, mapped to '0' to '9'
    return (rand() % 10 + '0');
}

char symbol(void){
    char s[8] = "!@#$%*_-";
    int r;
    r = rand() % 8;
    return s[r];
}

int main(){
    int x;
    
    // seeds the random number generator with the current time to ensure different sequences of random numbers in each run.
    srand((unsigned) time(NULL));
    
    for(x = 0; x < UPPER; x++){
        putchar(uppercase());
    }
    
    for(x = 0; x < LOWER; x++){
        putchar(lowercase());
    }
    
    for(x = 0; x < NUM; x++){
        putchar(number());
    }
    
    for(x = 0; x < SYM; x++){
        putchar(symbol());
    }
    
    putchar('\n');
    
    return 0;
}
```

- `uppercase()`: Generates a random uppercase letter by mapping a random number between 0 and 25 to the ASCII values of 'A' to 'Z'.
- `lowercase()`: Generates a random lowercase letter by mapping a random number between 0 and 25 to the ASCII values of 'a' to 'z'.
- `number()`: Generates a random digit by mapping a random number between 0 and 9 to the ASCII values of '0' to '9'.
- `symbol()`: Generates a random symbol from a predefined set of symbols.

**Alternative Lowercase function (Work the same way)**

```C
char lowercase(){
    char ch;
    // Calls the uppercase() function to generate a random uppercase letter and assigns it to ch.
    ch = uppercase();
   
    return (ch |= 0x20);
}
```

- The bitwise OR assignment operator (`|=`) is used to set the 6th bit of the ASCII value of `ch`.

- In ASCII, the difference between uppercase and lowercase letters is the 6th bit. For example:
  - 'A' (uppercase) has an ASCII value of 65 (`01000001` in binary).
  - 'a' (lowercase) has an ASCII value of 97 (`01100001` in binary).
- By setting the 6th bit, we convert the uppercase letter to its corresponding lowercase letter.
- `0x20` is the hexadecimal representation of the binary value `00100000`.
- `ch |= 0x20` sets the 6th bit of `ch` to 1, effectively converting it to lowercase.
- The function then returns the modified `ch`.

### Example

Let's see an example with the letter 'A':

1. **Uppercase 'A'**:
   - ASCII value: 65
   - Binary: `01000001`
2. **Bitwise OR with `0x20`**:
   - `0x20` in binary: `00100000`
   - `01000001` (65) OR `00100000` (32) = `01100001` (97)
3. **Result**:
   - ASCII value: 97
   - Character: 'a' (lowercase)

### Example

Let's see an example with the letter 'A':

1. **Uppercase 'A'**:
   - ASCII value: 65
   - Binary: `01000001`
2. **Bitwise OR with `0x20`**:
   - `0x20` in binary: `00100000`
   - `01000001` (65) OR `00100000` (32) = `01100001` (97)
3. **Result**:
   - ASCII value: 97
   - Character: 'a' (lowercase)

**Output**

```sh
chan@CMA:~/C_Programming/test$ ./final
Qengxvq6-*
chan@CMA:~/C_Programming/test$ ./final
Zwznnux9$@
```



#### Solution #2

`hello.c`

```C
void generate_password(){
    char uppercase[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";  // Uppercase letters
    char lowercase[] = "abcdefghijklmnopqrstuvwxyz";  // Lowercase letters
    char digits[] = "0123456789";                     // Digits
    char symbols[] = "!@#$%*_-";
    
    // 1 uppercase, 6 lowercase, 1 digit, 2 symbols (total: 10 characters)
    char password[11];
    
    // Seed the random number generator
    srand(time(NULL));
    
    // Select one random uppercase letter
    password[0] = uppercase[rand() % 26];
    
    // Select six random lowercase letter
    for(i = 1; i <= 6; i++){
        password[i] = lowercase[rand() % 26];
    }
    
    // Select one random digit
    password[7] = digits[rand() % 10];
    
    // Select two random symbols
    password[8] = symbols[rand() % 8];
    password[9] = symbols[rand() % 8];
    
    password[10] = '\0';
    
    printf("Generated password: %s\n", password);
 }
```

`hello.h`

```C
void generate_password();
```



`main.c`

```C
int main(){
    generate_pasword();
    return 0;
}
```



**Output**

```sh
chan@CMA:~/C_Programming/test$ ./final
Generated password: Xsjzgdu4!!
chan@CMA:~/C_Programming/test$ ./final
Generated password: Pwyliha8!-
chan@CMA:~/C_Programming/test$ ./final
Generated password: Lobshhz5-*

```

#### Improving upon the password

- The password pattern of the previous password generating program is predictable.
- A better way to output the random characters is to scramble them.
- For this improvement, the password must be stored in an array as opposed to output directly.

`hello.h`

```C
enum
{
    ERROR_CODE = -1,
    UPPER = 1,
    LOWER = 6,
    NUM = 1,
    SYM = 2,
};

char uppercase(void);
char lowercase(void);
char numbers(void);
char symbols(void);
void scramble(char p[]);

```



`hello.c`

```C
#include "hello.h"

char uppercase(void){
    return (rand() % 26 + 'A');
}
char lowercase(void){
    char ch;
    ch = uppercase();
    return (ch |= 0x20);
}
char numbers(void){
    return (rand() % 10 + '0');
}
char symbols(void){
    char s[8] = "!@#$%*_-";
    int r;
    r = rand() % 8;
    return s[r];
}

void scramble(char p[]){

    // calculates the buffer size
    const int size = UPPER+LOWER+NUM+SYM+1;
    
    // key[] to determine which characters need to be randomized.
    char key[size];
    int x, r;

    // Initialize the array with null characters
    for(x = 0; x < size; x++){
        key[x] = '\0';
    }

    x = 0;
    // Loops until the passed array has been fully processed (minus one for the null character)
    while(x <size - 1){
        // Generate a random value, 0 thru the buffer size 
        r = rand() % (size - 1);

        // Check if position is empty
        // If the random value at element r is a null character, meaning it's unassigned
        if(!key[r]){

            // it copies the original character to its new, random position.
            // places the characters from p[x] into the random position key[r].
            key[r] = p[x];
            
            // Moves to the next character
            x++;
        }
    }


    // Copy the randomized array into the passed array
    for(x=0; x < size; x++){
        p[x] = key[x];
    }
}
```



`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <time.h>
#include <signal.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <pthread.h>
#include <ctype.h>
#include <stdbool.h>
#include "hello.h"

int main()
{
    // Necessary storage for the password, plus one for the null character
    char password[UPPER+LOWER+NUM+SYM+1];
    int x;
	
    // Seeds the randomizer
    srand((unsigned)time(NULL));
	
    x = 0;
    while(x < UPPER){
        password[x++] = uppercase();
    }
    while(x < UPPER+LOWER){
        password[x++] = lowercase();
    }
    while(x < UPPER+LOWER+NUM){
        password[x++] = numbers();
    }
    while(x < UPPER+LOWER+NUM+SYM){
        password[x++] = symbols();
    }

    password[x] = '\0';

    printf("%s\n", password);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
Yrhxsdb1-$
chan@CMA:~/C_Programming/test$ ./final
Jkjqpxv5!*
```

##### Explanation

- The program's output is unchanged, but this incremental step stores the password.

- With the password stored in a buffer, it can be passed to a new function, `scramble()` which randomizes the characters in the buffer.

  - **Purpose**: The function shuffles the characters in the input array `p[]` so that they appear in random order.
  - Mechanism:
    - Uses a temporary array `key[]` to store characters at random positions.
    - Random indices are generated using `rand() % (size - 1)`.
    - The function ensures that each character is placed in a unique position by checking if `key[r]` is empty.
  - **Result**: After the function executes, `p[]` contains the same characters as before but in a randomized order.

  ### Example

  Suppose `p[]` contains the characters: `{'A', 'b', '3', '@', '\0'}`.

  1. **Before Scrambling**:

     ```
     Index: 0 1 2 3 4
     p[]     : A b 3 @ \0
     ```

  2. **Scrambling Process**:

     - Randomly assigns each character to a position in `key[]`.
     - For example:
       - `key[2] = 'A'`
       - `key[0] = 'b'`
       - `key[3] = '3'`
       - `key[1] = '@'`

  3. **After Scrambling**:

     ```
     Index: 0 1 2 3 4
     
     key[]: b @ A 3 \0
     ```

  4. **Copy Back to `p[]`**:

     - `p[]` now contains: `{'b', '@', 'A', '3', '\0'}`.

  ##### Important Notes

  - **Randomness**: The function relies on the `rand()` function to generate random indices. Ensure that the random number generator is properly seeded using `srand()` in your `main()` function.
  - **Null Terminator**: The `size` calculation includes an extra character for the null terminator `'\0'`, which signifies the end of the string.
  - **No Repeats**: By checking if `key[r]` is empty before assigning, the function prevents overwriting characters and ensures all positions are filled exactly once.

  Now if we add our scramble() function to our main function just before the printf() statement:

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <time.h>
#include <signal.h>
#include <arpa/inet.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <pthread.h>
#include <ctype.h>
#include <stdbool.h>
#include "hello.h"

int main()
{
    // Necessary storage for the password, plus one for the null character
    char password[UPPER + LOWER + NUM + SYM + 1];
    int x;

    srand((unsigned)time(NULL));

    x = 0;
    while (x < UPPER)
    {
        password[x++] = uppercase();
    }
    while (x < UPPER + LOWER)
    {
        password[x++] = lowercase();
    }
    while (x < UPPER + LOWER + NUM)
    {
        password[x++] = numbers();
    }
    while (x < UPPER + LOWER + NUM + SYM)
    {
        password[x++] = symbols();
    }

    password[x] = '\0';

    scramble(password);

    printf("%s\n", password);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
g_fiu$wCo9
chan@CMA:~/C_Programming/test$ ./final
3*Wxievkg%
```

Now it is blessedly randomized.

#### Generating random words, Mad Libs style

- To build a random word password generator, we need a routine that spits out random words.
- If they're to be legitimate words, we most likely need some type of list from which to extract the words.
- Writing a word-generating function is a good approach, plus it gives us an opportunity to create a list of words we like.

`hello.h`

```C
const char *add_word(void);
```

`hello.c`

```C
#include <stdlib.h>
#include "hello.h"

const char *add_word(void){
    const char *vocabulary[] = {
        "orange", "grape", "apple", "banana",
        "coffee", "tea", "juice", "beverage",
        "happy", "grumpy", "bashful", "sleepy"};
	
    int r;
    
    // Generate a random value, zero thru the number of elements in the array (minus one)
    r = rand() % (sizeof(vocabulary) / sizeof(char *));
    
    // Returns the random element - the word
    return vocabulary[r];
}
```

`main.c`

```C
// This macro makes the for loop more readable in the main() function
#define repeat(a) for(int x = 0; x < a; x++)

int main(){
    srand((unsigned)time(NULL));
    
    // Outputs three random words
    repeat(3){
        printf("%s ", add_word());
    }
    putchar('\n');
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
sleepy apple sleepy 
chan@CMA:~/C_Programming/test$ ./final
grumpy orange sleepy 
```



#### Mad Libs Style

Mad Libs style is a fun word game format where players fill in blanks with specific types of words (like nouns, adjectives, or verbs) to complete a story without knowing the context. Once all the blanks are filled in, the story is read back, often resulting in funny or absurd sentences because the chosen words rarely fit the narrative in a conventional way.

Here’s how it works:

1. A template story is created with blanks labeled by word types, like **[noun]**, **[adjective]**, or **[verb]**.
2. Players are prompted to fill in each blank with a word matching the specified type, without seeing the full story.
3. After all the blanks are filled, the complete story is revealed, often resulting in hilarious or nonsensical outcomes.

**Example:**

Template:

> "The [adjective] cat jumped over the [noun] and started to [verb] loudly."

Filled in:

> "The *spiky* cat jumped over the *pineapple* and started to *dance* loudly."

Mad Libs is commonly used as a fun party activity, educational tool, or writing exercise to spark creativity and encourage understanding of parts of speech.



The first step in coding a Mad Libs program is crafting several functions along the lines of `add_word()` . 

- We must write one function for each word category as found in a Mad Libs: `add_noun()`, `add_verb()`, and `add_adjective()`.
- Each function is populated with its own `vocabulary[]` array, packed with the corresponding word types: nouns, verbs and adjectives.
- The `main()` function calls each function as required to fill in the blanks for a Mad Libs-like sentence.

`hello.h`

```C
const char *add_noun(void);
const char *add_verb(void);
const char *add_adjective(void);
```



`hello.c`

```C
#include <stdlib.h>
#include "hello.h"

const char *add_noun(void)
{
    const char *vocabulary[] = {
        "couch", "dog", "tree", "eyeball",
        "banana", "necklace", "house", "car",
        "computer", "mountain", "cup", "hair"};
    int r;

    // Generates a random value, zero thru the number of elements in the array (minus one)
    r = rand() % (sizeof(vocabulary) / sizeof(char *));

    // Returns the random element - the word
    return vocabulary[r];
}

const char *add_verb(void)
{
    const char *vocabulary[] = {
        "run", "eat", "burp", "sneeze",
        "cut", "yodel", "cook", "slice"};
    int r;

    r = rand() % (sizeof(vocabulary) / sizeof(char *));
    return vocabulary[r];
}
const char *add_adjective(void)
{
    const char *vocabulary[] = {
        "loud", "big", "soft", "crunchy",
        "smelly", "great", "blue", "tiny",
        "ripe", "hairy"};
    int r;

    r = rand() % (sizeof(vocabulary) / sizeof(char *));

    return vocabulary[r];
}
```



`main.c`

```C
int main(){
    srand((unsigned) time(NULL));
    
    printf("Will you please take the %s %s ", add_adjective(), add_noun());
    printf("and %s the %s?\n", add_verb(), add_noun());
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Will you please take the tiny computer and cook and couch?

chan@CMA:~/C_Programming/test$ ./final
Will you please take the tiny mountain and slice and house?
```



One way to add a richer variety of words to the various functions is to take the code a step further and read words from a vocabulary text file.

`nouns.txt`

```
couch
dog
tree
eyeball
banana
necklace
house
car
computer
mountain
cup
hair
girl
teeth
flagpole
table
mummy
motorcycle
log
Godzilla
```

`adjectives.txt`

```
loud
big
soft
crunchy
smelly
great
blue
tiny
ripe
hairy
pretty
ugly
tall
short
fat
skinny
great
busy
slow
sexy
hungry
rich
poor
```

`verbs.txt`

```
run
eat
burp
sneeze
cut
yodel
cook
slice
pinch
torture
beg
cough
laugh
fly
climb
kick
yell
punch
fight
sit
play
```

- These three separate files will be scanned for random words.

`hello.h`

```C
enum{
    BSIZE = 32,
};

struct term{
    char filename[16];  // A string representing the filename to open
    
    FILE *fp;  // A FILE pointer referencing the open file listed in the filename member
    
    int items;  // The total number of words extracted from the file
    
    char *list_base;  // A block of memory containing pointers referencing each word extracted from the file
}

// arg passed as a pointer to allow the function to modify the struct's members and have the updated data retained.
void build_vocabulary(struct term *t);

// The function doesn't require a pointer as an arg because it doesn't modify the struct's content
char *add_word(struct term t);
```

- If we don't pass `struct term *t` pointer as an argument to the function `build_vocabulary`, any changes are abandoned when the function terminates.
- Because a pointer is passed, structure pointer notation `->` is used within the function.



`hello.c`

**Purpose**: Reads words from a file and stores them in the `list_base` array of the `struct term`.

**Process** of `build_vocabulary(struct term *t)`:

- **Opening the File**:
  - Attempts to open the file specified by `t->filename`.
  - If the file cannot be opened, it prints an error message and exits.
- **Initializing the List**:
  - Allocates initial memory for `t->list_base` to hold pointers to strings (words).
  - Checks if the memory allocation was successful.
- **Reading Words**:
  - Uses a loop to read each line from the file using `fgets`.
  - Allocates memory for each word and copies it into the allocated space.
  - Removes the newline character at the end of each word. This step is required to ensure that the word returned doesn't contain a newline.
  - Stores the pointer to the word in `t->list_base` and increments `t->items`.
  - Confirms that  the `t->list_base` buffer isn't full. If the list becomes full, it reallocates more memory to accommodate additional words.
- **Closing the File**:
  - After all words are read, it closes the file.

```C
void build_vocabulary(struct term *t){
    char buffer[BSIZE]; // Buffer to store each line from the file
    char *r, *entry;
    
    t->fp = fopen(t->filename, "r");
    if(t->fp == NULL){
        fprintf(stderr, "Unable to open file %s\n", t->filename);
        exit(1);
    }
    
    // Allocate initial memory for the list of words
    t->list_base = malloc(sizeof(char *) * 100);
    if(t->list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    t->items = 0;
    
    // Read words from the file until the end is reached
    while(!feof(t->fp)){
        r = fgets(buffer, BSIZE, t->fp);
        if(r == NULL){
            break;
        }
        
        // Allocate memory for the word.
        entry = malloc(sizeof(char) * strlen(buffer) + 1);
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        // Copy the word from the buffer into the allocated space "entry".
        strcpy(entry, buffer);
        r = entry;
        
        // Remove the newline character at the end of the word
        while(*r){
            if(*r == '\n'){
                *r = '\0';
                break;
            }
            r++;
        }
        
        // Add the word to the list
        *(t->list_base + t->items) = entry;
        // increment the word count
        t->items++;
        
        // If the list reaches its current capacity, reallocate more memory
        if(t->items % 100 == 0){
            t->list_base = realloc(t->list_base, sizeof(char *)*(t->items + 100));
            if(t->list_base == NULL){
                fprintf(stderr, "Unable to allocate memory\n");
                exit(1);
            }
        }
    }
    fclose(t->fp);
}

/* Purpose: Select a random word from the vocabulary stored in t.list_base */
char *add_word(struct term t){
    int word;
    
    // Generates a random index within the range of 0 to t.items - 1
    word = rand() % t.items;
    return *(t.list_base + word); // Returns the word at that index from t.list_base
}
```

- At the end of the function, the `items` member of the struct (`t.items`) contains **a count of all the words read from the file**.
- The `list_base` member contains **the addresses for each string stored in memory.**



`main.c`

```C
int main(){
    struct term noun = {"nouns.txt", NULL, 0, NULL};
    struct term verb = {"verbs.txt", NULL, 0, NULL};
    struct term adjectives = {"adjectives.txt", NULL, 0, NULL};
    
    // Build vocabularies by reading words from files
    build_vocabulary(&noun);
    build_vocabulary(&verb);
    build_vocabulary(&adjectives);
    
    srand((unsigned)time(NULL));
    
    printf("Will you please take the %s %s ", add_word(adjective), add_word(noun));
    
    printf("and %s the %s?\n", add_word(verb), add_word(noun));
    
    return 0;
}
```



`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Will you please take the hungry log and fight the Godzilla?

chan@CMA:~/C_Programming/test$ ./final
Will you please take the blue table and cough the mummy?

chan@CMA:~/C_Programming/test$ ./final
Will you please take the pretty necklace and sit the tree?

```



### Building a random word password generator

- We can craft two different types of random word password programs based on the two versions of the Mad Libs programs.
- The first program uses arrays to store a series of random words. 
- For more variety, however, we can use the second code to take advantage of files that store our favorite password words.



`hello.h`

```C
char *number(void);
char *symbol(void);
char *add_word(void);
```

`hello.c`

```C
char *number(void){
    // The static array's contents are retained when the function terminates
    static char n[2];
    n[1] = rand() % 10 + '0'; // Generate a random character, 0 thru 9, storing it as the first element of array n[]
    
    n[1] = '\0';
    return n;
}

char *symbol(void){
    char sym[8] = "!@#$%*_-";
    static char s[2];
    
    s[0] = sym[rand() % 8];
    s[1] = '\0';
    
    return s;
}
char *add_word(void){
    char *vocabulary[] = {
        "Orange", "Grape", "Apple", "Banana", "coffee", "tea", "juice", "beverage",
        "happY", "grumpY", "bashfuL", "sleepY"};
	int r;
    r = rand() % 12;
    return vocabulary[r];
}
```

- The purpose of declaring variables as `static` here is to ensure that the arrays `n` and `s` persist after the functions return.
- This allows us to safely return pointers to these arrays without causing undefined behavior.
- In C, when we declare a variable inside a function as `static`, it has the following properties:
  - **Static Storage Duration**: The variable is allocated when the program starts and remains in memory until the program exits.
  - **Local Scope**: The variable is only accessible within the function where it is declared.
  - **Retains Value Between Calls**: The variable retains its value between multiple calls to the function.

`main.c`

```C
int main(){
    char password[32];
    
    srand((unsigned)time(NULL));
    
    // Initialize the string so that the strcpy() doesn't puke
    password[0] = '\0';
    
    // Copies the first word, appends a number, appends the second word, appends a symbol, appends the final word
    strcpy(password, add_word());
    strcat(password, number());
    strcat(password, add_word());
    strcat(password, symbol());
    strcat(password, add_word());
    
    printf("%s\n", password);
    return 0;
}
```

- It's important to initialize the `password` array as an empty with with the null terminator `\0`, before using `strcat` as `strcat` expects a properly null-terminated string as its destination.
- `strcpy(destination, source)` : Copies the `source` string into the `destination` array, including the null terminator.
- `strcat(destination, source)` : Appends the source string to the end of the `destination` string, starting from the null terminator, and **adds a new null terminator at the end.**

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
happY4sleepY_Orange

chan@CMA:~/C_Programming/test$ ./final
Orange3sleepY%bashfuL

chan@CMA:~/C_Programming/test$ ./final
grumpY0bashfuL$Banana
```



- The  above program can be enhanced by expanding the `vocabulary[]` array in the `add_word()` function.
- Or, devise a system where we have files containing words we like to use in a password like the way the second Mad Libs program works.

`hello.h`

```C
enum{
    BSIZE = 32,
};

struct term{
    char filename[16];
    FILE *fp;
    int items;
    char **list_base;
}

void build_vocabulary(struct term *t);
char *number(void);
char *symbol(void);
char *add_word(void);
```

- `t->list_base` is a dynamically allocated array of pointers to `char`, effectively an array of strings.
- `t->items` is an integer tracking the number of words added to the list.

`hello.c`

```C
void build_vocabulary(struct term *t){
    char buffer[BSIZE];
    char *r, *entry;
    
    t->fp = fopen(t->filename, "r");
    if(t->fp == NULL){
        fprintf(stderr, "Unable to open file %s\n", t->filename);
        exit(1);
    }
    
    t->list_base = malloc(sizeof(char *) * 100);
    
    if(t->list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    t->items = 0;
    while(!feof(!t->fp)){
        r = fgets(buffer, BSIZE, t->fp);
        if(r == NULL){
            break;
        }
        
        entry = malloc(sizeof(char *) * strlen(buffer) + 1);
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        strcpy(entry, buffer);
        r = entry;
        while(*r){
            if(*r == '\n'){
                *r = '\0';
                break;
            }
            r++;
        }
        
        // Adds a new word `entry` to the t->list_base at the current index t->items
        *(t->list_base + t-> items) = entry;
        t->items++;
        if(t->items % 100 == 0){
            t->list_base = realloc(t->list_base, sizeof(char *) * (t->items + 100));
            if(t->list_base == NULL){
                fprintf(stderr, "Unable to allocate memory\n");
                exit(1);
            }
        }
    }
    fclose(t->fp);
}

char *number(void){
    static char n[2];
    n[0] = rand() % 10 + '0';
    n[1] = '\0';
    
    return n;
}

char *symbol(void){
    char sym[8] = "!@#$%*_-";
    static char s[2];
    
    s[0] = sym[rand() % 8];
    s[1] = '\0';
    
    return s;
}

char *add_word(void){
    char *vocabulary[] = {
        "Orange", "Grape", "Apple", "Banana", "coffee", "tea", "juice", "beverage",
        "happY", "grumpY", "bashfuL", "sleepY"};
    int r;
    r = rand() % 12;
    return vocabulary[r];

}

// Ensure that the passed string has at lease one uppercase letter
void check_caps(char *string){
    int found, r, len;
    char *s;
    
    // initial scan
    found = 0;
    s = string;
    while(*s){
        if(isupper(*s)){
            found = 1;
            break;
        }
        s++;
    }
    
    // Exit if the string has a capital letter
    if(found){
        return;
    }
    
    // Make a random letter uppercase
    len = strlen(string);
    s = string;
    while(1){
        r = rand() % len;
        if(islower(*(s+r))){
            *(s+r) = toupper(*(s+r));
            break;
        }
    }
}
```

- `t->list_base + t->items` in `build_vocabulary()`:
  - `t->list_base` is a pointer to the first element of the array (`char **`).
  - By adding `t->items`, we move the pointer ahead by `t->items` positions.
  - This points to the next available slot in the array where we can store the new word.
- **`*(t->list_base + t->items)`**:
  - The `*` operator dereferences the pointer to access the value at that position, which is of type `char *`.
  - This represents the slot in the array where we will store the pointer to the new word (`entry`).
- **`= entry;`**:
  - `entry` is a pointer to a `char` (a string), which we've just read from the file and copied into dynamically allocated memory.
  - We assign `entry` to the dereferenced slot, effectively storing the new word in our vocabulary list.

**Alternative Notation**

The line can also be written using array indexing for clarity:

```C
t->list_base[t->items] = entry;
```

- This notation shows that we are placing `entry` into the `list_base` array at index `t->items`.

`main.c`

```C
int main()
{

    char password[32];
    struct term nouns = {"nouns.txt", NULL, 0, NULL};
    struct term verbs = {"verbs.txt", NULL, 0, NULL};
    struct term adjectives = {"adjectives.txt", NULL, 0, NULL};

    build_vocabulary(&nouns);
    build_vocabulary(&verbs);
    build_vocabulary(&adjectives);

    srand((unsigned)time(NULL));

    password[0] = '\0';

    strcpy(password, add_word());
    strcat(password, number());
    strcat(password, add_word());
    strcat(password, symbol());
    strcat(password, add_word());

    printf("%s\n", password);

    return 0;
}
```



`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Orange2Apple$beverage
chan@CMA:~/C_Programming/test$ ./final
coffee5Apple!beverage
chan@CMA:~/C_Programming/test$ ./final
tea6happY!grumpY

```

---



## Chapter 7 - String utilities

### Understanding the string

- It's important to separate what we believe to be a string from a character array.
- Though all strings are character arrays, not all character arrays are strings.
- For example:

```C
char a[3] = {'c', 'a', 't'};
```

- This statement creates a char array `a[]`.  It contains three characters: c-a-t. This array is not a string.
- The following char array, however, is a string:

```C
char b[4] = {'c', 'a', 't', '\0'};
```

- Array `b[]` contains four characters: c-a-t plus null character.
- This terminating null character makes the array a string.
- It can be processed by any C language string function or output as a string.



To save us time, the C compiler lets us craft strings by enclosing characters in double quotes:

```C
char c[4] = "cat";
```

- Array `c[]` is a string. It consists of four characters, c-a-t plus the null character added automatically by the compiler.



But if we declare  a string like this:

```C
char d[3] = "cat";
```

- The compiler allocates three characters for c-a-t, but none for the null character.
- This declaration might be flagged by the compiler or it might not.
- Either way, the string is malformed, and minus the terminating character, manipulating or outputting the string yields unpredictable and potentially wacky results.



Because the compiler automatically allocates storage for a string, the following declaration format is used most often:

```C
char e[] = "cat";
```

- With empty brackets, the compiler calculates the string's storage and assigns the proper number of elements to the array, including the null character.



#### String Considerations

- When allocating string storage, always add one for the null character. Strings are allocated directly as a char array declaration or via a memory-allocation function such as `malloc()`.
- When using string storage, the final character in storage must be the null character, whether or not the buffer is full.
- The `fgets()` function, often used to read string input, automatically accounts for the null character in its second argument, `size`.
  - So, if we use the value 32 as the `size` argument in an `fgets()` statement, the function stores up to 31 characters before it automatically adds the null character to terminate the input string.
- Without the terminating null character, string functions continuing processing bytes until the next random null character is encountered.
  - The effect could be garbage output or worse a segmentation fault.
- One problem with forgetting the null is that often memory is already packed with null characters.
  - A buffer can overflow, but the random null characters already in memory prevent output from looking bad and from our mistake being detected.
  - Never rely upon null characters sitting in memory.



### Measuring a string

- The `strlen()` counts the number of characters in the string ,with escaped characters counted as a single character.

  - For example, the newline `\n` is a single character, though it occupies two character positions.
  - The tab `\t` is also a single character, though the terminal may translate it into multiple spaces when output.

- The `strlen()` can be used elsewhere in the code to manipulate all characters in the string without violating the terminating null character or double-counting escaped characters.

  - ```C
    #include <stdio.h>
    #include <string.h>
    
    int main() {
        char str[] = "Hello, World!";
        size_t len = strlen(str);
    
        printf("Length of the string: %zu\n", len);
    
        // Manipulate characters in the string
        for (size_t i = 0; i < len; i++) {
            if (str[i] == 'o') {
                str[i] = '0';
            }
        }
    
        printf("Modified string: %s\n", str);
    
        return 0;
    }
    ```

- If we want to include the null character in the string's size, we can use the `sizeof` operator, but this trick only works on statically allocated strings (otherwise, the pointer size is returned).

  - The `sizeof` operator returns the size of the array, including the terminating null character. This works for statically allocated strings. For dynamically allocated strings, `sizeof` returns the size of the pointer.

  - ```C
    #include <stdio.h>
    
    int main() {
        char static_str[] = "Hello, World!";
        char *dynamic_str = "Hello, World!";
    
        // Size of statically allocated string (includes null character)
        size_t static_size = sizeof(static_str);
    
        // Size of dynamically allocated string (size of pointer)
        size_t dynamic_size = sizeof(dynamic_str);
    
        printf("Size of static string (including null character): %zu\n", static_size);
        printf("Size of dynamic string (pointer size): %zu\n", dynamic_size);
    
        return 0;
    }
    ```

  - ```sh
    chan@CMA:~/C_Programming/test$ ./final
    
    Size of static string (including null character): 14
    Size of dynamic string (pointer size): 8
    
    ```



In the following code snippets, a comparison is made between values returned by `strlen()` and `sizeof`.

- A string `s[]` is declared which contains 10 characters.

```C
int main(){
    char s[] = "0123456789";
    
    printf("%s is %lu characters long\n", s, strlen(s));
    printf("%s occupies %zu bytes of storage\n", s, sizeof(s));
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
0123456789 is 10 characters long
0123456789 occupies 11 bytes of storage
```

- The `strlen()` function returns the number of characters in the string.
- The `sizeof` returns the amount of storage the string occpies - essentially `strlen() + 1` though, if the string is smaller than its allocated buffer size, `sizeof` returns the buffer size and not `strlen() + 1`.



If we make this change to `s[]` in the code:

```C
char s[20] = "0123456789";
```

```sh
chan@CMA:~/C_Programming/test$ ./final
0123456789 is 10 characters long
0123456789 occupies 20 bytes of storage

```

- Despite the larger buffer size, the null character still sits at element 10 (the 11th character) in the `s[]` array.
- The remainder of the buffer is considered garbage but is still reported as the string's "size" by the `sizeof` operator.



In the following code snippet, empty `a[]` and null `b[]` are tested whether the compiler notices the difference between a null string or an empty string.

- The `strcmp()` is used, which returns zero when both strings are identical.

```C
int main()
{

    char a[5] = {'\0'};
    char b[5];

    if (strcmp(a, b) == 0)
    {
        puts("Strings the the same");
    }
    else
    {
        puts("Strings are not the same");
    }

    // Size according to strlen()
    printf("Length: a = %lu b = %lu\n", strlen(a), strlen(b));

    // Size according to sizeof
    printf("Storage: a = %zu b = %zu\n", sizeof(a), sizeof(b));

    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
Strings are not the same
Length: a = 0 b = 4
Storage: a = 5 b = 5

```

- There's always a random chance that the garbage in memory for string `b[]` may match up with the contents of string `a[]`. 
- Therefore, even this output can't truly be trusted.
- Why does `strlen(b)` return the value 4?
- It's completely legitimate in C to have a string that contains only the terminating null character: such a string's length is zero.
- It can be manipulated by all string functions.



### Returning vs. Modifying directly

- Functions that manipulate strings in C have two ways they can make their changes.
- The first is to return a modified version of the string.
- The second is to manipulate the passed string directly.

For example, the `strcat()` function appends one string to another.

```C
char *strcat(char *dest, const char *src);
```

- String `src` (source) is appended to the end of string `dest` (destination).
- The function assumes enough room is available in the `dest` buffer to successfully append the string.
- Upon success, string `dest` contains both `dest` plus `src`.
- The function returns a pointer to `dest`. 
- The `strcat()` function is an example of manipulating a passed string directly.

```C
char *strappend(char *dest, const char *src){
    return strcat(dest, src);
}

int main(){
     // Array s1[] contains enough storage for both strings
    char s1[32] = "This is another ";
    char s2[] = "fine mess!";
    
    // Pointer to hold the result of the concatenation
    char *s3;
	
    // Append s2 to s1 and store the result in s3
    s3 = strappend(s1, s2);
    printf("%s\n", s3);

    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
This is another fine mess!
```



**Exercise 7.1**

Modify the source code for the above code snippet. Remove the `strcat()` function from the code, replacing it with your own code that sticks the contents of argument `src` to the end of argument `dest`. Do not use the `strcat()` function to accomplish this task! Instead, determine the size of the resulting string and allocate storage for it. The `strappend()` function returns the address of the created string.



**1st Solution**

`main.c`

```C
char *strappend(char *dest, const char *src){
    size_t dest_len = strlen(dest);
    size_t src = strlen(src);
    
    char *result = malloc(sizeof(char *) * (dest_len + src_len + 1));
    
    if(result == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Copy dest to result
    strcpy(result, dest);
    
    // Copy src to the end of result after dest
    strcpy(result + dest_len, src);
    
    return result;
}

int main(){
    char s1[32] = "This is another ";
    char s2[] = "fine mess!";
    char *s3;
    
    s3 = strappend(s1, s2);
    printf("%s\n", s3);
    
    free(s3);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
This is another fine mess!

```



**2nd Solution**

```C
char *strappend(char *dest, char *src){
    char *s, *index;
    
    s = malloc(strlen(dest) + strlen(src) + 1);
    if(s == NULL){
        fprintf(stderr, "Memory Allocation Failed!\n");
        exit(1);
    }
    
    // Pointer to traverse the new string
    index = s;
    
    // Copy dest to the new string
    while(*dest){  //Loop until \0 
        *index = *dest;
        index++;
        dest++;
    }
    
    // Copy src to the end of the new string
    while(*src){
        *index = *src;
        index++;
        src++;
    }
    
    // Null-terminate the new string
    *index = '\0';
    
    return s;
}

int main(){
    char s1[32] = "This is another ";
    char s2[] = "fine mess!";
    char *s3;
    
    s3 = strappend(s1, s2);
    printf("%s\n", s3);
    
    free(s3);
    return 0;
}

```

**Notes**

- `index = s` is an assignment where `index` is set to point to the same memory location as `s`. 
  - This allows us to use `index` to traverse and modify the newly allocated memory without losing the original starting address stored in `s`.
- We return `s` because it holds the address of the newly allocated memory where the concatenated string is stored.
  - If we were to return `index`, it would point to the end of the string after the copying operations, which is not useful.
- `*index = *s` would be incorrect in this context because `*index` and `*s` are dereferencing the pointers, meaning they access the values stored at the memory locations pointed to by `index` and `s`.
  - We want to assign the pointer itself, not the value it points to.
- Condition `while(*dest)`:
  - `*dest` dereferences the pointer `dest` to get the character it points to.
- `*index = *dest`: This line copies the character from the memory location pointed to by `dest` to the memory location pointed to by `index`.
- **Pointer Arithmetic vs. Dereferencing**
  1. **Pointer Arithmetic**:
     - `index++` increments the pointer `index` to point to the next memory location.
     - `dest++` increments the pointer `dest` to point to the next character in the string.
  2. **Deferencing and Incrementing**:
     - `*index++` increments the pointer `index` and then dereferences the new address. This is equivalent to `*(index++)`.
     - `*dest++` increments the pointer `dest` and dereferences the new address. This is equivalent to `*(dest++)`.
- **Why Not Use `*index++`** or `*dest++` In this case?
  - **Correct Usage**: We want to increment the pointers themselves to move to the next character in the string, not the values they point to.
  - **Clarity**: Using `index++` and `dest++` makes it clear that we are moving the pointers to the next position.
  - Using `*index++` or `*dest++` would increment the pointers and then dereference the new address which is not what we want in this context.

```sh
chan@CMA:~/C_Programming/test$ ./final
This is another fine mess!

```



### Changing Case

Changing the 5th bit (counting from 0)  of an ASCII character converts it between uppercase and lowercase.

- **Explanation:**

  - In ASCII, the uppercase letters 'A' to 'Z' have values from 65 to 90.
  - The lowercase letters 'a' to 'z' have values from 97 to 122.
  - The difference between the uppercase and lowercase letters is 32, which corresponds to the 5th bit (0x20 in hexadecimal).

- **Example:**

  - 'A' (65 in decimal) is `01000001` in binary.

  - 'a' (97 in decimal) is `01100001` in binary.

  - The difference is the 5th bit (0x20).



```C
void strupper(char *s){
    // Loops until *s references the null character
    while(*s){
        
        // Converts only lowercase letters
        if(*s >= 'a' && *s <= 'z'){
            // Resets the sixth bit(count from 1) to convert to uppercase
            *s &= 0xdf;
        }
        
        // Proceed to the next character
        s++;
    }
}

int main(){
    char string[] = "Random STRING sample 123@#$";
    printf("Original string: %s\n", string);
    strupper(string);
    printf("Uppercase string: %s\n", string);
    
    return 0;
}
```

- 

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: Random STRING sample 123@#$
Uppercase string: RANDOM STRING SAMPLE 123@#$

```

**Notes**:

- `0xdf`: The hexadecimal value `0xdf` is `11011111` in binary. Using the bitwise AND operator (`&`), this clears the 5th bit of the character effectively converting it to uppercase.
- `char *s` in `void strupper(char *s)` is a pointer to a character, which means ***it points to the first character of the string.***
- `*s` inside the code: This deferences the pointer `s` , giving us the value of the characters it points to.



Due to the layout of the ASCII table, the following statement also works:

```C
*s -= 32; 
```

- Subtracting 32 from each character's ASCII value also converts it to lowercase.

Let's modify our `strupper()` function to create a function that converts characters to lowercase.

```C
void strlower(char *s){
    while(*s){
        if(*s >= 'A' && *s <= 'Z'){
            *s += 32;
        }
        s++;
    }
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: Random STRING sample 123@#$
Uppercase string: random string sample 123@#$

```



**Exercise 7.2**

Write a function, `strcaps()` that capitalizes the first letter of every word in a string. Process the text "This is a sample string" or a similar string that contains several words written in lowercase, including at least one one-letter word. The function modifies the string directly as opposed to generating a new string.



**Solution**

`main.c`

```C
void strcaps(char *s){
    int i = 0;
    
    // Capitalize the first letter
    if(s[0] >= 'a' && s[0] <= 'z'){
        s[0] -= 32;
    }
    
    // Process the rest of the string
    while(s[i] != '\0'){
        // If current character is space and the next character is a letter
        if(s[i] == ' ' && s[i+1] >= 'a' && s[i+1] <= 'z'){
            s[i+1] -= 32; // Convert the next character to uppercase
        }
        i++;
    }
}

int main()
{

    char string[] = "This is a sample string";

    printf("Original string: %s\n", string);
    strcaps(string);
    printf("Uppercase string: %s\n", string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string
Uppercase string: This Is A Sample String
```

**Solution by the author**

`main.c`

```C
void strcaps{
    // Create TRUE/FALSE constants, 0 and 1
    enum{FALSE, TRUE};
    int inword = FALSE;
    
    // Loop thru the string until *s == '\0'
    while(*s){
        if(isalpha(*s)){
            // is a word being processed? If no, a new word has started
            if(!inword){
                *s = toupper(*s);
            	inword = TRUE; // currently inside a word
            }
        }else{ // non-alphabet char here
            inword = FALSE; // not in a word
        }
        s++; // Continue processing the string
    }
}

int main()
{

    char string[] = "This is a sample string";

    printf("Original string: %s\n", string);
    strcaps(string);
    printf("Uppercase string: %s\n", string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string
Uppercase string: This Is A Sample String
```



### Reversing a string

- The key to changing the order of characters in a string is knowing the string's length - where it starts and where it ends.
- For the string's start, the string's variable name is used, which holds the base address.
- The string's ending address isn't stored anywhere; the code must find the string's terminating null character and then use math to calculate the string's size.

![Screenshot from 2024-11-09 15-14-43](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-09 15-14-43.png)

- Figure 7.1 illustrates a string lounging in memory, with both array and pointer notation calling out some of its parts.

- The terminating null character marks the end of the string ,wherever its location may be, measured as offset `n` from the string's start.

- The easiest way to locate the end of a string is to use the `strlen()` function.

  - Add the function's return value to the string's starting location in memory to find the string's end.

- Assume that the `char` pointer `s` references the string's start and that int variable `len` is initialized to zero. 

- If so, this `while` loop locates the string's end where the null character dwells:

  ```C
  while(*s++){
      len++;
  }
  ```

- After this loop is complete, pointer `*s` references the string's terminating null-character, and the value of `len` is equal to the string's length (minus the null character).

- A more readable version of the loop:

  ```C
  while(*s != '\0'){
      len++;
      s++;
  }
  ```

​	

```C
#include <stdio.h>

int main() {
    char str[] = "Hello, World!";
    char *s = str; // Pointer s references the start of the string
    int len = 0; // Initialize len to zero

    // Loop to count the length of the string
    while (*s++) {
        len++;
    }

    // After the loop, s points to the null character
    printf("Length of the string: %d\n", len); // Print the length of the string

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Length of the string: 13
```



- The stupidest way to find the end of a string is to use the `sizeof` operator.
- The operator is not dumb, but when used on a `char` pointer argument, `sizeof` returns the number of bytes the pointer (memory address variable) occupies, not the size of the buffer the pointer references.
- For example, on my computer, a pointer is 8 bytes wide, so no matter what size buffer `*s` refers to, `sizeof(s)` always returns 8.

```C
#include <stdio.h>

int main() {
    char str[] = "Hello, World!";
    char *s = str; // Pointer s references the start of the string

    // Using sizeof on a char pointer
    printf("Size of pointer s: %zu bytes\n", sizeof(s)); // Print the size of the pointer

    // Using sizeof on the actual array
    printf("Size of array str: %zu bytes\n", sizeof(str)); // Print the size of the array

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Size of pointer s: 8 bytes
Size of array str: 14 bytes
```

**Explanation:**

- `char *s = str;` : The pointer `s` references the start of the string `str`.
- `sizeof(s)` : When used on a `char` pointer, `sizeof` returns the size of the pointer itself, not the size of the string it points to.
  - On most systems, this is typically 4 bytes (on a 32-bit system) or 8 bytes (on a 64-bit system).
- `sizeof(str)`: When used on the actual array `str`, `sizeof` returns the total size of the array, including the null character.
  - For the string "Hello, World!", this would be 14 bytes (13 characters + 1 null character).



After obtaining the string's length, the reversing process works backgrounds through the string, copying each character into another buffer, front to back.

- The result is a new string containing the reverse character order of the original.



`hello.h`

```C
char *strrev(char *s);
```

`hello.c`

```C
char *strrev(char *s){
    int len, i;
    char *reversed;
    
    len = 0;
    while(*s){
        len++;
        s++;
    }
    
    // Allocate storage for the reversed string
    // same length as the passed string
    reversed = malloc(sizeof(char) * len);
    
    if(reversed == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Move the pointer s back to the last char of the original string from the null character
    s--;
    i = 0;
    
    // Copies the number of characters from the original string to the reversed string in reverse order
    while(len){
        
        // Copies the character
        *(reversed + i) = *s;
        i++;
        
        // Decrement the offset for the original string & back up the pointer s
        len--;
        s--;
    }
    
    // caps a newly constructed string with the null character!
    *(reversed + i) = '\0';
    
    return reversed;
}
```

- The `strrev()` creates a new string, `reversed`.
- First, a `while` loop calculates the string's size (argument *s).
- Second, storage is allocated for the new string based on the original string's size.
- We don't need to +1 in the `malloc()` to make room for the null character because variable `len` already references the null character's offset.
- Finally, a `while` loop process string `s` backward as it fills string `reversed` with characters.

`main.c`

```C
int main()
{
    char str[] = "A string dwelling in memory";
    printf("Before: %s\n", str);
    printf("After: %s\n", strrev(str));
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Before: A string dwelling in memory
After: yromem ni gnillewd gnirts A
```



#### Reversing a string (Iterative Method)

- Uses two pointers (start and end)
- Swaps characters from both ends moving towards the center
- More space-efficient as it doesn't use the call stack
- Generally preferred in practice

`main.c`

```C
void strrev(char *str){
    int length = strlen(str);
    int start = 0;
    int end = length - 1;
    char temp;
    
    // Loop to reverse the string
    while(start < end){
        // Swaping characters at start and end indices
        temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        
        // Move towards the middle of the string
        start++;
        end--;
    }
}
```

**Walkthrough**:

- **Initial State**:

  - `str = "This is a sample string 123@#!"`
  - `start = 0`, `end = 29`
  - Characters to swap: `str[0] = 'T'` and `str[29] = '!'`

- **First Swap**:

  - Swap `str[0]` and `str[29]`
  - `temp = str[0]` (temp = 'T')
  - `str[0] = str[29]` (str[0] = '!')
  - `str[29] = temp` (str[29] = 'T')
  - Increment `start` to `1`, decrement `end` to `28`
  - `str = "!his is a sample string 123@#T"`

- **Second Swap**:

  - Swap `str[1]` and `str[28]`
  - `temp = str[1]` (temp = 'h')
  - `str[1] = str[28]` (str[1] = '#')
  - `str[28] = temp` (str[28] = 'h')
  - Increment `start` to `2`, decrement `end` to `27`
  - `str = "!#is is a sample string 123@hT"`

- ...And so on until start is less than the end.

- **Final State:**

  - `str = "!#@321 gnirts a elpmas a sihT"`
  - `start = 15`, `end = 14`

  At this point, the `start` index is greater than the `end` index, so the loop terminates. The string has been successfully reversed.

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string 123@#!
Reversed string: !#@321 gnirts elpmas a si sihT

```

#### Reversing a string (Recursive Method):

- More elegant but uses more memory due to recursive calls
- Needs start and end indices as parameters
- Base case is when start >= end

`main.c`

```C
void strrev_recursive(char *str, int start, int end){
    char temp;
    
    // Base case
    if(start >= end){
        return;
    }
    
    // Swap characters
    temp = str[start];
    str[start] = str[end];
    str[end] = temp;
    
    // Recursive call for remaining characters
    strrev_recursive(str, start + 1, end - 1);
}

int main(){
    char str[] = "This is a sample string 123@#!";
    printf("Original string: %s\n", str);
    strrev_recursive(str, 0, strlen(str) - 1);
    printf("Reversed string (recursive): %s\n", str);
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
Original string: This is a sample string 123@#!
Reversed string (recursive): !#@321 gnirts elpmas a si sihT
```



###### Things to Note:

Both methods:

- Modify the string in place
- Don't create a new string
- Handle strings of any length
- Are time complexity O(n/2) which simplifies to O(n).

The iterative method is generally preferred because:

1. It is more efficient in terms of space complexity
2. It avoids stack overflow for very long strings
3. It's easier to understand and debug



### Trimming a string

**Extracting portions of a string: left, middle and right**

| Left      | Mid      | Right                |
| --------- | -------- | -------------------- |
| Slice me, | dice me, | make julienne fries! |



- Each function requires at least two arguments: 
  - A string to slice and
  - A character count.
- The middle extraction function also requires an offset.



`left() function`

The following function:

- Extracts `len` characters from the passed string `s`.
- Storage is allocated for a new string.
- The `left()` is easier to code because it copies the first `len` characters of the passed string `s` into the target string `buf`.
- The address of `buf` is returned.

```C
char *left(char *s, int len){
    // storage for the new string
    char *buf;
    int x;
    
    buf = malloc(sizeof(char) * len + 1);
    if(buf == NULL){
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    // Copy the len characters
    // *(s+x) = s[x], *(buf+x) = buf[x]
    for(x = 0; x < len; x++){
        if(*(s+x) == '\0'){
            break;
        }
        
        // copy the charactes to buf
        *(buf+x) = *(s+x);
    }
    
    return buf;
}
```



`right() function`

- Unlike the `left()` function, chopping off the right side of a string requires that the program knows where the string ends.
- Our code must hunt down that terminating null character.
- For the `right()` function, we count backward from the null character to lop off the right side of the string.
- The following function:
  - Borrows its allocation routine from the `left()` function.
  - After the buffer is created, the code hunts for the end of the string, moving the pointer `start` to this location.
  - Then the value of `len` is subtracted from `start` to reposition the pointer to the beginning of the right-end string chunk desired.
  - Then `len` number of characters are copied into the new string.

```C
char *right(char *s, int len){
    char *buf;
    char *start;
    int x;
    
    buf = (char *)malloc(sizeof(char) * len + 1);
    if(buf == NULL){
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    // Initialize start to the beginning of the string
    start = s;
    
    // Move start to the end of the string
    while(*start != '\0'){
        start++;
    }
    
    // Move start back by 'len' characters
    start -= len;
    
    // Check if start is before the beginning of the string
    if(start < s){
        // Exit if len > the length of the string
        exit(1);
    }
    
    // Copy len characters from start to buf
    for(x = 0; x < len; x++){
        *(buf + x) = *(start + x); // same as buf[x] = start[x]
    }
    
    *(buf + x) = '\0';
    
    return buf;
}
```

**Visualization**:

Let's visualize the process with the example string `"Slice me, dice me, make julienne fries!"` and `len = 20`.

1. **Initial State**:
   - `str = "Slice me, dice me, make julienne fries!"`
   - `len = 20`
2. **Find the End of the String**:
   - `start` moves to the end of the string (points to the null character).
3. **Move Back by `len` Characters**:
   - `start` moves back by 20 characters.
   - `start` now points to the character `'m'` in `"make julienne fries!"`.
4. **Copy Characters**:
   - Copy the characters from `start` to `buf`.
   - `buf` will contain `"make julienne fries!"`.
5. **Result**:
   - The rightmost 20 characters are `"make julienne fries!"`.

By following these steps, the function correctly extracts the rightmost `len` characters from the input string.

![Screenshot from 2024-11-10 22-06-37](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-10 22-06-37.png)

`mid() function`

- The `mid()` function has three arguments:

  - ```C
    char *mid(char *s, int offset, int len);
    ```

  - Pointer `s` references the string to slice.

  - Integer `offset` is the character position to start extraction.

  - Integer `len` is the number of characters to extract.

- The `mid()` function performs a straight character-by-character copy from the passed string `s` into the new string buffer `buf`.

- The key is adding the `offset` value when passing the characters:

  - ```C
    *(buf + x) = *(s + offset - 1 + x);
    ```

  - The `offset` value must be reduced by 1 to account for the fact that characters in the string start at offset 0, not offset 1.

```C
char *mid(char *s, int offset, int len){
    char *buf;
    int x;
    
    buf = (char *)malloc(sizeof(char) * len + 1);
    if(buf == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    for(x = 0; x < len; x++){
        *(buf + x) = *(s + offset - 1 + x);
        if(*(buf + x) == '\0'){
            break;
        }
    }
    
    *(buf + x) = '\0';
    
    return buf;
}
```

**Visualization**

Let's visualize the process with the example string `"Slice me, dice me, make julienne fries!"`, `offset = 11`, and `len = 7`.

1. **Initial State**:
   - `str = "Slice me, dice me, make julienne fries!"`
   - `offset = 11`
   - `len = 7`
2. **Memory Allocation**:
   - Allocate memory for 7 characters plus one for the null terminator.
3. **Copy Characters**:
   - Start copying from `str + offset - 1` (which is `str + 10` or `str[10]`).
   - Copy 7 characters from the original string to the buffer.
4. **Characters Copied**:
   - Characters copied: `"dice me"`
   - Buffer after copying: `"dice me"`
5. **Result**:
   - The substring starting at offset 11 and of length 7 is `"dice me"`.



![Screenshot from 2024-11-10 22-25-39](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-10 22-25-39.png)



**Combined Version**

`hello.h`

```C
char *left(char *s, int len);
char *right(char *s, int len);
char *mid(char *s, int offset, int len);
```

`hello.c`

```C
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include "hello.h"
char *left(char *s, int len)
{
    char *buf;
    int x;

    buf = (char *)malloc(sizeof(char) * len + 1);
    if (buf == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    for (x = 0; x < len; x++)
    {
        if (*(s + x) == '\0')
        {
            break;
        }

        *(buf + x) = *(s + x);
    }
	*(buf + x) = '\0';
    return buf;
}
char *right(char *s, int len)
{
    char *buf;
    char *start;
    int x;

    buf = (char *)malloc(sizeof(char) * len + 1);
    if (buf == NULL)
    {
        fprintf(stderr, "Memory allocation error\n");
        exit(1);
    }
    
	// Initialize start to the beginning of the string
    start = s;
    
    // Move start to the end of the string
    while(*start != '\0'){
        start++;
    }
    
    // Move start back by 'len' characters
    start -= len;
    
    // Check if start is before the beginning of the string
    if(start < s){
        // Exit if len > the length of the string
        exit(1);
    }
    
    // Copy len characters from start to buf
    for(x = 0; x < len; x++){
        *(buf + x) = *(start + x); // same as buf[x] = start[x]
    }
    
    *(buf + x) = '\0';
    
    return buf;
}

char *mid(char *s, int offset, int len)
{
    char *buf;
    int x;

    buf = (char *)malloc(sizeof(char) * len + 1);
    if (buf == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    for (x = 0; x < len; x++)
    {
        // The offset value is decreased by 1 because the first character is offset 0, not offset 1.
        // We will copy characters starting from offset until length
        // same as buf[x] = s[offset - 1 + x]
        *(buf + x) = *(s + offset - 1 + x);

        if (*(buf + x) == '\0')
        {
            break;
        }
    }

    *(buf + x) = '\0';
    return buf;
}
```

`main.c`

```C
int main()
{
	char string[] = "Slice me, dice me, make Julienne fries!";

	printf("Original string: %s\n",string);
	printf("Left %d characters: %s\n",8,left(string,8));
	printf("Middle %d characters: %s\n",7,mid(string,11,7));
	printf("Right %d characters: %s\n",20,right(string,20));

	return(0);
}
```

`Output`

```C
chan@CMA:~/C_Programming/test$ ./final
Original string: Slice me, dice me, make Julienne fries!
Left 8 characters: Slice me
Middle 7 characters: dice me
Right 20 characters: make Julienne fries!

```



### Difference between `char *s` and `char **s`

`char *s`:

- Single pointer to a character/string
- Points directly to a sequence of characters
- It can point to a single character or first character of a string
- Common use: storing/manipulating single strings

```C
char *s = "Hello";  // Points to string literal
// or
char str[] = "Hello";
char *s = str;      // Points to first character of array
```

`char **s`:

- Pointer to a pointer to character (double pointer)
- It can hold the address of a `char *` (i.e., the address of a pointer to a character), which can be used to represent an **array of strings** or a **2D array of characters**.
- Can point to an array of strings
- Common use: array of strings or dynamic string arrays
- This is commonly used in situations where we need multiple strings, like an array of command-line arguments (`argv` in `main(int argc, char **argv)`).

```C
// Example of char **s:
char *strings[] = {"Hello", "World"};
char **s = strings;  // Points to array of strings

// Accessing elements:
printf("%s\n", s[0]);  // Prints "Hello"
printf("%s\n", s[1]);  // Prints "World"
```

Complete Program Showing Both

```C
#include <stdio.h>

int main() {
    // char *s example
    char *single = "Hello";
    printf("Single pointer:\n");
    printf("%s\n", single);
    
    // char **s example
    char *array[] = {"Hello", "World"};
    char **double_ptr = array;
    
    printf("\nDouble pointer:\n");
    printf("First string: %s\n", double_ptr[0]);
    printf("Second string: %s\n", double_ptr[1]);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Single pointer: 
Hello

Double pointer:
First string: Hello
Second string: World

```

**Key Differences**:

1. Memory Structure:

   - `char *s` : s -> "Hello"
   - `char **s` : s -> ptr -> "Hello" -> ptr -> "World"

2. Common Uses:

   - `char *s` : Single strings
   - `char **s`: Arrays of strings, 2D character arrays

3. Dereferencing:

   - `char *s` : Use `*s` to get a character
   - `char **s` : Use `*s` to get a string, `**s` to get a character.

4. **`char \*s`**: Points to a single string.

   **`char \**s`**: Points to multiple strings or an array of `char *` pointers, each potentially pointing to a different string.

In terms of memory, `char *s` is a single-level pointer, while `char **s` is a double-level pointer, allowing for more complex structures like lists of strings.



### Splitting a string

To write a string-splitting function in C with fewer than 20 lines of code, we need to pass at least 4 arguments:

```C
int strsplit(char *org, int offset, char **s1, char **s2);
```

- Pointer `org` references the string to split.
- Integer `offset` is the location of the split.
- The last two pointers, `s1` and `s2` contains two sides of the split.
  - These pointers are passed by reference, which allows the function to access and modify their contents.



In the following function:

- the size of the original string is obtained and used to allocate storage for `s1` and `s2`.
- Then the `strncpy()` function copies the separate portions of the original string into the separate strings.
- The function returns 1 upon success, and 0 when things foul up.

```C
int strsplit(char *org, int offset, char **s1, char **s2){
    int len;
    
    len = strlen(org);
    
    // If the offset arg is out of range, return zero - error.
    if(offset > len){
        return 0;
    }
    
    // Allocate storage for split string 1, argument s1 dereferenced
    *s1 = malloc(sizeof(char) * offset + 1);
    
    // Allocate storage for split string 2, calcuating the proper size
    *s2 = malloc(sizeof(char) * len - offset + 1);
    if(s1 == NULL || s2 == NULL){
        return 0;
    }
    
    // copy the first offset characters to the first substring
    strncpy(*s1, org, offset);
    (*s1)[offset] = '\0';
    
    // copy the remaining characters to the second substring
    strncpy(*s2, org + offset, len - offset);
    (*s2)[len - offset] = '\0';
    
    return 1;
}

int main(){
    char string[] = "When this baby hits 88 miles per hour";
    
    // Pointers to hold the two substrings
    char *first, *second;
    
    // Variable to hold the result of the split
    int r;
    
    // Split the string at offset 15
    r = strsplit(string, 15, &first, &second);
    
    if(r == 1){
        printf("Split successful\n");
        printf("'%s' split into:\n", string);
        printf("'%s'\n", first); // Print the first substring
        printf("'%s'\n", second); // Print the second substring
    }else{
        puts("The function was unable to split the string");
    }
    
    //Free the allocated memory
    free(first);
    free(second);
    
    return 0;
}
```

- `*s1 = malloc(sizeof(char) * (offset + 1));`: Allocate memory for the first substring, including space for the null terminator. The first string is until the offset.
- `*s2 = malloc(sizeof(char) * (len - offset + 1));`: Allocate memory for the second substring, including space for the null terminator. The second string is the remaining characters based on the offset.

### Visualization

Let's visualize the process with the example string `"When this baby hits 88 miles per hour"` and `offset = 15`.

1. **Original String**:

   string = "When this baby hits 88 miles per hour"

2. **Offset Calculation**:

   - `offset = 15`
   - The string will be split at the 15th character (0-based index).

3. **Memory Allocation**:

   - Allocate memory for the first substring (`"When this baby "`), including space for the null terminator.
   - Allocate memory for the second substring (`"hits 88 miles per hour"`), including space for the null terminator.

4. **Copy Characters**:

   - Copy the first 15 characters to the first substring:

   - ```
     first = "When this baby "
     ```

   - Copy the remaining characters to the second substring:

   - ```
     second = "hits 88 miles per hour"
     ```

```sh
chan@CMA:~/C_Programming/test$ ./final
Split successful
'When this baby hits 88 miles per hour' split into:
'When this baby '
'hits 88 miles per hour'
```



### Inserting one string into another

```c
char *strinsert(char *org, char *ins, int offset);
```

- The function's return value is a newly created string, which avoids the necessity that string `org` be large enough to also accommodate inserting string `ins`.
- Returning the string, that is, creating it within the function, also avoids having to temporarily store the remainder of string `org` for concatenation later.
- In this approach, the new string is built character by character, inserting string `ins` at `offset` characters as the new string is built. `offset` refers to the location where we want to insert the character.
- Rather than use the `strcat()` and `strcpy()`, this version of `strinsert()` function copies characters sequentially from string `org` into a newly created buffer.
- Once the character count is equal to `offset`, characters are copied from string `ins` into the newly created buffer. 
- After that, the count continues from string `org`.

![Screenshot from 2024-11-11 17-16-49](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-11 17-16-49.png)

```C
char *strinsert(char *org, char *ins, int offset){
    char *new;
    int size, index, append;
    
    size = strlen(org) + strlen(ins);
    
    if(offset < 0){
        return NULL;
    }
    
    new = malloc(sizeof(char) * size + 1);
    if(new == NULL){
        fprintf(stderr, "Memory allocation failed\n");
        exit(1);
    }
    
    offset -= 1; // adjust offset to be zero-based
    
    // Indexes to track prograss thru new string
    index = 0;
    
    // Status variable to track whether ins string has been inserted
    append = 0;
    
    // Loop thru the original string
    while(*org){
        // if the current index matches the offset, insert ins 
        if(index == offset){
            while(*ins){
                // copy char from ins to new
                *(new + index) = *ins;
                index++;
                ins++;
            }
            // set append flag to indicate 'ins' has been appended
            append = 1;
        }
        // copy char from 'org' to 'new' to continue building the new string
        *(new + index) = *org;
        index++;
        org++;
    }
    
    // Confirms that a string was inserted; if not, string ins is appended
    if(!append){
        while(*ins){
            *(new + index) = *ins;
            index++;
            ins++;
        }
    }
    *(new + index) = '\0';
    
    return new;
}
```

`main.c`

```C
int main(){
    char s1[] = "Well, this is another mess!";
    char s2[] = "fine ";
    
    printf("Before: %s\n", s1);
    // Insert s2 into s1 at offset 23
    char *result = strinsert(s1, s2, 23);
    printf("After: %s\n", result);
    
    free(result);
    return 0;
}
```



`Output`

- This is the program's output where the string "fine " (plus a space) is inserted into the string "Well, this is another mess!" at offset 23.

```sh
chan@CMA:~/C_Programming/test$ ./final
Before: Well, this is another mess!
After: Well, this is another fine mess!
```



### Counting words in a string

- To solve the puzzle of counting words in a string, we must write code that recognizes when a word starts.

```C
int strwords(char *s){
    
    
    // Create the constants FALSE = 0 and TRUE = 1
    enum{FALSE, TRUE};
    
    // Starts out assuming the code isn't reading inside of a word
    int inword = FALSE;
    int count;
    
    count = 0;
    while(*s){
        if(isalpha(*s)){
            
            // Confirms that a word isn't being processed
            if(!inword){
                count++;
                inword = TRUE;
            }
        }else{
            // For non-alpha char, inword is FALSE
            inword = FALSE;
        }
        s++;
    }
    return count;
}

int main(){
    char string[] = "This is a sample string";
    printf("The string '%s' contains %d words\n", string, strwords(string));
    return (0);
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'This is a sample string' contains 5 words
```



But if we change is to isn't, the output is 

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'This isn't a sample string' contains 6 words
```



**Exercise 7.3**

Modify the `strwords()` function so that it accounts for contractions. 

`main.c`

```C
int strwords(char *s){
    // Create the constants FALSE = 0 and TRUE = 1
    enum{FALSE, TRUE};
    
    // Variable to track if we are inside a word
    int inword = FALSE;
    int count;
    
    count = 0;
    
    // Loop thru the string
    while(*s){
        if(isalpha(*s)){
            // If s is an alphabet & if we are not already in a word
            if(!inword){
                count++;
                inword = TRUE;
            }
        }
        // Check for contractions
        else if(*s == '\'' && isalpha(*(s + 1))){
            // Skip the apostrophe and the following alphabetic characters
            s++;
        }else{
            inword = FALSE; // If the character is not alphabetic, we are not in a word
        }
        s++;
    }
    return count;
}

int main(){
    char string[] = "This is a sample string";
    printf("The string '%s' contains %d words\n", string, strwords(string));
    return (0);
}
```

**Things to Note**:

```C
else if (*s == '\'' && isalpha(*(s + 1)))
```

Check if the character is an apostrophe followed by an alphabetic character.

- `s++`: Skip the apostrophe and the following alphabetic character.

### Visualization

Let's visualize the process with the example string `"This isn't a sample string"`.

1. **Initial State**:

   string = "This isn't a sample string"

2. **Loop Through the String**:

   - `T` is alphabetic, increment word count to 1.
   - `h` is alphabetic, continue.
   - `i` is alphabetic, continue.
   - `s` is alphabetic, continue.
   - ` ` is not alphabetic, set `inword` to `FALSE`. (Space)
   - `i` is alphabetic, increment word count to 2.
   - `s` is alphabetic, continue.
   - `'` is an apostrophe followed by `n`, skip the apostrophe.
   - `n` is alphabetic, continue.
   - `t` is alphabetic, continue.
   - ` ` is not alphabetic, set `inword` to `FALSE`.
   - `a` is alphabetic, increment word count to 3.
   -  ` ` is not alphabetic, set `inword` to `FALSE`. (Space)
   - `s` is alphabetic, increment word count to 4.
   - `a` is alphabetic, continue.
   - `m` is alphabetic, continue.
   - `p` is alphabetic, continue.
   - `l` is alphabetic, continue.
   - `e` is alphabetic, continue.
   -  ` ` is not alphabetic, set `inword` to `FALSE`. (Space)
   - `s` is alphabetic, increment word count to 5.
   - `t` is alphabetic, continue.
   - `r` is alphabetic, continue.
   - `i` is alphabetic, continue.
   - `n` is alphabetic, continue.
   - `g` is alphabetic, continue.

3. **Result**:

   - The string `"This isn't a sample string"` contains 5 words.

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'This isn't a sample string' contains 5 words
```



### Converting tabs to spaces

To set a tab stop, we must know where text output is going across the screen - the current column value. This value is compared with the tab stop width desired, using the following equation:

```C
spaces = tab - (column % tab)
```

![Screenshot from 2024-11-11 20-56-55](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-11 20-56-55.png)

- The `(column % tab)` expression returns the number of spaces since the last tab stop interval (tab) based on the cursor's current column offset (column).
- To obtain the number of spaces until the next tab stop, this value is subtracted from the tab stop width.
- The result is the number of spaces required to line up the next character output with a tab stop.



```C
void strtabs(const char *s, int tab){
    int column, x, spaces;
    
    // The column variable tracks the current column position.
    column = 0;
    
    // Loop thru the string
    while(*s){
        if(*s == '\t'){
            // Calculates the number of spaces to output to line up at the next tab stop
            spaces = tab - (column % tab);
            
            // Output the required spaces
            for(x = 0; x < spaces; x++){
                putchar(' ');
            }
            
            // update the column offset
            column += spaces;
        }else{ // if the character is not a tab
            putchar(*s);
            
            // reset the column if the character is a newline, otherwise increment the column counter
            if(*s == '\n'){
                column = 0;
            }else{
                column++;
            }
        }
        s++;
    }
}

int main()
{
    const char *text[3] = {"Hello\tHi\tHowdy\n", "\tLa\tLa\n", "Constantinople\tConstantinople\n"};
    int x, y;
    
    // Nested loop to output the three sample strings at three different tab stops: 4, 8 and 16 spaces
    for (y = 4; y < 32; y *= 2)
    {
        // Print the current tab width
        printf("Tab width: %d\n", y);
        
        // Loop thru each string in the array
        for (x = 0; x < 3; x++)
        {
            // Replace tabs with spaces in the current strings
            strtabs(text[x], y);
        }
    }

    return (0);
}
```

### Visualization

Let's visualize the process with the example strings and different tab widths.

1. **Initial State**:

   ```C
   text[0] = "Hello\tHi\tHowdy\n"
   
   text[1] = "\tLa\tLa\n"
   
   text[2] = "Constantinople\tConstantinople\n"
   ```

2. **Loop Through Tab Widths**:

   - Tab widths: 4, 8, 16

3. **Tab Width 4**:

   - For `text[0] = "Hello\tHi\tHowdy\n"`:
     - Replace `\t` with spaces to the next tab stop (4 spaces).
     - Result: `"Hello Hi Howdy\n"`
   - For `text[1] = "\tLa\tLa\n"`:
     - Replace `\t` with spaces to the next tab stop (4 spaces).
     - Result: `" La La\n"`
   - For `text[2] = "Constantinople\tConstantinople\n"`:
     - Replace `\t` with spaces to the next tab stop (4 spaces).
     - Result: `"Constantinople Constantinople\n"`

4. **Tab Width 8**:

   - For `text[0] = "Hello\tHi\tHowdy\n"`:
     - Replace `\t` with spaces to the next tab stop (8 spaces).
     - Result: `"Hello Hi Howdy\n"`
   - For `text[1] = "\tLa\tLa\n"`:
     - Replace `\t` with spaces to the next tab stop (8 spaces).
     - Result: `" La La\n"`
   - For `text[2] = "Constantinople\tConstantinople\n"`:
     - Replace `\t` with spaces to the next tab stop (8 spaces).
     - Result: `"Constantinople Constantinople\n"`

5. **Tab Width 16**:

   - For `text[0] = "Hello\tHi\tHowdy\n"`:
     - Replace `\t` with spaces to the next tab stop (16 spaces).
     - Result: `"Hello Hi Howdy\n"`
   - For `text[1] = "\tLa\tLa\n"`:
     - Replace `\t` with spaces to the next tab stop (16 spaces).
     - Result: `" La La\n"`
   - For `text[2] = "Constantinople\tConstantinople\n"`:
     - Replace `\t` with spaces to the next tab stop (16 spaces).
     - Result: `"Constantinople Constantinople\n"`

```sh
chan@CMA:~/C_Programming/test$ ./final
Tab width: 4
Hello   Hi  Howdy
    La  La
Constantinople  Constantinople
Tab width: 8
Hello   Hi      Howdy
        La      La
Constantinople  Constantinople
Tab width: 16
Hello           Hi              Howdy
                La              La
Constantinople  Constantinople

```

- When the terminal window encounters a tab, it doesn't convert the tab into multiple spaces like the program does.
- For the terminal window, the cursor itself moves the required number of character positions across the screen: spaces aren't output.



### A string library

#### Creating a library

- Libraries are created from object code files.
- The `ar` (archive) utility is what transforms the object code file into a library.

```C
ar -rcs libmystring.a mystring.o
```

- -c - Creates the archive
- -s - Indexes the archive
- -r - Inserts file(s) into the archive

Name format that follows the convention used in Linux: `libname.a`.



**How I updated my MakeFile**

```makefile
# Compiler & Standard
CC = clang
STD = -std=c23

# Compiler Flags
CFLAGS = -Wall -Wextra -g -D_XOPEN_SOURCE=700
LIBS = -lssl -lcrypto -lpthread -lm

# Directories
LIBDIR = ./libs
OBJDIR = ./obj

# Targets
all: final

# Final executable
final: $(OBJDIR)/main.o $(LIBDIR)/libhello.a
	@echo "Linking and producing the final application"
	$(CC) $(STD) $(CFLAGS) $(OBJDIR)/main.o -L$(LIBDIR) -lhello -o final $(LIBS)

# Object files
$(OBJDIR)/main.o: main.c hello.h
	@echo "Compiling the main file"
	$(CC) $(STD) $(CFLAGS) -c main.c -o $(OBJDIR)/main.o

$(OBJDIR)/hello.o: hello.c hello.h
	@echo "Compiling the hello file"
	$(CC) $(STD) $(CFLAGS) -c hello.c -o $(OBJDIR)/hello.o

#Static library
$(LIBDIR)/libhello.a: $(OBJDIR)/hello.o
	@echo "Creating static library libhello.a"
	ar -rcs $(LIBDIR)/libhello.a $(OBJDIR)/hello.o

# Clean up
clean:
	@echo "Removing everything except the source files"
	@rm -f ./*.o $(OBJDIR)/*.o $(LIBDIR)/libhello.a final
```

- If we have copied the library into the `/usr/local/lib` folder, the linker searches for it there.
- The `-L` (big L) switch directs the linker to look in a specific directory for library files.



### A Kinda OOP approach

- C is a procedural programming language. 
- Inelegantly put, this description means that C code runs from top to bottom, with one thing happening after another.
- Object-oriented programming (OOP) involves methods instead of functions.
- Methods work like functions, though they are often a part of the data type they manipulate.

For example, in Java,

```Java
Len = Str.length()
```

- The string variable is named `Str`. 
- The dot operator access the `length()` method, which is attached to all string objects.
- The equivalent in C is

```C
len = strlen(str);
```

The dot operator is also used in C, specifically in a structure.

#### Adding a function to a structure

- A structure contains members of specific data types: int, float, char and so on.
- As it turns out, a function is also a data type, and it can serve as a member of a structure.

```C
type (*name) (arguments)
```

- The `type` is a data type, the value returned from the function or `void` for nothing returned.
- The `name` is the function's name, which is secretly a pointer. 
- In this format, the function's name isn't followed by parentheses.
- Instead, the `arguments` item lists any arguments passed to the function.

```C
struct str{
    char *string;
    unsigned long (*length) (const char *);
}
```

- The `str` structure's function member is referenced as the `length`.
  - It takes a `const char` pointer -  a string - as its argument and it returns an `unsigned long` value.
- To make the function member work, it must be assigned to a specific function.
- In this case, `strlen()` is ideal which takes a `const char` pointer as an argument and returns an `unsigned long` value.
- Creating a structure merely defines its members.
- To use the structure, a variable of the structure type is created.
- Here, structure `str` variable `str1` is created:

```C
struct str str1;
```

- And its members must be assigned values. Here is how the `length` member is assigned:

```C
str1.length = &strlen;
```

- The `length` member's function is `strlen()`.
- It is specified without the parentheses, prefixed by the ampersand to obtain its address.
- Once assigned, the function member can be called like any function.

```C
len = str1.length(str1.string);
```

- Member `str1.length` is a function (secretly `strlen()`).
- It operates on the `string` member of the same structure, `str1.string`.
- The value returned, the length of the string, is stored in variable `len`.



`main.c`

```C
int main(){
    struct str{
        char *string;
        unsigned long (*length) (const char *);
    };
    struct str str1;
    char s[] = "Heresy";
    
    // The string member is assigned
    str1.string = s;
    
    // The function is assigned, no parentheses, and prefixed by the address-of operator.
    str1.length = &strlen;
    
    printf("The string '%s' is %lu characters long\n", str1.string, str1.length(str1.string));
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'Heresy' is 6 characters long
```

#### Creating a string "object"

- To create a phony string object, a `string_create()` function is needed. 
- This function is passed a pointer to a `string` structure along with the string's contents (text).

```C
int string_create(struct string *s, char *v);
```

- The pointer is necessary to allow the function to modify the structure directly.
- Without the pointer, any changes made to the passed structure within the function are discarded.
- The string passed, `v`, is eventually incorporated into the structure along with other informative goodies.



`string_create()`

- Returns TRUE or FALSE values depending on whether the object is successfully created.
- The string's length is obtained and stored in the structure's length member. 
- This value is used to allocate storage for the string.

```C
int string_create(struct string*s, char *v){
    // Confirm that a string is available, if not, returns FALSE
    if(s == NULL){
        return FALSE;
    }
    
    s->length = strlen(v);
    
    s-> value = malloc(sizeof(char) * s->length + 1);
    if(s->value == NULL){
        return FALSE;
    }
    
    strcpy(s->value, v);
    
    return TRUE;
}
```



`string_destroy()`

- Just as an object is created, a companion `string_destroy()` function must exist.
- This function removes the object, which means de-allocating the string's storage and zeroing out any other structure members.
- The `string_destroy()` does three things:
  - frees the allocated memory
  - assigns the value pointer to NULL (which confirms that the memory is deallocated).
  - sets the string's length to zero.
- This function does not obliterate the structure variable, unlike OOP languages that may also remove the variable that's created.

```C
void string_destroy(struct string *s){
    free(s->value);
    s->value = NULL;
    s->length = 0;
}
```



Completed program

`hello.h`

```C
enum{
    TRUE,
    FALSE
};

struct string
{
    char *value;
    int length;
};

int string_create(struct string *s, char *v);

void string_destroy(struct string *s);
```

`hello.c`

```C
int string_create(struct string *s, char *v){
    if(s == NULL){
        return FALSE;
    }
    
    s->length = strlen(v);
    s->value = malloc(sizeof(char) * s->length + 1);
    
    if(s->value == NULL){
        return FALSE;
    }
    
    strcpy(s->value, v);
    
    return TRUE;
}

void string_destroy(struct string *s){
    
}
```

`main.c`

```C
int main(){
    struct string str1;
    string_create(&str1, "I am not a string object");
    
    printf("The string '%s' is %d characters long\n", str1.value, str1.length);
    
    string_destroy(&str1);
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
The string 'I am not a string object' is 24 characters long
```

- After destroying a string structure variable, it can be reused or reassigned.
- The point it to have both a create function and a destroy function for the "object" which mimics how some object-oriented programming languages work with objects.

---

## Chapter 8 - Unicode and wide characters



```C
void toMorse(char c){
    // arrays declared as const char to keep the code from otherwise messing with them; this type of construction dislikes being manipulated.
    const char *morse_alpha[] = {
        ".-", "-...", "-.-.", "-..", ".", "..-.",
        "--.", "....", "..", ".---", "-.-", ".-..",
        "--", "-.", "---", ".--.", "--.-", ".-.",
        "...", "-", "..-", "...-", ".--", "-..-",
        "-.--", "--.."};
    const char *morse_digit[] = {
        "-----", ".----", "..---", "...--", "....-",
        ".....", "-....", "--...", "---..", "----."};
	
    // Pulls out alphabetic characters
    if(isalpha(c)){
        c = toupper(c);
        
        // Subtracts the character from 'A' to print the corresponding Morse code for the alphabetic character
        printf("%s ", morse_alpha[c - 'A']);
    }else if(isdigit(c)){ // Checks for digits 0 thru 9
        
        // Subtracts the digit from '0' to print the corresponding Morse code for the digit
        printf("%s ", morse_digit(c - '0'));
    }else if(c == ' ' || c == '\n'){
        putchar('\n');
    }else{
        return;
    }
}

int main(){
    int ch;
    while((ch = getchar()) != EOF){
        toMorse(ch);
    }
    return 0;
}
```

- The `toMorse()` function is easily set into a filter, which translates text input into Morse code strings for output.

### Visualization

Let's visualize the process with the example string `"Hey it's an honor 123"`.

1. **Initial State**:

   ```
   Input: "Hey it's an honor 123"
   ```

   

2. **Character-by-Character Conversion**:

   - `H`: Convert to Morse code `....`
   - `e`: Convert to Morse code `.`
   - `y`: Convert to Morse code `-.--`
   - ``: Print newline to separate words
   - `i`: Convert to Morse code `..`.
   - `t`: Convert to Morse code `-`
   - `'`: Ignore
   - `s`: Convert to Morse code `...`
   - ``: Print newline to separate words
   - `a`: Convert to Morse code `.-`
   - `n`: Convert to Morse code `-.`
   - ``: Print newline to separate words
   - `h`: Convert to Morse code `....`
   - `o`: Convert to Morse code `---`
   - `n`: Convert to Morse code `-.`
   - `o`: Convert to Morse code `---`
   - `r`: Convert to Morse code `.-.`
   - ``: Print newline to separate words
   - `1`: Convert to Morse code `.----`
   - `2`: Convert to Morse code `..---`
   - `3`: Convert to Morse code `...--`

```sh
chan@CMA:~/C_Programming/test$ ./final
Hey it's an honor 123
.... . -.-- 
.. - ... 
.- -. 
.... --- -. --- .-. 
.---- ..--- ...-- 
```



### Understanding Unicode and Wide Characters

1. **Unicode**:
   - Unicode is a standard for encoding text in different writing systems. It assigns a unique code point to each character, regardless of the platform, program, or language.
   - UTF-8 is a variable-width character encoding for Unicode. It can represent any character in the Unicode standard and is backward compatible with ASCII.
2. **Wide Characters**:
   - In C, wide characters are used to represent Unicode characters. They are typically stored in `wchar_t` type variables.
   - Wide character strings are arrays of `wchar_t` and are manipulated using functions from the `<wchar.h>` library.

### Setting the locale

In C, locales are used to define various cultural-specific settings that affect the behavior of certain functions, such as those related to formatting, character classification, and string collation. 

The `setlocale` function is used to set or query the program's current locale.



- A locale is a set of parameters that defines the user's language, country, and any special variant preferences. 
- These parameters affect the behavior of various functions in the C standard library, such as:
  - **Character classification and conversion**: Functions like `isalpha`, `isdigit`, `toupper`, and `tolower` depend on the locale to determine character properties.
  - **String collation and comparison**: Functions like `strcoll` and `strxfrm` use locale-specific rules for comparing and transforming strings.
  - **Date and time formatting**: Functions like `strftime` use locale-specific formats for representing dates and times.
  - **Number formatting**: Functions like `printf` and `scanf` use locale-specific rules for formatting numbers, including decimal points and thousands separators.

```sh
chan@CMA:~/C_Programming/test$ locale
LANG=en_SG.UTF-8
LANGUAGE=en_SG:en
LC_CTYPE="en_SG.UTF-8"
LC_NUMERIC="en_SG.UTF-8"
LC_TIME="en_SG.UTF-8"
LC_COLLATE="en_SG.UTF-8"
LC_MONETARY="en_SG.UTF-8"
LC_MESSAGES="en_SG.UTF-8"
LC_PAPER="en_SG.UTF-8"
LC_NAME="en_SG.UTF-8"
LC_ADDRESS="en_SG.UTF-8"
LC_TELEPHONE="en_SG.UTF-8"
LC_MEASUREMENT="en_SG.UTF-8"
LC_IDENTIFICATION="en_SG.UTF-8"
LC_ALL=
```

- The UTF-8 character format is what allows Unicode text I/O - though to enable UTF-8 in our code, we must use the `setlocale()` function, prototyped in the `locale.h` header file.

```C
char *setlocale(int category, const char *locale);
```

- The first argument, `category` is a defined constant representing which aspect of the locale we want to set. Common categories include:
  - `LC_ALL`: All locale settings.
  - `LC_COLLATE`: String collation (comparison) rules.
  - `LC_CTYPE`: Character classification and conversion.
  - `LC_MONETARY`: Monetary formatting.
  - `LC_NUMERIC`: Number formatting (decimal point, thousands separator).
  - `LC_TIME`: Date and time formatting.
- The second argument is a string to set the specific locale details.
  - For example, for text, we can specify "en_SG.UTF-8" which activates the 8-bit Unicode character set for English. An empty string can also be specified.
  - `""`: The default locale, usually determined by the environment variables.
  - `"C"`: The standard C locale, which is the default locale when a program starts.
  - `"en_US.UTF-8"`, `"fr_FR.UTF-8"`, etc.: Specific locales for different languages and regions.
- The `setlocale()` function returns a string representing the specific information requested.
- If the locale is not supported, it returns `NULL`.
- We need not use the string; setting the locale is good enough for wide character I/O.



The following program uses the `setlocale()` function to output locale details - specifically the character set in use.

- Line 8 uses the `setlocale()` function to return a string describing the current locale, saved in variable `locale`.
- Used in this way, the `setlocale()` function doesn't change the locale settings; it only reports information.

```C
#include <locale.h>

int main(){
    
    // Pointer to a string to retain the function's output
    char *locale;
    
    // Synchronizes the GPU so that the work completes
    locale = setlocale(LC_ALL, "");
    printf("The current locale is %s\n", locale);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
The current locale is en_SG.UTF-8
```



### Exploring character types

To invoke the magic that enables access to Unicode's humongous character set, we must be familiar with the three types of characters used in computerdom:

- Single-byte characters
- Wide characters
- Multi-byte characters



**Single-byte characters**: 

- provide the traditional way to generate text.
- These are 8-bit values, the `char` data type, equal to a single byte of storage.
- Though `char` values range from 0 through 255 (unsigned), only values 0 through 127 are assigned characters using the ASCII standard.



**Wide characters**:

- The wide character data type uses more than 8-bits to encode text.
- The number of bytes can vary, depending on the character.
- In C, the `wchar_t` data type handles wide characters, and the wide character (wchar) family of functions manipulate these characters.



**Multi-byte characters**:

- A multibyte character requires several bytes to represent the character.
- This description includes wide characters but also characters that require a prefix byte, or lead unit, and then another sequence of bytes to represent a single character.
- This type of multibyte character may be used in specific applications and computer platforms.



To represent a single-byte character, we use the `char` data type in C.

```C
char hash = '#';
```

- The hash character is assigned to `char` variable `hash`.
- The character code is 35 decimal, 23 hex.



To represent wide characters, use the `wchar_t` data type.  We must include `wchar.h` header file which also prototypes the various wide character functions.

```C
wchar_t yen = 0xa5;
```

- The Yen character ¥ is U+00a5. 
- The value is assigned to `wchar_t` variable `yen`.



```C
wchar_t yen = L'¥';
```

- The `L` prefix defines the character as long (wide).
- This prefix works like the `L` suffix applied to `long` integer values: `123L` indicates the value `123` specified as a `long int` value.

The `L` prefix is also used to declare a wide character string.

```C
wchar_t howdy[] = L"Hello, planet Earth!";
```

- The string above, "Hello, planet Earth!", is composed of wide characters, thanks to the `L` prefix.
- The `wchar_t` data type declares wide string `howdy`.



As with single characters, we cannot insert special characters into a wide string. The following declaration is flagged as illegal character encoding:

```C
wchar_t monetary[] = L"$¥€₤";
```

- Such a string is instead composed in this manner:

```C
wchar_t monetary[] = {
    0x24, 0xa5, 0x20ac, 0xa3, 0x0
}
```

- Hex values above represent the characters dollar sign, yen, euro, and British pound, followed by the null character caboose to terminate the string.
- To output wide characters and wide strings, use the `wprintf()` function.
  - This function works like the standard library `printf()` function, though it deals with wide strings.
- Special placeholders are used for wide characters and wide strings:
  - The `%lc` placeholder represents a single wide character.
  - The `%ls` placeholder represents a wide string.
- Lowercase `l` in the placeholder identifies the target variable as the wide or `wchar_t` data type.



### Generating wide character output

- To output wide characters in C, we have to employ the functions declared in the `wchar.h` header file, which also conveniently defines the `wchar_t` data type.
- We also need the `locale.h` header file because the wide character functions must be activated by first setting the locale.

```C
#include <wchar.h>

int main(){
    wprintf(L"Hello, wide world!\n");
    return 0;
}
```

- The `setlocale()` function isn't required because the output is ASCII, albeit wide ASCII, which is why the `wprintf()` formatting string is prefixed by an `L` (long, or wide character).

```sh
chan@CMA:~/C_Programming/test$ ./final
Hello, wide world!
```

```C
int main()
{
    wchar_t hello[] = L"Hello, wide world!\n";
    wprintf(L"%ls", hello);
    return (0);
}

```

- The `wchar_t` data type defines array `hello[]` composed of characters present in the wide string.
- If the `L` prefix is omitted, the compiler barfs up a data type mismatch error and the code won't compile.
- To create a wide string, we need both the `wchar_t` data type and the `L` prefix on the text enclosed in double quotes.
- `wprintf(L"%ls", hello)`: The `L` prefix is required for the formatting string, because all wide character functions deal with wide characters. 
  - The `%ls` placeholder represents a string of wide characters.

```sh
chan@CMA:~/C_Programming/test$ ./final
Hello, wide world!
```



To output a single wide character, use the `putwchar()` function. It works like `putchar()`.



The code in the next listing outputs the four playing card suits: spades, hearts, clubs, and diamonds.

- Their unicode values are assigned as elements of the `suits[]` array.
- The `setlocale()` function is required because these are not ASCII characters.
- Within the `for` loop, the `putwchar()` function outputs the characters.
- A final `putwchar()` function outputs a newline - a wide newline.



```C
#include <wchar.h>
#include <locale.h>

int main(){
    const int count = 4;
    
    // Unicode values for four playing card suits
    wchar_t suits[] = {
        0x2660, 0x2665, 0x2663, 0x2666
    };
    
    int x;
    
    // The locale is set because these are not ASCII characters.
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    for(x = 0; x < count; x++){
        putwchar(suits[x]);
    }
    
    putwchar('\n');
    return 0;
}
```

- `LC_CTYPE`: Character classification and conversion.

```sh
chan@CMA:~/C_Programming/test$ ./final
♠♥♣♦
```



In the following listing, three Unicode strings are declared in the `main()` function.

- Each one ends with newline and null characters.
- The `fputws()` function sends strings as the output to the `stdout` device.
  - This function is equivalent to `fputs()` function.



```C
#include <wchar.h>
#include <stdio.h>
#include <locale.h>

int main(){
    // Russian word "Привет!" (Hello!)
    wchar_t russian[] = {
        0x41f, 0x440, 0x438, 0x432, 0x435, 0x442, '!', '\n', '\0'};

    // Chinese word "你好" (Hello)
    wchar_t chinese[] = {
        0x4f60, 0x597d, '\n', '\0'};

    // Emoji "👋" (Waving Hand)
    wchar_t emoji[] = {
        0x1f44b, '\n', '\0'};

    // Set the locale to UTF-8
    setlocale(LC_ALL, "en_SG.UTF-8");

    // Print the wide character strings
    fputws(russian, stdout);
    fputws(chinese, stdout);
    fputws(emoji, stdout);

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ make all
Compiling the main file
clang -std=c23 -Wall -Wextra -g -D_XOPEN_SOURCE=700 -c main.c -o ./obj/main.o
Linking and producing the final application
clang -std=c23 -Wall -Wextra -g -D_XOPEN_SOURCE=700 ./obj/main.o -L./libs -lhello -o final -lssl -lcrypto -lpthread -lm

chan@CMA:~/C_Programming/test$ ./final
Привет!
伱好
👋
```



- The inability of some typefaces to properly render portions of the Unicode character set is something we should always consider when coding wide text output.
- Not every string we output requires all wide text characters, such as those strings shown in the next listing.
- In face, most often we may find a single character required in a string of otherwise typable, plain ASCII text.
- One way to sneak such a character into a string is demonstrated here.

```C
#include <wchar.h>
#include <locale.h>

int main(){
    // The character is specified by its Unicode value, U-00A5.
    wchar_t yen = 0xa5;
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    wprintf(L"That will be %lc500\n", yen);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
That will be ¥500
```



Another way to insert a non-ASCII Unicode character in a string is substitution.

- For example, we can create a wide character string of ASCII text, then plop in a specific character before the string is output.



First, we create a wide character string with a placeholder for the untypable Unicode character:

```C
wchar_t s[] = L"That will be $500\n";
```

The next step is to replace this element with the proper wide character:

```C
s[13] = 0xa5; // Jpn yen 
```

This assignment works because all characters in string `s[]` are wide. Character code `0xa5` replaces the dollar sign.



**Exercise 8.1**

Create a program that outputs this text: `I ♥ to code.`

The unicode value for the heart symbol is U+2665.

```C
int main()
{
    wchar_t s[] = L"I * to code.";
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    s[2] = 0x2665;
    wprintf(L"%ls\n", s);

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
I ♥ to code.
```



### Receiving wide character input

The following listing uses the `getwchar()` function to process standard input, including wide characters.

- The single character input is echoed back in the `wprintf()` statement.
- The `%lc` placeholder represents `wchar_t` variable `mood`.

```C
#include <locale.h>
#include <wchar.h>

int main(){
    
    // The single wide character variable mood holds input
    wchar_t mood;
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    wprintf(L"What is your mood? ");
    
    // Obtail a wide character from standard input and stores it in wchar_t variable mood
    mood = getwchar();
    wprintf(L"I feel %lc, too!\n", mood);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
What is your mood? 7
I feel 7, too!
chan@CMA:~/C_Programming/test$ ./final
What is your mood? ¥ 
I feel ¥, too!
```

- The program reads from standard input, though any text we type is represented internally by using wide characters.
- Therefore, the program runs whether we type a Unicode character or any other keyboard character.
- However, the true test is to type a Unicode character, specifically an emoji.

#### Typing Miscellaneous Symbols in Ubuntu Linux

CTRL + SHIFT + u then, the code number. For example,

- The Unicode for a coffee cup symbol is U+2615. 
- So when we want to output that in the terminal window, we have to press CTRL + SHIFT + u, then the underscored <u>`u`</u> will appear.  
- Then type the number 2615 right after the underscored u and we'll get our coffee cup emoji.

```sh
chan@CMA:~/C_Programming/test$ ./final
What is your mood? ☕
I feel ☕, too!
```

The Umbrella Symbol Unicode - U+2602

```sh
chan@CMA:~/C_Programming/test$ ./final
What is your mood? ☂
I feel ☂, too!
```



To read more than a single character, use the `fgetws()` function. 

- This function is the wide character version of `fgets()`, with a similar set of arguments.

```C
wchar_t *fgetws(wchar_t *ws, int n, FILE *stream);
```

- The first argument is a `wchar_t` buffer to store input.
- Then comes the buffer size, which is the input character count minus one for the null character, which is automatically added.
- Finally, the file stream, such as `stdin` for standard input.
- The `fgetws()` function returns the buffer's address upon success or NULL otherwise.

The next listing shows how the `fgetws()` function is used.

- The wide character buffer `input` stores wide characters read from the standard input device (`stdin`).
- A `wprintf()` function outputs the characters stored in the `input` buffer.

```C
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

int main(){
    // Uses a constant to set the buffer size
    const int size = 32;
    wchar_t input[size];
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    wprintf(L"Type some fancy text: ");
    
    // Reads the size characters into the input buffer from standard input
    fgetws(input, size, stdin);
    wprintf(L"You typed: '%ls'\n", input);
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Type some fancy text: ☂
You typed: '☂
'
chan@CMA:~/C_Programming/test$ ./final
Type some fancy text: 你好，世界
You typed: '你好，世界
'
```

- As with standard input and the `fgets()` function, the newline character is retained in the input string.

**Exercise 8.2**

When the string is shorter than the maximum number of characters allowed, the newline is retained in the string. Your tasks is to modify the source code so that any newline in the string is removed from output. One way to accomplish this tasks is to write your won output function. That's too easy. Instead, you must create a function that removes the newline added by the `fgetws()` function, effectively trimming the string.

```C
#include <stdio.h>
#include <wchar.h>
#include <locale.h>

void remove_newline(wchar_t *str){
    while(*str){
        if(*str == '\n'){
            *str = '\0';
            break;
        }
        str++;
    }
}

int main(){
    const int size = 32;
    wchar_t input[size];
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    wprintf(L"Type some fancy text: ");
    fgetws(input, size, stdin);
    remove_newline(input);
    wprintf(L"You typed: ' %ls '\n", input);
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Type some fancy text: ♅
You typed: ' ♅ '
```

Another wide input function is `wscanf()`.

- This function is based on `scanf()`.

```C
int wscanf(const wchar_t *restrict format, ...);
```

- This format is identical to that of `scanf()` function, though the formatting string (the first argument) is composed of wide characters.

```C
#include <wchar.h>
#include <locale.h>

int main(){
    // The pound character is defined as a wchar_t constant.
    const wchar_t pound = 0xa3;
    int quantity;
    float total;

    setlocale(LC_CTYPE, "en_SG.UTF-8");

    wprintf(L"How many crisps do you want? ");
    wscanf(L"%d", &quantity);
    total = quantity * 1.4;
    wprintf(L"That'll be %lc%.2f\n", pound, total);

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
How many crisps do you want? 2
That'll be £2.80
chan@CMA:~/C_Programming/test$ ./final
How many crisps do you want? 4
That'll be £5.60
```



### Working with wide characters in files

- The `wchar.h` header files also defines wide character equivalents of file I/O functions available in the standard C library.
  - For example, `fputwc()` to send a wide character to stream, the equivalent of `fputc()`.
  - These wide character functions are paired with the standard library file I/O functions, such as `fopen()`.
- As with standard I/O, our wide character file functions must set the locale.
- The file must be opened for reading, writing, or both.
- Wide character file I/O functions are used to put and get text from the file.
- The `WEOF` constant is used to identify the wide end-of-file character, `wint_t` data type.
- Once the file activity is done, the file is closed.



As an example, consider code to output 24 uppercase letters of the Greek alphabet, alpha to omega, A(U+0391) to Ω (U+03A9), saving the alphabet to a file.

- The Unicode values increment successively for each letter, though a blank spot exists at code U+03B1.
- The uppercase blank spot keeps the upper- and lowercase values parallel, as two lowercase sigma characters are used in Greek.

```C
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <locale.h>

int main(){
    const wchar_t alpha = 0x391; // Unicode for Greek capital letter Alpha (Α)
    const wchar_t omega = 0x3a9; // Unicode for Greek capital letter Omega (Ω)
    const wchar_t no_sigma = 0x3a2; // Unicode for a non-existent Greek letter (reserved)
    const char *file = "alphabeta.wtxt";
    FILE *fp;
    wchar_t a;
    
    fp = fopen(file, "w");
    if(fp == NULL){
        fprintf(stder, "Unable to open %s\n", file);
        exit(1);
    }
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    wprintf(L"Writing the Greek alphabet...\n");
    
    // Loop through the Greek alphabet from Alpha to Omega
    for(a = alpha; a <= omega; a++){
        if(a == no_sigma){
            continue; // Skip the non-existent Greek letter
        }
        
        // Write the character to the file and to the console
        fputwc(a, fp);
        fputwc(a, stdout);
    }
    
    fputwc('\0', fp);
    fclose(fp);
    wprintf(L"\nDone\n");
    return 0;
}
```

- After the file is created, the uppercase Greek characters are written to the file one at a time, using a `for` loop.
- Constants `alpha` and `omega` represent the first and last characters' Unicode values.
- The `wchar_t` constant `no_sigma` is used in an `if` test with the loop so that its character (U+03A2, which is blank) is skipped.

```sh
chan@CMA:~/C_Programming/test$ ./final
Writing the Greek alphabet...
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
Done.
```

`alphabeta.wtxt`

```
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ 
```



The next listing shows the file-reading code.

- Traditional file I/O commands open the file.
- The locale is set.
- Then the `fgetws()` function does its magic to read the uppercase alphabet wide string.
- The line is output, and the file is closed.

```C
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <locale.h>

int main(){
    const char *file = "alphabeta.wtxt";
    const int length = 64;
    FILE *fp;
    
    // The wide character input buffer
    wchar_t line[length];
    
    fp = fopen(file, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open %s\n", file);
        exit(1);
    }
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
   	wprintf(L"Reading from %s\n", file);
    fgetws(line, length, fp);
    wprintf(L"%ls\n", line);
    fclose(fp);
    return 0;
}
```

- Because the earlier program where we write Greek alphabets to "alphabeta.wtxt" file, we added a null character to the end, the `fgetws()` function here reads text from the file in one chunk like the `fgets()` function.
- `fgetws()` stops reading when it encounters the null byte, a newline, or the buffer fills.

```sh
chan@CMA:~/C_Programming/test$ ./final
Reading from alphabeta.wtxt
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
```



To read one wide character at a time from a file, use the `fgetwc()` function, which is the wide character counterpart of `fgetc()`.

- Like `fgetc()`, the value returned by `fgetwc()` isn't a character or even a wide character. It's a wide integer.

```C
wint_t fgetwc(FILE *stream);
```

- The function's argument is an open file handle, or `stdin` for standard input.

- The value returned is of the `wint_t` data type.

- As with `fgetc()`, the reason is that the wide end-of-file marker, `WEOF`, can be encountered, which the `wchar_t` type doesn't interpret properly.

- To modify the above program to read single characters from the file, only a few changes are required:

  - The `line[]` buffer is removed, along with the `length` constant. 

  - In its place, a single `wint_t` variable is declared:

  - ```C
    wint_t ch;
    ```

  - To read from the file, the `fgetws()` statement, as well as the `wprintf()` statement are replaced with:

  - ```C
    while((ch = fgetwc(fp)) != WEOF){
        putchar(ch);
    }
    putchar('\n');
    ```

  - The `while` loop's condition both reads a character (a `wint_t` value) from the open file handle `fp`.

  - This value is compared with `WEOF`, the wide character end-of-file marker.

  - As long as the character isn't the end of file, the loop repeats.

  - The loop's sole statement is `putwchar(ch)`, which outputs the character read.

  - A final `putwchar()` statement outputs a newline, cleaning up the output.

**Complete Program**

```C
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <locale.h>

int main(){
    const char *file = "alphabeta.wtxt";
    FILE *fp;
    wint_t ch;
    
    fp = fopen(file, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open %s\n", file);
        exit(1);
    }
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    
    wprintf(L"Reading from %s\n", file);
    while((ch = fgetwc(fp)) != WEOF){
        putwchar(ch);
    }
    putwchar('\n');
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Reading from alphabeta.wtxt
ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ
```



**Exercise 8.3**

Create code that writes the Cyrillic alphabet to a file. The first letter of the Cyrillic alphabet, А, is `U+0410`. The last letter is Я, `U+042F`. These are the uppercase letters. Unlike Greek, no blanks are found in the Unicode sequence.



Writing Cyrillic alphabet to a file

```C
int main(){
    const wchar_t cyrillicA = 0x0410;
    const wchar_t cyrillicR = 0x042F;
    
    const char *file = "cyrillic.wtxt";
    FILE *fp;
    wchar_t c;
    
    fp = fopen(file, "w");
    if(fp == NULL){
        fprintf(stderr, "Unable to open %s\n", file);
        exit(1);
    }
    
    setlocale(LC_CTYPE, "en_SG.UTF-8");
    wprintf(L"Writing Cyrillic characters to %s\n", file);
    
    for(c = cyrillicA; c <= cyrillicR; c++){
        fputwc(c, fp);
        fputwc(c, stdout);
    }
    
    fputwc('\0', fp);
    fclose(fp);
    wprintf(L"\nDone\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Writing Cyrillic characters to cyrillic.wtxt
АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ
Done
```

`cyrillic.wtxt`

```
АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ 
```



Reading from `cyrillic.wtxt` (`fgetwc()`)

```C
int main(){
    const char *file = "cyrillic.wtxt";
    FILE *fp;
    wint_t ch;

    fp = fopen(file, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open %s\n", file);
        exit(1);
    }

    setlocale(LC_CTYPE, "en_SG.UTF-8");

    wprintf(L"Reading Cyrillic characters from %s\n", file);

    while ((ch = fgetwc(fp)) != WEOF)
    {
        putwchar(ch);
    }

    putwchar('\n');

    fclose(fp);

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Reading Cyrillic characters from cyrillic.wtxt
АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ

```



Reading from `cyrillic.wtxt` (`fgetws()`)

```C

int main()
{
    const char *file = "cyrillic.wtxt";
    const int length = 64;
    FILE *fp;
    wchar_t line[length];

    fp = fopen(file, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open %s\n", file);
        exit(1);
    }

    setlocale(LC_CTYPE, "en_SG.UTF-8");

    wprintf(L"Reading Cyrillic characters from %s\n", file);

    while (fgetws(line, length, fp) != NULL)
    {
        wprintf(L"%ls\n", line);
    }

    fclose(fp);

    return 0;
}

```

```sh
chan@CMA:~/C_Programming/test$ ./final
Reading Cyrillic characters from cyrillic.wtxt
АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ

```

---



## Chapter 9 - Hex Dumper

- Hexdump is a Linux utility available as part of the default installation.
- In C, the 8-bit byte corresponds directly to the `char` data type.



```C
unsigned long byte = sizeof(char) * 8;
```

- The `sizeof` operator returns the number of bytes used by a specific C language data type, `char` .
- This value is multiplied by eight to obtain the number of bits.
- The result is stored in `unsigned long` variable `byte`.

```sh
chan@CMA:~/C_Programming/test$ ./final
Size of char: 8
```

- We don't need to perform the math and overhead.

- The reason is that the compiler itself has a limit.
- Specifically, the limit values are set as defined constants in the appropriately named `limits.h` header file.
- Memory capacity, media storage, file size - all these quantities are measured in 8-bit bytes, `char` values.
- This yardstick gives rise to two systems for counting bytes: one based on the powers of two (binary), the other on the powers of 10 (decimal).
- When we allocate 1 K (kilobyte) of memory, we are setting aside 1024 char-sized pieces of memory as a single chunk.
- All `char` or byte-size values easily fit within an integer-sized chunk.
- The `int` data type avoid any wrapping that occurs with a `char` which is probably one reason why functions like `getchar()` and `putchar()` use integers instead of `char` types.



The next listing stores the 256 `char` values in a char array, `data[]`.

- Two `for` loops process the array, the first to fill it and the second to output its values.
- Though the array stores only byte values, `int` variable `b` is used to store the values.

```C
int main(){
    // Room for the full variety of byte values
    unsigned char data[256];
    int b;
    
    for(b = 0; b < 256; b++){
        data[b] = b;
    }
    
    for(b = 0; b < 256; b++){
        printf("%d\n", data[b]);
    }
    return 0;
}
```

- With an array holding the values, allows for modifications and manipulations to be made to the stored data.
- The goal is to accurately present the data in a readable format. 
- The inelegant term for doing so is `dump`.



### Dumping data

- Dump is both a noun and a verb, neither of which is flattering.
- What's being dumped isn't considered useful unless it's data.
- In the digital realm, a *dump* is the movement of data from one place to another.
- To dump data in C, we copy it from one location to another.
- We can dump a chunk of memory, though only the memory the program has access to.



```C
int main()
{
    unsigned char data[256];
    int b;

    for (b = 0; b < 256; b++)
    {
        data[b] = b;
    }

    for (b = 0; b < 256; b++)
    {
        printf(" %02X", data[b]);
        // output a newline every 16 bytes
        if ((b + 1) % 16 == 0)
        {
            putchar('\n');
        }
    }
    return 0;
}
```

- One is added to the value of `b`, (b + 1), to avoid a newline popping out after the first value (zero).

![Screenshot from 2024-11-14 21-35-15](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-14 21-35-15.png)

- The output is better, but it could still use some improvement.
- Because the data dump is sequential, it's easy to see patterns and reference rows and columns.



**Exercise 9.2**

Improve the code in the previous program in two stages. First add an initial column showing the byte values' offset. Output this value as a 5-digit hexadecimal number. Then output the row of 16 bytes.

Second, add an extra space to separate the eighth and ninth byte columns. This space makes the rows and columns more readable.

**Solution**

```C
int main(){
    unsigned char data[256];
    int b;
    
    // Initialize the 'data' array with values from 0 to 255
    for(b = 0; b < 256; b++){
        data[b] = b;
    }
    
    // Iterate thru the 'data' array to print its content
    for(b = 0; b < 256; b++){
        if(b % 16 == 0){
            // Print b as a 5-digit hexadecimal number with leading zeros
            printf("%05X ", b);
        }
        
        // Print the current byte in hexadecimal format 
        printf(" %02X", data[b]); //Print 'data[b]' as a 2-digit hexadecimal number with leading zeros
        
        // Insert a space after every 8 bytes for readability
        if((b + 1) % 8 == 0){
            putchar(' ');
        }
        
        // After every 16 bytes, print a newline character to move to the next line
        if((b + 1) % 16 == 0){
            putchar('\n');
        }
    }
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
00000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F 
00010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F 
00020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F 
00030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F 
00040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F 
00050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F 
00060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F 
00070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F 
00080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F 
00090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F 
000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF 
000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF 
000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF 
000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF 
000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF 
000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF 

```

- A final improvement is to add a third ASCII column after the byte values.
- This additional information cross-references the hex bytes of displayable ASCII text, providing a handy way for humans to quickly scan the dump for relevant information.
- The ordeal of adding an ASCII column to the output is complicated due to stream output.
- Each row must be processed sequentially: 16 bytes are output as hex values and then the same bytes are output as printable ASCII characters.
- To resolve this, the `line_out()` function features three arguements,
  - an offset representing a byte count,
  - the length of the data chunk,
  - and the data itself as an `unsigned char` pointer
- Variable `a` tracks progress in the `for` loops and is used with the data pointer to fetch specific byte values: `*(data + a)`.
- This function outputs a single row of the dump, so it is called from the `main` function to output all the data.

`hello.h`

```C
void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data){
    int a;
    
    // Print the offset in 5-digit hex format followed by a space
    printf("%05X ", offset);
    
    // Print each byte in hex format
    for(a = 0; a < length; a++){
        printf(" %02X", *(data + a));
        
        // After every 8 bytes, print an extra space for readability
        if((a + 1) % 8 == 0){
            putchar(' ');
        }
    }
    
    // Additional space between hex bytes and ASCII representation
    putchar(' ');
    
    // Print the ASCII representation of each byte
    for(a = 0; a < length; a++){
        
        // Check if byte is printable
        if(*(data + a) >= ' ' && *(data + a) <= '~'){
            putchar(*(data + a));
        }else{
            putchar(' ');
        }
    }
    putchar('\n');
}
```

`main.c`

```C
int main(){
    unsigned char data[256];
    int b;
    
    const int length = 16;
    
    for(b = 0; b < 256; b++){
        data[b] = b;
    }
    
    // Iterate over the data array in steps of length (16 bytes)
    for(b = 0; b < 256; b += length){
        // Call the line_out func to print each 16-byte chunk
        // Pass the current offset, the length, and a pointer to the current chunk
        line_out(b, length, data + b);
    }
    
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
00000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F                  
00010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F                  
00020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !"#$%&'()*+,-./
00030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;<=>?
00040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO
00050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_
00060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno
00070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~ 
00080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F                  
00090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F                  
000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF                  
000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF                  
000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF                  
000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF                  
000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF                  
000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF    
```

![Screenshot from 2024-11-16 21-36-10](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-16 21-36-10.png)

**Exercise 9.3**

The output from the preceding program is predictable  - awath of 256-byte values from 0x00 through 0xFF. Le

s modify the code to repopulate the `data[]` buffer with random values.

`hello.c`

```c#
void line_out(int offset, int length, unsigned char *data)
{
    int a;
    printf("%05X ", offset);

    for (a = 0; a < length; a++)
    {
        printf(" %02X", *(data + a));
        if ((a + 1) % 8 == 0)
        {
            putchar(' ');
        }
    }
    putchar(' ');

    for (a = 0; a < length; a++)
    {
        if (*(data + a) >= ' ' && *(data + a) <= '~')
        {
            putchar(*(data + a));
        }
        else
        {
            putchar(' ');
        }
    }

    putchar('\n');
}
```

`main.c`

```C
int main()
{
    unsigned char data[256];
    int b;
    const int length = 16;

    srand((unsigned)(time(NULL)));

    for (b = 0; b < 256; b++)
    {
        data[b] = rand() % 256;
    }

    for (b = 0; b < 256; b += length)
    {
        line_out(b, length, data + b);
    }
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
00000  BA A3 19 01 F1 24 4F 5D  1A 8A DD 1A 07 65 4B EF       $O]     eK 
00010  D9 AC 52 73 76 B9 BC 56  B8 0E 25 A3 BE 8B 18 78    Rsv  V  %    x
00020  2E 31 7A 1F 56 C9 7D 70  53 5A 8B 5A BF D6 4A 99  .1z V }pSZ Z  J 
00030  82 9C 0C F8 55 C8 4F 0D  D7 74 B1 95 FF C9 0E 2E      U O  t     .
00040  FA 88 4D 50 51 CA C1 A5  24 4C FF E4 22 49 7D A4    MPQ   $L  "I} 
00050  E5 89 9D 3B 51 EC 48 28  60 F9 BE 5F C2 CC 8D BD     ;Q H(`  _    
00060  54 DB 0D A5 A5 CE 4A CA  1A 4A AE 3C 93 2B E1 79  T     J  J < + y
00070  B4 7E B4 05 6A FC 2E CA  F6 EC 29 B8 B8 B7 75 0C   ~  j .   )   u 
00080  92 83 B1 37 51 FC 01 6C  46 AF A8 D9 DA 89 52 8E     7Q  lF     R 
00090  07 06 94 71 03 C2 3B F9  AE 65 B1 66 1C 27 72 AE     q  ;  e f 'r 
000A0  AA 23 E5 FB 1F E7 67 65  96 10 3F 71 99 91 FF A1   #    ge  ?q    
000B0  98 93 12 9B 55 4E 94 03  B3 45 69 CF 6C DB 7D 16      UN   Ei l } 
000C0  FF 62 12 1E 49 79 84 E0  89 C3 51 23 54 50 C4 EC   b  Iy    Q#TP  
000D0  E4 D6 87 39 24 1B 3D D7  61 A6 A6 CD 82 23 E4 81     9$ = a    #  
000E0  86 F6 9F CF 6F 23 AF F9  E6 00 1C 3B 51 E0 27 35      o#     ;Q '5
000F0  B6 AF 6E DB CA AB B2 2B  52 59 F9 D4 7C DD 55 02    n    +RY  | U 
chan@CMA:~/C_Programming/test$ ./final
00000  AB 5A 9F 73 61 3C C5 22  2B 2F 31 EB D5 3C 4A CE   Z sa< "+/1  <J 
00010  25 81 8C AB 57 11 2D 04  1A E1 37 11 78 CD B5 23  %   W -   7 x  #
00020  28 54 97 89 90 5C AB BC  8B DC A7 60 18 F1 2F 3D  (T   \     `  /=
00030  72 BB E9 CA CD 16 CE E7  F7 05 F9 70 D3 AE 93 FB  r          p    
00040  02 2A 84 92 86 2F 4E 12  0B F5 72 23 E7 A1 60 59   *   /N   r#  `Y
00050  5D 49 23 2A 5F F2 11 57  F7 0A C7 CA B8 5A C5 BA  ]I#*_  W     Z  
00060  85 49 4D 0B 78 9B 1D 83  91 90 A6 78 31 07 D1 8E   IM x      x1   
00070  50 F5 B8 B0 E7 CA 07 DE  D4 CE A9 8D 28 6E 47 AD  P           (nG 
00080  B8 94 B9 30 30 D6 B4 C1  66 5A 39 98 61 0A 26 B2     00   fZ9 a & 
00090  FF DF 62 E6 A9 69 C5 7D  37 6E 0A 5F DC 52 0D 94    b  i }7n _ R  
000A0  E6 C6 C5 16 9C 79 D7 03  D3 10 9B 35 1B C1 E7 1A       y     5    
000B0  A0 49 01 49 B2 C6 C7 E9  34 D1 48 10 23 55 A5 0A   I I    4 H #U  
000C0  1B 6A 20 B8 E3 F8 BB B6  08 56 EB 23 17 D2 3E B8   j       V #  > 
000D0  1B 3F 01 CD 05 C8 B6 39  9A FF 49 BD 54 EE C7 70   ?     9  I T  p
000E0  58 E8 28 3B E0 E3 F2 E8  39 DD 0C 50 B0 4A 08 CB  X (;    9  P J  
000F0  89 0A 99 8E D2 4F C7 6C  4E 10 2A A3 FF F1 13 57       O lN * 
```



### Reading file data

- A `dumpfile` utility could be written as a filter, just like Linux's `hexdump`.
- As a filter, `hexdump` chews through all input whether it originates from a file or is the output from some program.
- Utilities that read data from a file use two approaches.
  - The first is to specify the filename at the command prompt - usually, as the first (and often only) argument.
  - The second way is to prompt for a filename after the utility starts, or to prompt for the filename if it's missing as a command-line argument.
- `bytes.dat` test file is used for the following listing and it contains sequential byte values from 0x00 through 0xFF.



`hello.h`

```C
void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data)
{
    int a;
    
    // Print the offset in hexadecimal (5 digits with leading zeros)
    printf("%05X ", offset);

    // Iterate through each byte to format the ASCII representation
    for (a = 0; a < length; a++)
    {
        printf(" %02X", *(data + a));
        
        // Insert a space after every 8 bytes for readability
        if ((a + 1) % 8 == 0)
        {
            putchar(' ');
        }
    }
    
    // Additional space between hex and ASCII sections
    putchar(' ');

    // Iterate through each byte again to print ASCII characters
    for (a = 0; a < length; a++)
    {
        // Check if the byte is a printable ASCII character
        if (*(data + a) >= ' ' && *(data + a) <= '~')
        {
            putchar(*(data + a));
        }
        else
        {
            putchar(' ');
        }
    }

    putchar('\n');
}
```

- The condition `*(data + a) >= ' '` **and** `*(data + a) <= '~'` is used to determine whether a given byte in the `data` array represents a **printable ASCII character**.
- **Understanding the ASCII Range:**
  - **' ' (Space):** ASCII value **32**
  - **'~' (Tilde):** ASCII value **126**
  - **ASCII Printable Characters:** Range from **32** to **126**
  - This range includes all standard printable characters, such as letters, digits, punctuation marks, and common symbols.

`main.c`

```C
int main(int argc, char *argv[])
{
    const int length = 16;
    unsigned char buffer[length];
    char *filename;
    FILE *fp;
    
    // Variables for character reading, offset tracking, and buffer indexing
    int ch, offset, index;

    if (argc < 2)
    {
        fprintf(stderr, "Format: dumpfile filename\n");
        exit(1);
    }

    filename = argv[1];

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }
    
    offset = 0; // Initialize the offset (starting byte index) to zero
    index = 0;
    
    while (!feof(fp))
    {
        ch = fgetc(fp);
        if (ch == EOF)
        {
            // If there are remaining bytes in the buffer
            if (index != 0)
            {
                // Print the remaining bytes using line_out
                line_out(offset, index, buffer);
            }
            // Exit the loop as the file has been fully read
            break;
        }

        buffer[index] = ch; // Store the read byte into the buffer
        index++;
        
        // If the buffer is full (16 bytes)
        if (index == length)
        {
            // Print the buffer contents using line_out
            line_out(offset, length, buffer);
            
            // Update the offset for the next chunk
            offset += length;
            
            // Reset the buffer index for the next set of bytes
            index = 0;
        }
    }

    fclose(fp);

    return 0;
}

```

`Output`

```sh
 chan@CMA:~/C_Programming/test$ ./final
Format: dumpfile filename
chan@CMA:~/C_Programming/test$ ./final bytes.dat
00000 00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F                  
00010 10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F                  
00020 20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !"#$%&'()*+,-./
00030 30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;<=>?
00040 40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO
00050 50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_
00060 60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno
00070 70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~ 
00080 80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F                  
00090 90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F                  
000A0 A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF                  
000B0 B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF                  
000C0 C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF                  
000D0 D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF                  
000E0 E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF                  
000F0 F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF 
```



### Fixing uneven output

![Screenshot from 2024-11-17 19-52-09](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-17 19-52-09.png)

- At offset `0x00270` (the last line), the file's final byte, `0A` is immediately followed by the line's ASCII column,
- The text "to thee" is several spaces to the left of where it should line up - if the file ended exactly at 16-byte boundary.
- To resolve this problem, the `line_out()` function must know when a line of output doesn't match the default output length of 16 bytes.

In the next listing, we see how enum `SIZE` is used in the `line_out()` function to help test when the final line of output is shorter than 16 bytes.

- This change requires the addition of an `if` statement between the two existing `for` loops.
- The `if` decision helps to balance out the remainder of the last row of output so that the ASCII column lines up.

`hello.h`

```C
enum{
    SIZE = 16,
};

void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data){
    int a;
    
    printf("%05X ", offset);
    
    for(a = 0; a < length; a++){
        printf(" %02X", data[a]);
        if((a + 1) % 8 == 0){
            putchar(' ');
        }
    }
    
    // If the row has fewer than SIZE (16) bytes
    if(length < SIZE){
        
        // Continue the loop using variable a
        for(; a < SIZE; a++){
            
            // Outputs three spaces
            printf("   ");
            
            if((a + 1) % 8 == 0){
                putchar(' ');
            }
        }
    }
    
    putchar(' ');
    
    for(a = 0; a < length, a++){
        if(data[a] >= ' ' && data[a] <= '~'){
            putchar(data[a]);
        }else{
            putchar(' ');
        }
    }
    
    putchar('\n');
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int ch, offset, index;
    
    if(argc < 2){
        fprintf(stderr, "Format: dumpfile filename\n");
        exit(1);
    }
    
    filename = argv[1];
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }
    
    offset = 0;
    index = 0;
    while(!feof(fp)){
        ch = fgetc(ch);
        if(ch == EOF){
            if(index != 0){
                line_out(offset, index, buffer );
                
            }
            break;
        }
        
        buffer[index] = ch;
        index++;
        
        // If the buffer is full (16 bytes)
        if(index == SIZE){
            
            // Print the buffer contents using line_out
            line_out(offset, SIZE, buffer);
            // Update the offset for the next chunk
            offset += SIZE;
            index = 0;
        }
    }
    
    fclose(fp);
    return 0;
}
```

- Purpose of `offset` and `SIZE`

  - **`offset`**: This variable keeps track of the current byte position in the file. It represents the starting byte index of each line in the hexdump.
  - **`SIZE`**: This is a constant that defines the number of bytes to read and display per line. In our program, `SIZE` is typically set to `16`, meaning each line of the hexdump will display 16 bytes.

- **Why `offset += SIZE`?**

  - Every time we read a chunk of `SIZE` bytes from the file, we process and display those bytes in one line of the hexdump. 

  - After processing, we need to update the `offset` to reflect the position of the next chunk of bytes to be read. 

  - By adding `SIZE` to `offset`, we ensure that each subsequent line accurately represents the next set of bytes in the file.

- **Example Flow:**

  1. **First Line:**
     - **Offset**: `0`
     - **Bytes Displayed**: Bytes `0` to `15`
     - **After Processing**: `offset += 16` → `offset = 16`
  2. **Second Line:**
     - **Offset**: `16`
     - **Bytes Displayed**: Bytes `16` to `31`
     - **After Processing**: `offset += 16` → `offset = 32`
  3. **And so on...**

- Visualizing the Process with `sonnet18.txt`

  - **Step-by-Step Execution**

    1. **Program Start:**

       - Initial Variables:
         - `offset = 0`
         - `index = 0`
         - `buffer[16]` is empty.

    2. **Reading the First 16 Bytes:**

       - **Bytes Read:**

         ```
         S h a l l   I   c o m p a r e
         ```

       - **Buffer Contents (Hex):**

         ```
         53 68 61 6C 6C 20 49 20 63 6F 6D 70 61 72 65
         ```

       - **Calling `line_out(offset, 16, buffer)`**

         ```
         00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65     Shall I compare
         ```

       - Update Offset:

         - `offset += 16` → `offset = 16`

    3. **Reading the Next 16 bytes**:

       - Bytes Read:

         ```
          t o   a   s u m m e r ' s   d a y 
         ```

       - **Buffer Contents (Hex):**

         ```
         20 74 6F 20 61 20 73 75 6D 6D 65 72 27 73 20 64
         ```

       - **Calling `line_out(offset, 16, buffer)`:**

         - Prints:

         ```
         00010  20 74 6F 20 61 20 73 75  6D 6D 65 72 27 73 20 64   to a summer's d
         ```

       - Update Offset:

         - `offset += 16` → `offset = 32`

    4. **Continuing the Process:**

       This process repeats, reading 16 bytes at a time, calling `line_out` to display each chunk, and updating the `offset` accordingly.

    5. **Handling the Last Chunk:**

       If the total number of bytes isn't a multiple of `SIZE`, the remaining bytes are processed similarly, ensuring the hexdump is complete.

`sonnet18.txt`

```
Shall I compare thee to a summer's day?
Thou art more lovely and more temperate:
Rough winds do shake the darling buds of May,
And summer's lease hath all too short a date;
Sometime too hot the eye of heaven shines,
And often is his gold complexion dimm'd;
And every fair from fair sometime declines,
By chance or nature's changing course untrimm'd;
But thy eternal summer shall not fade,
Nor lose possession of that fair thou ow'st;
Nor shall death brag thou wander'st in his shade,
When in eternal lines to time thou grow'st:
So long as men can breathe or eyes can see,
So long lives this, and this gives life to thee.
```



`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final bytes.dat
00000  00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F                  
00010  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F                  
00020  20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F   !"#$%&'()*+,-./
00030  30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  0123456789:;<=>?
00040  40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  @ABCDEFGHIJKLMNO
00050  50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  PQRSTUVWXYZ[\]^_
00060  60 61 62 63 64 65 66 67  68 69 6A 6B 6C 6D 6E 6F  `abcdefghijklmno
00070  70 71 72 73 74 75 76 77  78 79 7A 7B 7C 7D 7E 7F  pqrstuvwxyz{|}~ 
00080  80 81 82 83 84 85 86 87  88 89 8A 8B 8C 8D 8E 8F                  
00090  90 91 92 93 94 95 96 97  98 99 9A 9B 9C 9D 9E 9F                  
000A0  A0 A1 A2 A3 A4 A5 A6 A7  A8 A9 AA AB AC AD AE AF                  
000B0  B0 B1 B2 B3 B4 B5 B6 B7  B8 B9 BA BB BC BD BE BF                  
000C0  C0 C1 C2 C3 C4 C5 C6 C7  C8 C9 CA CB CC CD CE CF                  
000D0  D0 D1 D2 D3 D4 D5 D6 D7  D8 D9 DA DB DC DD DE DF                  
000E0  E0 E1 E2 E3 E4 E5 E6 E7  E8 E9 EA EB EC ED EE EF                  
000F0  F0 F1 F2 F3 F4 F5 F6 F7  F8 F9 FA FB FC FD FE FF     


han@CMA:~/C_Programming/test$ ./final sonnet18.txt
00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65 20  Shall I compare 
00010  74 68 65 65 20 74 6F 20  61 20 73 75 6D 6D 65 72  thee to a summer
00020  27 73 20 64 61 79 3F 0A  54 68 6F 75 20 61 72 74  's day? Thou art
00030  20 6D 6F 72 65 20 6C 6F  76 65 6C 79 20 61 6E 64   more lovely and
00040  20 6D 6F 72 65 20 74 65  6D 70 65 72 61 74 65 3A   more temperate:
00050  0A 52 6F 75 67 68 20 77  69 6E 64 73 20 64 6F 20   Rough winds do 
00060  73 68 61 6B 65 20 74 68  65 20 64 61 72 6C 69 6E  shake the darlin
00070  67 20 62 75 64 73 20 6F  66 20 4D 61 79 2C 0A 41  g buds of May, A
00080  6E 64 20 73 75 6D 6D 65  72 27 73 20 6C 65 61 73  nd summer's leas
00090  65 20 68 61 74 68 20 61  6C 6C 20 74 6F 6F 20 73  e hath all too s
000A0  68 6F 72 74 20 61 20 64  61 74 65 3B 0A 53 6F 6D  hort a date; Som
000B0  65 74 69 6D 65 20 74 6F  6F 20 68 6F 74 20 74 68  etime too hot th
000C0  65 20 65 79 65 20 6F 66  20 68 65 61 76 65 6E 20  e eye of heaven 
000D0  73 68 69 6E 65 73 2C 0A  41 6E 64 20 6F 66 74 65  shines, And ofte
000E0  6E 20 69 73 20 68 69 73  20 67 6F 6C 64 20 63 6F  n is his gold co
000F0  6D 70 6C 65 78 69 6F 6E  20 64 69 6D 6D 27 64 3B  mplexion dimm'd;
00100  0A 41 6E 64 20 65 76 65  72 79 20 66 61 69 72 20   And every fair 
00110  66 72 6F 6D 20 66 61 69  72 20 73 6F 6D 65 74 69  from fair someti
00120  6D 65 20 64 65 63 6C 69  6E 65 73 2C 0A 42 79 20  me declines, By 
00130  63 68 61 6E 63 65 20 6F  72 20 6E 61 74 75 72 65  chance or nature
00140  27 73 20 63 68 61 6E 67  69 6E 67 20 63 6F 75 72  's changing cour
00150  73 65 20 75 6E 74 72 69  6D 6D 27 64 3B 0A 42 75  se untrimm'd; Bu
00160  74 20 74 68 79 20 65 74  65 72 6E 61 6C 20 73 75  t thy eternal su
00170  6D 6D 65 72 20 73 68 61  6C 6C 20 6E 6F 74 20 66  mmer shall not f
00180  61 64 65 2C 0A 4E 6F 72  20 6C 6F 73 65 20 70 6F  ade, Nor lose po
00190  73 73 65 73 73 69 6F 6E  20 6F 66 20 74 68 61 74  ssession of that
001A0  20 66 61 69 72 20 74 68  6F 75 20 6F 77 27 73 74   fair thou ow'st
001B0  3B 0A 4E 6F 72 20 73 68  61 6C 6C 20 64 65 61 74  ; Nor shall deat
001C0  68 20 62 72 61 67 20 74  68 6F 75 20 77 61 6E 64  h brag thou wand
001D0  65 72 27 73 74 20 69 6E  20 68 69 73 20 73 68 61  er'st in his sha
001E0  64 65 2C 0A 57 68 65 6E  20 69 6E 20 65 74 65 72  de, When in eter
001F0  6E 61 6C 20 6C 69 6E 65  73 20 74 6F 20 74 69 6D  nal lines to tim
00200  65 20 74 68 6F 75 20 67  72 6F 77 27 73 74 3A 0A  e thou grow'st: 
00210  53 6F 20 6C 6F 6E 67 20  61 73 20 6D 65 6E 20 63  So long as men c
00220  61 6E 20 62 72 65 61 74  68 65 20 6F 72 20 65 79  an breathe or ey
00230  65 73 20 63 61 6E 20 73  65 65 2C 0A 53 6F 20 6C  es can see, So l
00240  6F 6E 67 20 6C 69 76 65  73 20 74 68 69 73 2C 20  ong lives this, 
00250  61 6E 64 20 74 68 69 73  20 67 69 76 65 73 20 6C  and this gives l
00260  69 66 65 20 74 6F 20 74  68 65 65 2E              ife to thee.

```



![Screenshot from 2024-11-17 20-00-18](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-17 20-00-18.png)

**Exercise 9.4**

To further update the source code for the above program, modify the `main()` function so that if the filename argument is missing, the program prompts for it.

It's important that your code identify when the user just presses Enter or otherwise dismisses the filename prompt. There's no point in the program attempting to open a NULL string filename. Beyond this requirement, you don't need to otherwise validate the filename, because the `fopen()` statement does so automatically.

**Solution**

`hello.h`

```C
enum{
    SIZE = 16,
};

void line_out(int offset, int length, unsigned char *data);
```

`hello.c`

```C
void line_out(int offset, int length, unsigned char *data){
    int a;
    
    printf("%05X ", offset);
    
    for(a = 0; a < length; a++){
        printf(" %02X", data[a]);
        if((a + 1) % 8 == 0){
            putchar(' ');
        }
    }
    
    // If the row has fewer than SIZE (16) bytes
    if(length < SIZE){
        
        // Continue the loop using variable a
        for(; a < SIZE; a++){
            
            // Outputs three spaces
            printf("   ");
            
            if((a + 1) % 8 == 0){
                putchar(' ');
            }
        }
    }
    
    putchar(' ');
    
    for(a = 0; a < length, a++){
        if(data[a] >= ' ' && data[a] <= '~'){
            putchar(data[a]);
        }else{
            putchar(' ');
        }
    }
    
    putchar('\n');
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int ch, offset, index;
    char fileinput[100];
    
    if(argc < 2){
        printf("Enter the filename: ");
        if(fgets(fileinput, sizeof(fileinput), stdin) != NULL){
            
            // ensures that the newline character from user input is removed properly
            fileinput[strcspn(fileinput, "\n")] = '\0';
        }
    }
    
    filename = (argc >= 2) ? argv[1] : fileinput;
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open file '%s'\n");
        exit(1);
    }
    
    offset = 0;
    index = 0;
    
    //Simplifed loop condition
    while((ch = fgetc(fp)) != EOF){
        buffer[index++] = (unsigned char)ch;
        
        if(index == SIZE){
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }
    
    // Handle remaining bytes after EOF
    if(index > 0){
        line_out(offset, index, buffer);
    }
    fclose(fp);
    return 0;
}
```

`main.c` (Author's solution)

```C
int main(int argc, char *argv[]){
    unsigned char buffer[SIZE];
    
    // the filename variable can now be an input buffer
    // BUFSIZ is defined in stdio.
    char filename[BUFSIZ];
    
    // For the fgets() function return value
    char *r;
    FILE *fp;
    int ch, offset, index;
    
    if(argc < 2){
        printf("Filename: ");
        r = fgets(filename, BUFSIZ, stdin);
        
        // a NULL return = nothing valid typed
        // if only '\n' in the buffer, nothing typed
        if(r == NULL || filename[0] == '\n'){
            exit(1);
        }
        
        // Remove the newline
        while(*r != '\n'){ // r = the string entered
            r++;
            
            // Check for overflow
            if(r - filename == BUFSIZ){
                exit(1);
            }
        }
        *r = '\0'l
    }else{
        strcpy(filename, argv[1]);
    }
    
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }
    
    offset = 0;
    index = 0;
    while((ch = fgetc(fp)) != EOF){
        buffer[index++] = (unsigned char)ch;
        
        if(index == SIZE){
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }
    
    if(index > 0){
        line_out(offset, index, buffer);
    }
    
    fclose(fp);
    
    return 0;
    
}
```



`Output`

```sh
han@CMA:~/C_Programming/test$ ./final
Enter the filename: hey
Unable to open file 'hey'

chan@CMA:~/C_Programming/test$ ./final
Enter the filename: sonnet18.txt
00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65 20  Shall I compare 
00010  74 68 65 65 20 74 6F 20  61 20 73 75 6D 6D 65 72  thee to a summer
00020  27 73 20 64 61 79 3F 0A  54 68 6F 75 20 61 72 74  's day? Thou art
00030  20 6D 6F 72 65 20 6C 6F  76 65 6C 79 20 61 6E 64   more lovely and
00040  20 6D 6F 72 65 20 74 65  6D 70 65 72 61 74 65 3A   more temperate:
00050  0A 52 6F 75 67 68 20 77  69 6E 64 73 20 64 6F 20   Rough winds do 
00060  73 68 61 6B 65 20 74 68  65 20 64 61 72 6C 69 6E  shake the darlin
00070  67 20 62 75 64 73 20 6F  66 20 4D 61 79 2C 0A 41  g buds of May, A
00080  6E 64 20 73 75 6D 6D 65  72 27 73 20 6C 65 61 73  nd summer's leas
00090  65 20 68 61 74 68 20 61  6C 6C 20 74 6F 6F 20 73  e hath all too s
000A0  68 6F 72 74 20 61 20 64  61 74 65 3B 0A 53 6F 6D  hort a date; Som
000B0  65 74 69 6D 65 20 74 6F  6F 20 68 6F 74 20 74 68  etime too hot th
000C0  65 20 65 79 65 20 6F 66  20 68 65 61 76 65 6E 20  e eye of heaven 
000D0  73 68 69 6E 65 73 2C 0A  41 6E 64 20 6F 66 74 65  shines, And ofte
000E0  6E 20 69 73 20 68 69 73  20 67 6F 6C 64 20 63 6F  n is his gold co
000F0  6D 70 6C 65 78 69 6F 6E  20 64 69 6D 6D 27 64 3B  mplexion dimm'd;
00100  0A 41 6E 64 20 65 76 65  72 79 20 66 61 69 72 20   And every fair 
00110  66 72 6F 6D 20 66 61 69  72 20 73 6F 6D 65 74 69  from fair someti
00120  6D 65 20 64 65 63 6C 69  6E 65 73 2C 0A 42 79 20  me declines, By 
00130  63 68 61 6E 63 65 20 6F  72 20 6E 61 74 75 72 65  chance or nature
00140  27 73 20 63 68 61 6E 67  69 6E 67 20 63 6F 75 72  's changing cour
00150  73 65 20 75 6E 74 72 69  6D 6D 27 64 3B 0A 42 75  se untrimm'd; Bu
00160  74 20 74 68 79 20 65 74  65 72 6E 61 6C 20 73 75  t thy eternal su
00170  6D 6D 65 72 20 73 68 61  6C 6C 20 6E 6F 74 20 66  mmer shall not f
00180  61 64 65 2C 0A 4E 6F 72  20 6C 6F 73 65 20 70 6F  ade, Nor lose po
00190  73 73 65 73 73 69 6F 6E  20 6F 66 20 74 68 61 74  ssession of that
001A0  20 66 61 69 72 20 74 68  6F 75 20 6F 77 27 73 74   fair thou ow'st
001B0  3B 0A 4E 6F 72 20 73 68  61 6C 6C 20 64 65 61 74  ; Nor shall deat
001C0  68 20 62 72 61 67 20 74  68 6F 75 20 77 61 6E 64  h brag thou wand
001D0  65 72 27 73 74 20 69 6E  20 68 69 73 20 73 68 61  er'st in his sha
001E0  64 65 2C 0A 57 68 65 6E  20 69 6E 20 65 74 65 72  de, When in eter
001F0  6E 61 6C 20 6C 69 6E 65  73 20 74 6F 20 74 69 6D  nal lines to tim
00200  65 20 74 68 6F 75 20 67  72 6F 77 27 73 74 3A 0A  e thou grow'st: 
00210  53 6F 20 6C 6F 6E 67 20  61 73 20 6D 65 6E 20 63  So long as men c
00220  61 6E 20 62 72 65 61 74  68 65 20 6F 72 20 65 79  an breathe or ey
00230  65 73 20 63 61 6E 20 73  65 65 2C 0A 53 6F 20 6C  es can see, So l
00240  6F 6E 67 20 6C 69 76 65  73 20 74 68 69 73 2C 20  ong lives this, 
00250  61 6E 64 20 74 68 69 73  20 67 69 76 65 73 20 6C  and this gives l
00260  69 66 65 20 74 6F 20 74  68 65 65 2E              ife to thee.
```

`Output` (Author's solution)

```sh
chan@CMA:~/C_Programming/test$ ./final
Filename: Good News
Unable to open file 'Good News'
chan@CMA:~/C_Programming/test$ ./final
Filename: sonnet18.txt
00000  53 68 61 6C 6C 20 49 20  63 6F 6D 70 61 72 65 20  Shall I compare 
00010  74 68 65 65 20 74 6F 20  61 20 73 75 6D 6D 65 72  thee to a summer
00020  27 73 20 64 61 79 3F 0A  54 68 6F 75 20 61 72 74  's day? Thou art
00030  20 6D 6F 72 65 20 6C 6F  76 65 6C 79 20 61 6E 64   more lovely and
00040  20 6D 6F 72 65 20 74 65  6D 70 65 72 61 74 65 3A   more temperate:
00050  0A 52 6F 75 67 68 20 77  69 6E 64 73 20 64 6F 20   Rough winds do 
00060  73 68 61 6B 65 20 74 68  65 20 64 61 72 6C 69 6E  shake the darlin
00070  67 20 62 75 64 73 20 6F  66 20 4D 61 79 2C 0A 41  g buds of May, A
00080  6E 64 20 73 75 6D 6D 65  72 27 73 20 6C 65 61 73  nd summer's leas
00090  65 20 68 61 74 68 20 61  6C 6C 20 74 6F 6F 20 73  e hath all too s
000A0  68 6F 72 74 20 61 20 64  61 74 65 3B 0A 53 6F 6D  hort a date; Som
000B0  65 74 69 6D 65 20 74 6F  6F 20 68 6F 74 20 74 68  etime too hot th
000C0  65 20 65 79 65 20 6F 66  20 68 65 61 76 65 6E 20  e eye of heaven 
000D0  73 68 69 6E 65 73 2C 0A  41 6E 64 20 6F 66 74 65  shines, And ofte
000E0  6E 20 69 73 20 68 69 73  20 67 6F 6C 64 20 63 6F  n is his gold co
000F0  6D 70 6C 65 78 69 6F 6E  20 64 69 6D 6D 27 64 3B  mplexion dimm'd;
00100  0A 41 6E 64 20 65 76 65  72 79 20 66 61 69 72 20   And every fair 
00110  66 72 6F 6D 20 66 61 69  72 20 73 6F 6D 65 74 69  from fair someti
00120  6D 65 20 64 65 63 6C 69  6E 65 73 2C 0A 42 79 20  me declines, By 
00130  63 68 61 6E 63 65 20 6F  72 20 6E 61 74 75 72 65  chance or nature
00140  27 73 20 63 68 61 6E 67  69 6E 67 20 63 6F 75 72  's changing cour
00150  73 65 20 75 6E 74 72 69  6D 6D 27 64 3B 0A 42 75  se untrimm'd; Bu
00160  74 20 74 68 79 20 65 74  65 72 6E 61 6C 20 73 75  t thy eternal su
00170  6D 6D 65 72 20 73 68 61  6C 6C 20 6E 6F 74 20 66  mmer shall not f
00180  61 64 65 2C 0A 4E 6F 72  20 6C 6F 73 65 20 70 6F  ade, Nor lose po
00190  73 73 65 73 73 69 6F 6E  20 6F 66 20 74 68 61 74  ssession of that
001A0  20 66 61 69 72 20 74 68  6F 75 20 6F 77 27 73 74   fair thou ow'st
001B0  3B 0A 4E 6F 72 20 73 68  61 6C 6C 20 64 65 61 74  ; Nor shall deat
001C0  68 20 62 72 61 67 20 74  68 6F 75 20 77 61 6E 64  h brag thou wand
001D0  65 72 27 73 74 20 69 6E  20 68 69 73 20 73 68 61  er'st in his sha
001E0  64 65 2C 0A 57 68 65 6E  20 69 6E 20 65 74 65 72  de, When in eter
001F0  6E 61 6C 20 6C 69 6E 65  73 20 74 6F 20 74 69 6D  nal lines to tim
00200  65 20 74 68 6F 75 20 67  72 6F 77 27 73 74 3A 0A  e thou grow'st: 
00210  53 6F 20 6C 6F 6E 67 20  61 73 20 6D 65 6E 20 63  So long as men c
00220  61 6E 20 62 72 65 61 74  68 65 20 6F 72 20 65 79  an breathe or ey
00230  65 73 20 63 61 6E 20 73  65 65 2C 0A 53 6F 20 6C  es can see, So l
00240  6F 6E 67 20 6C 69 76 65  73 20 74 68 69 73 2C 20  ong lives this, 
00250  61 6E 64 20 74 68 69 73  20 67 69 76 65 73 20 6C  and this gives l
00260  69 66 65 20 74 6F 20 74  68 65 65 2E              ife to thee.

```



### Command-line options

- As a command-line utility, options and features are controlled by **switches** - additional command-line arguments that activate, deactivate, or specify quantities and limits.
- In Linux, these switches have a format: `-a`, where a letter is preceded by a dash or hyphen.

- In Linux, we can specify multiple switches:

  - ```sh
    dumpfile -a -b -c
    ```

  - These can be bunched together:

    - ```shell
      dumpfile -abc
      ```

  - And some switches can have options:

    ```sh
    dumpfile -q:5
    ```

- We can also take advantage of a handy C library feature: the `getopt()` function. 

  - It helps our program process switches so that we don't have to write the code.



### Using the `getopt()` function

- The `getopt()` function helps our code process command-line switches.

```C
int getopt(int argc, char* const argv[], const char *optstring);
```

- The first two arguments are identical to the `main()` function's `argc` and `*argv[]` arguments.

- The final argument `optstring`, is a list of valid switch characters.

- For example:

  - ```C
    getopt(argc, argv, "abc")
    ```

  - Valid switches here are `-a`, `-b` and `-c`.

  - The function is called repeatedly, each time returning the ASCII code for a valid character (an int value), the character '?' for an unknown option, or -1 when the function has exhausted command-line options.

- The companion `getopt_long()` function handles full word switches.

- Both `getopt()` and `getopt_long()` require that the `unistd.h` header file be included in our code.



In the next listing, shows code as a test before adding the `getopt()` function to our previous `dumpfile` code.

- Global variable `opterr` is set to zero to ensure that `getopt()` doesn't output its own error messages.
- The `getopt()` function itself resides inside a while loop's condition.
- The function's return value is compared with -1, meaning that all command-line arguments have been examined, which stops the loop.
- Otherwise, the value returned in variable `r` is used in a `switch-case` structure to indicate which option is set.
- This setup is how the `getopt()` function is typically implemented.

```C
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>

int main(int argc, char *argv[]){
    int r;
    
    // Suppresses error output from getopt()
    opterr = 0;
    
    // Scans the arguments, repeating the loop until every argument is processed
    while((r = getopt(argc, argv, "abc")) != -1){
        // Examines the character returned
        switch(r){
            case 'a':
            	puts("alfa option set");
            	break;
        	case 'b':
            	puts("bravo option set");
            	break;
        	case 'c':
            	puts("charlie option set");
            	break;
        	case '?':
            	printf("Switche '%c' is 						invalid\n", optopt);
        	default:
            	puts("Unknown option");   
        }
    }
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
chan@CMA:~/C_Programming/test$ ./final -a -b -c
alfa option set
bravo option set
charlie option set

chan@CMA:~/C_Programming/test$ ./final -c -a -b
charlie option set
alfa option set
bravo option set

chan@CMA:~/C_Programming/test$ ./final -cb
charlie option set
bravo option set

chan@CMA:~/C_Programming/test$ ./final -u -a
Switche 'u' is invalid
Unknown option
alfa option set


```

- The `getopt()` function allows us all the flexibility to read options in this manner without having to code the complex comparisons and processing ourselves.
- The next step is too add variables that represent on-off switches for what  the options attempt to accomplish.

```C
int main(int argc, char *argv[])
{
    int r;

    int alfa, bravo, charlie;

    // Each variable is initialized before the getopt() statement in the while loop
    opterr = 0;
    alfa = 0;
    bravo = 0;
    charlie = 0;

    while ((r = getopt(argc, argv, "abc")) != -1)
    {
        // Removes the puts() statement and replace them with statements that set the variables value to 1 (TRUE) for active
        switch (r)
        {
        case 'a':
            alfa = 1;
            break;
        case 'b':
            bravo = 1;
            break;
        case 'c':
            charlie = 1;
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    if (alfa)
        puts("alfa option set");
    if (bravo)
        puts("bravo option set");
    if (charlie)
        puts("charlie option set");
    if (alfa + bravo + charlie == 0)
        puts("No options set");

    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final
No options set
chan@CMA:~/C_Programming/test$ ./final -a -b -c
alfa option set
bravo option set
charlie option set
```

- Because the switches can be examined in this new code, a lack of options is easily identified.
- The remaining variations for the switches have the same output as the original program.
- The difference is that the program is now aware of the settings and can examine the variables to perform whatever magic is requested.



### Updating the `dumpfile` program code

- To add command-line options to a utility, we must know what the options do.

- Then we use a function like `getopt()` to scan for and set the options.

- For the `dumpfile` program, the appropriate suggestions are:

  - `-a` for abbreviated output
  - `-o` for octal output
  - `-h` for help

- The following code checks to see whether the `-h` "help" switch is specified first.

  - If not, the program may attempt to open the file `-h`.

  - So, a quick comparison is made for `-h` as the first argument.

  - If found, the `help()` function is called:

  - ```C
    filename = argv[1];
    
    if(strcmp(filename, "-h") == 0){
        help();
    }
    ```

  - Because the program assumes the first argument is a filename, this step is necessary even if we use the `getopt()` function elsewhere in the code to look for the `-h` switch.



In the next listing for the updated code for `dumpfile` , each of the three valid switches `-a`, `-o` and `-h` are tested for in a while loop.

- To process the rest of the switches, a single `int` variable `options`.
- It is initialized to zero, along with other variables used elsewhere in the main() function.
- For two of the switches, a macro alters the value of variable `options: set_abbr()` for `-a` and `set_oct()` for `-o`. 
- If the help switch is specified, the `help()` function is called where text is output and the program terminates.

#### Setting abbreviated output

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>

extern int options;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
    SIZE = 16, // 16 bytes per line
    ABBR = 1, // Abbreviation status is bit 1.
    OCT = 2, // Octal output status is bit 2.
};

// Uses the bitwise logical OR to set bit 1 (ABBR) in variable options
#define set_abbr() options |= ABBR

// Uses the bitwise logical AND to test bit 1 (ABBR) in variable options
#define test_abbr() ((options & ABBR) == ABBR)

// Uses the bitwise logical OR to set bit 2 (OCT) in variable options
#define set_oct() options |= OCT

// Uses the bitwise logical AND to test bit 2 (OCT) in variable options
#define test_oct() ((options & OCT) == OCT)

void line_out(int offset, int length, unsigned char *data);

void help(void);
#endif
```

- The defined constants `ABBR` and `OCT` represent bit positions in the variable `options` that don't overlap.
- Each bit can be set or examined without changing the other bits.
- The macro `set_abbr()` and `set_oct()` allow the code to modify the variable `options` by setting specific bits.
  - **`set_abbr()`**: Activates the **abbreviated output** mode by setting the `ABBR` flag in the `options` variable.
  - **`set_oct()`**: Activates the **octal output** mode by setting the `OCT` flag in the `options` variable.
  - **`test_abbr()`**: Checks if the **abbreviated output** mode is active by verifying if the `ABBR` flag is set in `options`.
  - **`test_oct()`**: Checks if the **octal output** mode is active by verifying if the `OCT` flag is set in `options`.

`hello.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int options = 0;

void line_out(int offset, int length, unsigned char *data)
{
    int a;
	
    // exectued when the test_abbr() returns zero
    if (!test_abbr())
    {

        printf("%05X ", offset);
    }

    for (a = 0; a < length; a++)
    {
        printf(" %02X", data[a]);

        if ((a + 1) % 8 == 0 && !test_abbr())
        {
            putchar(' ');
        }
    }

    if (length < SIZE)
    {
        for (; a < SIZE; a++)
        {
            printf("   ");
            if ((a + 1) % 8 == 0)
            {
                putchar(' ');
            }
        }
    }

    if (!test_abbr())
    {

        putchar(' ');
        for (a = 0; a < length; a++)
        {
            if (data[a] >= ' ' && data[a] <= '~')
            {
                putchar(data[a]);
            }
            else
            {
                putchar(' ');
            }
        }
    }
    putchar('\n');
}

void help(void)
{
    puts("dumpfile - output a file's raw data");
    puts("Format: dumpfile filename [options]");
    puts("Options:");
    puts("-a abbreviated output");
    puts("-o output octal instead of hex");
    puts("-h display this text");
    exit(1);
}
```

`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int r, ch, offset, index;

    if (argc < 2)
    {
        puts("Format: dumpfile filename [options]");
        exit(1);
    }

    filename = argv[1];

    if (strcmp(filename, "-h") == 0)
    {
        help();
    }

    fp = fopen(filename, "r");

    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }

    offset = index = opterr = options = 0;
	
    // Valid switches are a, o, s and h.
    while ((r = getopt(argc, argv, "aosh")) != -1)
    {
        switch (r)
        {
        case 'a':
            set_abbr();
            break;
        case 'o':
            set_oct();
            break;
        case 'h':
            help();
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    while ((ch = fgetc(fp)) != EOF)
    {
        buffer[index++] = ch;

        if (index == SIZE)
        {
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }

    // Handles remaining bytes after EOF
    if (index > 0)
    {
        line_out(offset, index, buffer);
    }

    fclose(fp);

    return 0;
}
```

- **Variables Initialized:**
  - `offset = 0`: Tracks the current byte position.
  - `index = 0`: Tracks the position within the buffer.
  - `buffer[16]`: Stores 16 bytes from the file.
- **Reading Loop:**
  - The program reads the file **one byte at a time** using `fgetc`.
  - Each byte is stored in `buffer[index]`.
  - When `index` reaches `16`:
    - Calls `line_out(offset, SIZE, buffer)` to process and print the chunk.
    - Updates:
      - `offset += SIZE` → Moves to the next byte position.
      - `index = 0` → Resets the buffer index.
- **End of File:**
  - After reading all bytes, if `index > 0` (last partial chunk), it calls `line_out(offset, index, buffer)` to process remaining bytes.

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt -h
dumpfile - output a file's raw data
Format: dumpfile filename [options]
Options:
-a abbreviated output
-o output octal instead of hex
-h display this text

chan@CMA:~/C_Programming/test$ ./final sonnet18.txt -a
 53 68 61 6C 6C 20 49 20 63 6F 6D 70 61 72 65 20
 74 68 65 65 20 74 6F 20 61 20 73 75 6D 6D 65 72
 27 73 20 64 61 79 3F 0A 54 68 6F 75 20 61 72 74
 20 6D 6F 72 65 20 6C 6F 76 65 6C 79 20 61 6E 64
 20 6D 6F 72 65 20 74 65 6D 70 65 72 61 74 65 3A
 0A 52 6F 75 67 68 20 77 69 6E 64 73 20 64 6F 20
 73 68 61 6B 65 20 74 68 65 20 64 61 72 6C 69 6E
 67 20 62 75 64 73 20 6F 66 20 4D 61 79 2C 0A 41
 6E 64 20 73 75 6D 6D 65 72 27 73 20 6C 65 61 73
 65 20 68 61 74 68 20 61 6C 6C 20 74 6F 6F 20 73
 68 6F 72 74 20 61 20 64 61 74 65 3B 0A 53 6F 6D
 65 74 69 6D 65 20 74 6F 6F 20 68 6F 74 20 74 68
 65 20 65 79 65 20 6F 66 20 68 65 61 76 65 6E 20
 73 68 69 6E 65 73 2C 0A 41 6E 64 20 6F 66 74 65
 6E 20 69 73 20 68 69 73 20 67 6F 6C 64 20 63 6F
 6D 70 6C 65 78 69 6F 6E 20 64 69 6D 6D 27 64 3B
 0A 41 6E 64 20 65 76 65 72 79 20 66 61 69 72 20
 66 72 6F 6D 20 66 61 69 72 20 73 6F 6D 65 74 69
 6D 65 20 64 65 63 6C 69 6E 65 73 2C 0A 42 79 20
 63 68 61 6E 63 65 20 6F 72 20 6E 61 74 75 72 65
 27 73 20 63 68 61 6E 67 69 6E 67 20 63 6F 75 72
 73 65 20 75 6E 74 72 69 6D 6D 27 64 3B 0A 42 75
 74 20 74 68 79 20 65 74 65 72 6E 61 6C 20 73 75
 6D 6D 65 72 20 73 68 61 6C 6C 20 6E 6F 74 20 66
 61 64 65 2C 0A 4E 6F 72 20 6C 6F 73 65 20 70 6F
 73 73 65 73 73 69 6F 6E 20 6F 66 20 74 68 61 74
 20 66 61 69 72 20 74 68 6F 75 20 6F 77 27 73 74
 3B 0A 4E 6F 72 20 73 68 61 6C 6C 20 64 65 61 74
 68 20 62 72 61 67 20 74 68 6F 75 20 77 61 6E 64
 65 72 27 73 74 20 69 6E 20 68 69 73 20 73 68 61
 64 65 2C 0A 57 68 65 6E 20 69 6E 20 65 74 65 72
 6E 61 6C 20 6C 69 6E 65 73 20 74 6F 20 74 69 6D
 65 20 74 68 6F 75 20 67 72 6F 77 27 73 74 3A 0A
 53 6F 20 6C 6F 6E 67 20 61 73 20 6D 65 6E 20 63
 61 6E 20 62 72 65 61 74 68 65 20 6F 72 20 65 79
 65 73 20 63 61 6E 20 73 65 65 2C 0A 53 6F 20 6C
 6F 6E 67 20 6C 69 76 65 73 20 74 68 69 73 2C 20
 61 6E 64 20 74 68 69 73 20 67 69 76 65 73 20 6C
 69 66 65 20 74 6F 20 74 68 65 65 2E    
```

**Macro Execution:**

- `-a` Switch Detected:

  - The program calls the macro `set_abbr()`.

  - Macro Definition (`hello.h`):

    ```C
    #define set_abbr() options |= ABBR
    ```

  - Effect:

    - Sets the `ABBR` flag in the `options` variable.
    - **`options` Before:** `0000` (binary)
    - **`ABBR` Value:** `0001` (binary)
    - **`options` After:** `0001` (binary)

**Macro Checks:**

- **`test_abbr()` Macro (`hello.h`):**

- ```C
  #define test_abbr() ((options & ABBR) == ABBR)
  ```

- **Result:** Returns `true` since `ABBR` flag is set.

- ```C
  if (!test_abbr())
  {
      printf("%05X ", offset);
  }
  ```

- Since `test_abbr()` is `true`:

  - Offset (`%05X`) and ASCII Representation are not printed.

- **Hexadecimal Printing:**

  - Iterates through each byte in `buffer` and prints its hexadecimal value.

  - Extra Space After 8 Bytes:

    ```C
    if ((a + 1) % 8 == 0 && !test_abbr())
    
    {
    
      putchar(' ');
    
    }
    ```

  - Since `test_abbr()` is `true`:

    - **No extra space added.**



#### Activating octal output

- To specify octal, we use the zero prefix: `01` is octal 1, `010` is octal 10 (decimal 8), and so on.

- The `printf()` and `scanf()` placeholder for octal values is `%o`.

- Like other placeholders, it features width values and zero-padding.

- Three changes are required to activate the `-o` switch.

  1. When the octal switch is active, the first column needs to output octal values instead of hex. The decision is in addition to whether the column is output when `test_abbr()` macro is true (or false).

     ```C
     if(!test_abbr()){
         if(test_oct()){
             printf("%05o ", offset);
         }else{
             printf("%05X ", offset);
         }
     }
     ```

     - The `%05o` placeholder outputs the value of variable offset as an octal number five digits wide with zeros padded on the left.

  2. The next change takes place in the `for` loop that outputs the bytes.

     - When the `test_oct()` macro returns TRUE, octal values are output instead of decimal:

     ```C
     if(test_oct()){
         printf(" %03o", data[a]);
     }else{
         printf(" %02X", data[a]);
     }
     ```

     - The placeholder `%03o` outputs an octal value three digits wide with zeros padded on the left.

  3. The final change is made when the last line of output is shorter than 16 bytes. 

     - Because the octal values are output three characters wide instead of two, four spaces are needed for each missing byte to line up the ASCII column.

     ```C
     if(test_oct()){
         printf("    ");
     }else{
         printf("   ");
     }
     ```

     

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>

extern int options;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
    SIZE = 16,
    ABBR = 1,
    OCT = 2,
};

#define set_abbr() options |= ABBR
#define test_abbr() ((options & ABBR) == ABBR)
#define set_oct() options |= OCT
#define test_oct() ((options & OCT) == OCT)

void line_out(int offset, int length, unsigned char *data);

void help(void);
#endif
```

`hello.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int options = 0;

void line_out(int offset, int length, unsigned char *data)
{
    int a;

    if (!test_abbr())
    {
        if (test_oct())
        {
            printf("%05o ", offset);
        }
        else
        {

            printf("%05X ", offset);
        }
    }

    for (a = 0; a < length; a++)
    {
        if (test_oct())
        {
            printf(" %03o", data[a]);
        }
        else
        {

            printf(" %02X", data[a]);
        }

        if ((a + 1) % 8 == 0 && !test_abbr())
        {
            putchar(' ');
        }
    }

    if (length < SIZE)
    {
        for (; a < SIZE; a++)
        {
            if (test_oct())
            {
                printf("    ");
            }
            else
            {

                printf("   ");
            }
            if ((a + 1) % 8 == 0)
            {
                putchar(' ');
            }
        }
    }

    if (!test_abbr())
    {

        putchar(' ');
        for (a = 0; a < length; a++)
        {
            if (data[a] >= ' ' && data[a] <= '~')
            {
                putchar(data[a]);
            }
            else
            {
                putchar(' ');
            }
        }
    }
    putchar('\n');
}

void help(void)
{
    puts("dumpfile - output a file's raw data");
    puts("Format: dumpfile filename [options]");
    puts("Options:");
    puts("-a abbreviated output");
    puts("-o output octal instead of hex");
    puts("-h display this text");
    exit(1);
}
```

`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int r, ch, offset, index;

    if (argc < 2)
    {
        puts("Format: dumpfile filename [options]");
        exit(1);
    }

    filename = argv[1];

    if (strcmp(filename, "-h") == 0)
    {
        help();
    }

    fp = fopen(filename, "r");

    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }

    offset = index = opterr = options = 0;

    while ((r = getopt(argc, argv, "aoh")) != -1)
    {
        switch (r)
        {
        case 'a':
            set_abbr();
            break;
        case 'o':
            set_oct();
            break;
        case 'h':
            help();
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    while ((ch = fgetc(fp)) != EOF)
    {
        buffer[index++] = ch;

        if (index == SIZE)
        {
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }

    // Handles remaining bytes after EOF
    if (index > 0)
    {
        line_out(offset, index, buffer);
    }

    fclose(fp);

    return 0;
}
```



`Output`

![Screenshot from 2024-11-18 19-40-21](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-18 19-40-21.png)

**Exercise 9.5**

How about adding one more switch to the dumpfile program? The `-v` switch is commonly used to output the program’s version number. I would recommend setting these values as defined constants: separate major and minor version numbers, or a complete version number string. Add both the -v switch as well as the code (the version() function) to output the
version number. The program can quit after performing this task. And remember that
some users may use the -v switch as the program’s only argument.

**Solution**

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>

extern int options;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
    SIZE = 16,
    ABBR = 1,
    OCT = 2,
    VERSION_MAJOR = 1,
    VERSION_MINOR = 0,
};

#define set_abbr() options |= ABBR
#define test_abbr() ((options & ABBR) == ABBR)
#define set_oct() options |= OCT
#define test_oct() ((options & OCT) == OCT)

void line_out(int offset, int length, unsigned char *data);

void help(void);

void version(void);
#endif
```

`hello.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int options = 0;

void line_out(int offset, int length, unsigned char *data)
{
    int a;

    if (!test_abbr())
    {
        if (test_oct())
        {
            printf("%05o ", offset);
        }
        else
        {

            printf("%05X ", offset);
        }
    }

    for (a = 0; a < length; a++)
    {
        if (test_oct())
        {
            printf(" %03o", data[a]);
        }
        else
        {

            printf(" %02X", data[a]);
        }

        if ((a + 1) % 8 == 0 && !test_abbr())
        {
            putchar(' ');
        }
    }

    if (length < SIZE)
    {
        for (; a < SIZE; a++)
        {
            if (test_oct())
            {
                printf("    ");
            }
            else
            {

                printf("   ");
            }
            if ((a + 1) % 8 == 0)
            {
                putchar(' ');
            }
        }
    }

    if (!test_abbr())
    {

        putchar(' ');
        for (a = 0; a < length; a++)
        {
            if (data[a] >= ' ' && data[a] <= '~')
            {
                putchar(data[a]);
            }
            else
            {
                putchar(' ');
            }
        }
    }
    putchar('\n');
}

void help(void)
{
    puts("dumpfile - output a file's raw data");
    puts("Format: dumpfile filename [options]");
    puts("Options:");
    puts("-a abbreviated output");
    puts("-o output octal instead of hex");
    puts("-h display this text");
    exit(1);
}

void version(void){
    printf("DumpFile Utility Version %d.%d\n", VERSION_MAJOR, VERSION_MINOR);
    exit(1);
}
```

`main.c`

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[SIZE];
    char *filename;
    FILE *fp;
    int r, ch, offset, index;

    if (argc < 2)
    {
        puts("Format: dumpfile filename [options]");
        exit(1);
    }

    filename = argv[1];

    if (strcmp(filename, "-h") == 0)
    {
        help();
    }

    fp = fopen(filename, "r");

    if (fp == NULL)
    {
        fprintf(stderr, "Unable to open file '%s'\n", filename);
        exit(1);
    }

    offset = index = opterr = options = 0;

    while ((r = getopt(argc, argv, "aohv")) != -1)
    {
        switch (r)
        {
        case 'a':
            set_abbr();
            break;
        case 'o':
            set_oct();
            break;
        case 'h':
            help();
            break;
        case 'v':
            version();
            break;
        case '?':
            printf("Switch '%c' is invalid\n", optopt);
            break;
        default:
            puts("Unknown option");
        }
    }

    while ((ch = fgetc(fp)) != EOF)
    {
        buffer[index++] = ch;

        if (index == SIZE)
        {
            line_out(offset, SIZE, buffer);
            offset += SIZE;
            index = 0;
        }
    }

    // Handles remaining bytes after EOF
    if (index > 0)
    {
        line_out(offset, index, buffer);
    }

    fclose(fp);

    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt -v
DumpFile Utility Version 1.0
```



---

## Chapter 10 - Directory tree

- The point of the directory tree utility is to output a map of the directory structure.
- The map details which directories are parents and children of each other.



### The filesystem

- The filesystem's duty is to organize storage.
- It takes a file's data and writes it to one or more locations on the media.
- This information is recorded along with other file details, such as the file's name, size, dates (created, modified, accessed), permissions, and so on.
- In a Linux terminal window, use the `man fs` command to review details on how Linux uses a filesystem and the different filesystems available.
- The `/proc/filesystems` directory lists available filesystems for your Linux installation.



### File and directory details

- To gather directory details at the command prompt, use the `ls` command.
- The output is a list of filenames in the current directory.
- For more details, the `-l` (long) switch is specified.

```shell
chan@CMA:~/C_Programming/test$ ls
alphabeta.wtxt  cyrillic.wtxt  hello.c  libs    Makefile  sonnet18.txt
bytes.dat       final          hello.h  main.c  obj
chan@CMA:~/C_Programming/test$ ls -l
total 64
-rw-rw-r-- 1 chan chan    49 Nov 13 22:56 alphabeta.wtxt
-rw-rw-r-- 1 chan chan   256 Nov 16 22:31 bytes.dat
-rw-rw-r-- 1 chan chan    65 Nov 14 20:07 cyrillic.wtxt
-rwxrwxr-x 1 chan chan 21216 Nov 18 21:00 final
-rw-rw-r-- 1 chan chan  1717 Nov 18 21:00 hello.c
-rw-rw-r-- 1 chan chan   497 Nov 18 21:00 hello.h
drwxrwxr-x 2 chan chan  4096 Nov 18 21:00 libs
-rw-rw-r-- 1 chan chan  1857 Nov 18 20:59 main.c
-rw-rw-r-- 1 chan chan   949 Nov 12 14:23 Makefile
drwxrwxr-x 2 chan chan  4096 Nov 18 21:00 obj
-rw-rw-r-- 1 chan chan   620 Nov 17 19:48 sonnet18.txt

```

- The details output by the `ls -l` command are stored in the directory like a database.
- In face, directories on storage media are really database.
- Their records aren't specifically files, but rather inodes.
- `inodes` is a collection of data that describes a file.



### Gathering file info

- To obtain details about a file, as well as to read a directory, we need to access inode data.
- The command-line program that does so is called `stat`.
- Below is the sample output on the `stat` program file `libs` inside my current directory `test`.

```shell
chan@CMA:~/C_Programming/test$ ls
alphabeta.wtxt  cyrillic.wtxt  hello.c  libs    Makefile  sonnet18.txt
bytes.dat       final          hello.h  main.c  obj
chan@CMA:~/C_Programming/test$ stat libs
  File: libs
  Size: 4096      	Blocks: 8          IO Block: 4096   directory
Device: 8,4	Inode: 2102431     Links: 2
Access: (0775/drwxrwxr-x)  Uid: ( 1000/    chan)   Gid: ( 1000/    chan)
Access: 2024-11-18 21:00:54.003506081 +0700
Modify: 2024-11-18 21:00:53.554497165 +0700
Change: 2024-11-18 21:00:53.554497165 +0700
 Birth: 2024-11-12 14:11:39.733013969 +0700
```



- To read this same information in our C programs, we use the `stat()` function.

  - It's prototyped in the `sys/stat.h` header file.

  ```C
  int stat(const char *pathname, struct stat *statbuf);
  ```

  - The `pathname` is a filename or a full pathname.
  - Argument `statbuf` is the address of a `stat` structure.
  - Here is a typical `stat()` function statement, with the `filename` `char` pointer containing the filename, `fs` as a `stat` structure, and `int` variable `r` capturing the return value.

  ```C
  r = stat(filename, &fs);
  ```

  - Upon failure, value -1 is returned.
  - Otherwise, 0 is returned and the `stat` structure `fs` is joyously filled with details about the file - inode data.

- The following table lists the common members of the `stat` structure, though different filesystems and operating systems add or change specific members.

![Screenshot from 2024-11-18 21-32-58](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-18 21-32-58.png)

- Most of the `stat` structure members are integers.
- They are all `unsigned`, though some values are `unsigned long`.

### **`struct stat` Definition**

Defined in the `<sys/stat.h>` header, **`struct stat`** typically includes the following members (note that actual implementations may have additional members):

```C
struct stat {
    dev_t     st_dev;     // ID of device containing file
    ino_t     st_ino;     // Inode number
    mode_t    st_mode;    // File type and mode (permissions)
    nlink_t   st_nlink;   // Number of hard links
    uid_t     st_uid;     // User ID of owner
    gid_t     st_gid;     // Group ID of owner
    dev_t     st_rdev;    // Device ID (if special file)
    off_t     st_size;    // Total size, in bytes
    blksize_t st_blksize; // Block size for filesystem I/O
    blkcnt_t  st_blocks;  // Number of 512B blocks allocated
    time_t    st_atime;   // Time of last access
    time_t    st_mtime;   // Time of last modification
    time_t    st_ctime;   // Time of last status change
};

```





```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <time.h>
int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        fprintf(stderr, "Specify a filename\n");
        exit(1);
    }

    filename = argv[1];
    printf("Info for file '%s'\n", filename);
    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "Error reading '%s'\n", filename);
        exit(1);
    }

    // Outputs the members of the stat structure fs
    printf("Media ID: %lu\n", fs.st_dev);
    printf("Inode number: %lu\n", fs.st_ino);
    printf("Type and mode: %u\n", fs.st_mode);
    printf("Hard links = %lu\n", fs.st_nlink);
    printf("Owner ID: %u\n", fs.st_uid);
    printf("Group ID: %u\n", fs.st_gid);
    printf("Device ID: %lu\n", fs.st_rdev);
    printf("File size %lu bytes\n", fs.st_size);
    printf("Block size = %lu\n", fs.st_blksize);
    printf("Allocated blocks = %lu\n", fs.st_blocks);
    
    // The time structures use the ctime() function to output their values.
    printf("Access: %s", ctime(&fs.st_atime));
    printf("Modified: %s", ctime(&fs.st_mtime));
    printf("Changed: %s", ctime(&fs.st_ctime));
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final libs
Info for file 'libs'
Media ID: 2052
Inode number: 2102431
Type and mode: 16893
Hard links = 2
Owner ID: 1000
Group ID: 1000
Device ID: 0
File size 4096 bytes
Block size = 4096
Allocated blocks = 8
Access: Mon Nov 18 21:40:43 2024
Modified: Mon Nov 18 21:40:43 2024
Changed: Mon Nov 18 21:40:43 2024
```



### Exploring file type and permissions

- Examining a file's (or inode's) `st_mode` is how we determine whether a file is a regular old file, a directory, or some other special type of file.
- In the Linux environment, everything is a file.
- Using the `stat()` function is how our code can determine which type of file the inode represents.
- The bit fields in the `st_mode` member of the `stat` structure describe the file's permissions.
- The `S_ISREG()` macro returns TRUE for regular files.

```C
printf("Type and mode: %X\n", fs.st_mode);
if(S_ISREG(fs.st_mode)){
    printf("%s is a regular file\n", filename);
}else{
    printf("%s is not a regular file\n", filename);
}
```

- A directory isn't a regular file.



**Short definition of `fs.st_mode`**

"In C programming, particularly when dealing with file system operations, **`fs.st_mode`** refers to the **`st_mode`** member of the **`struct stat`** structure. This member plays a crucial role in providing information about a file's type and its permission settings. Understanding **`st_mode`** is essential for tasks such as checking if a file is a regular file, directory, symbolic link, or for verifying its read/write/execute permissions."





Table 10.2 Macros defined in `sys/stat.h` to help determine file type

| Macro        | True for this type of file                                  |
| ------------ | ----------------------------------------------------------- |
| `S_ISBLK()`  | Block special, such as mass storage in the `/dev` directory |
| `S_ISCHR()`  | Character special, such as a pipe or the `/dev/null` device |
| `S_ISDIR()`  | Directories                                                 |
| `S_ISFIFO()` | A FIFO (named pipe) or socket                               |
| `S_ISREG()`  | Regular files                                               |
| `S_ISLNK()`  | Symbolic link                                               |
| `S_ISSOCK()` | Socket                                                      |



```shell
chan@CMA:~/C_Programming/test$ ls -l sonnet18.txt
-rw-rw-r-- 1 chan chan 620 Nov 17 19:48 sonnet18.txt

```

- The first chunk of info `-rw-rw-r--` indicates the file type and permissions.
- Next is the number of hard links `1`.
- The owner `chan`.
- The group `chan`.
- The `620` is the file size in bytes.
- And then comes the date and timestamp, and finally the filename.



Three sets of file permissions octets are used for a file. These sets are based on user classification:

- Owner
- Group
- Other

You are the owner of the files you create.

As a user on the computer, you are also a member of a group.

We can use the `id` command to view our username and ID number, as well as the groups we belong to.

- View the `/etc/group` file to see the full list of groups on the system.

```shell
cat /etc/group
```



- The value (a file's owner and group) is interpreted from the `st_mode` member of the file's `stat` structure.



| Defined constant | Permission octet         |
| ---------------- | ------------------------ |
| `S_IRUSR`        | Owner read permission    |
| `S_IWUSR`        | Owner write permission   |
| `S_IXUSR`        | Owner execute permission |
| `S_IRGRP`        | Group read permission    |
| `S_IWGRP`        | Group write permission   |
| `S_IXGRP`        | Group execute permission |
| `S_IROTH`        | Other read permission    |
| `S_IWOTH`        | Other write permission   |
| `S_IXOTH`        | Other execute permission |

- These defined constants follow a naming pattern: 
  - each defined constants start with `S_I`.
  - The `I` is followed by `R`, `W`, or `X` for read, write or execute, respectively.
  - This letter is followed by `USR`, `GRP`, `OTH` for Owner(user), Group, and Other.
- For example, if we want to test the read permission for a group user, we use the `S_IRGRP` defined constant.
- This defined constant is used in an `if` test  with a bitwise `AND` operator to test the permission bit on the `st_mode` member.

```C
if(fs.st_mode & S_IRGRP)
```

- The line `if (fs.st_mode & S_IRGRP)` checks whether the **group** associated with the file has **read** permissions.

- **Bitwise AND Operation**:

  - `fs.st_mode & S_IRGRP` performs a bitwise AND between the file's mode and the group read permission bitmask.
  - This operation **isolates** the group read permission bit.

- **Condition Evaluation**:

  - **Non-Zero Result**: Indicates that the **group read permission** is **set**.
  - **Zero Result**: Indicates that the **group read permission** is **not set**.

- **Example**:

  - Suppose `fs.st_mode` has the value `0754` (in octal), which translates to:
    - **Owner**: Read, Write, Execute (`7` -> `rwx`)
    - **Group**: Read, Execute (`5` -> `r-x`)
    - **Others**: Read (`4` -> `r--`)
  - **`S_IRGRP`** corresponds to the bitmask for group read permission (`0040` in octal).

- **Operation**:

- `0754` in octal is `111 101 100` in binary.

- **`S_IRGRP`** (`0040` in octal) corresponds to the binary `000 100 000`.

  ```C
    111 101 100   (0754 - fs.st_mode)
  & 000 100 000   (0040 - S_IRGRP)
  = 000 100 000   (0040 - Non-zero, permission granted)
  ```

  

  ```C
  fs.st_mode = 0754;        // File permissions: rwxr-xr--
  S_IRGRP    = 0040;        // Group read permission bitmask
  
  fs.st_mode & S_IRGRP = 0754 & 0040 = 0040 (non-zero)
  ```

- **Result**:

  - Since the result is `0040` (non-zero), the condition `if (fs.st_mode & S_IRGRP)` evaluates to **true**, indicating that the group **has read permission** for this file.

#### The `st_mode` Member

##### **What is `st_mode`?**

- **Type:** `mode_t` (an integer type)
- **Purpose:** Encodes both the **file type** and the **file mode (permissions)**

##### **Components Encoded in `st_mode`:**

1. **File Type:** Indicates whether the file is a regular file, directory, symbolic link, etc.
2. **Permissions:** Specifies read, write, and execute permissions for the owner, group, and others.

```C
int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        puts("Filename required");
        exit(1);
    }

    filename = argv[1];

    printf("Obtaining permission mode for '%s'\n", filename);

    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "File error\n");
        exit(1);
    }

    printf("Permission bits: %X\n", fs.st_mode);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt
Obtaining permission mode for 'sonnet18.txt'
Permission bits: 81B4
```

- #### **Steps:**

  1. **Hex to Binary:**

     - `8` → `1000`
     - `1` → `0001`
     - `B` → `1011`
     - `4` → `0100`

     **Combined Binary:** `1000 0001 1011 0100`

  2. **Binary to Octal:**

     - Group the binary digits into sets of three (from the right):

       ```C
       1 000 000 110 110 100
       ```

     - Add leading zeros if necessary

       ```C
       001 000 000 110 110 100
       ```

     - Convert each group to its octal equivalent:

       - `001` → `1`
       - `000` → `0`
       - `000` → `0`
       - `110` → `6`
       - `110` → `6`
       - `100` → `4`

     **Combined Octal:** `0100664`

  3. **Decoding the Octal Value `0100664`**:

     - File Type (`0100000`):

     - **Octal Prefix:** `01`

     - **Meaning:** Represents a **regular file**.

     | Octal | File Type                |
     | ----- | ------------------------ |
     | `01`  | Regular File (`S_IFREG`) |

     - #### **File Permissions (`00664`):**

       - **Owner Permissions (`6`):**
         - **Read (`4`) + Write (`2`) = `6`** → `rw-`
       - **Group Permissions (`6`):**
         - **Read (`4`) + Write (`2`) = `6`** → `rw-`
       - **Others Permissions (`4`):**
         - **Read (`4`) = `4`** → `r--`
       - **Combined Permissions:** `rw-rw-r--`

     - **File Type:** Regular File

     - **Permissions:**

       - **Owner:** Read and Write
       - **Group:** Read and Write
       - **Others:** Read Only

     - **Symbolic Representation:** `-rw-rw-r--`

     ```shell
     chan@CMA:~/C_Programming/test$ ls -l sonnet18.txt
     -rw-rw-r-- 1 chan chan 620 Nov 17 19:48 sonnet18.txt
     ```

     

```C
int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        fprintf(stderr, "Specify a filename\n");
        exit(1);
    }

    filename = argv[1];
    printf("Info for file '%s'\n", filename);
    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "Error reading '%s'\n", filename);
        exit(1);
    }

    printf("File '%s' is a ", filename);
	
    // Determines the file type
    if (S_ISBLK(fs.st_mode))
    {
        printf("block special\n");
    }
    else if (S_ISCHR(fs.st_mode))
    {
        printf("character special\n");
    }
    else if (S_ISDIR(fs.st_mode))
    {
        printf("directory\n");
    }
    else if (S_ISFIFO(fs.st_mode))
    {
        printf("named pipe or socket\n");
    }
    else if (S_ISREG(fs.st_mode))
    {
        printf("regular file\n");
    }
    else if (S_ISLNK(fs.st_mode))
    {
        printf("symbolic link\n");
    }
    else if (S_ISSOCK(fs.st_mode))
    {
        printf("socket\n");
    }
    else
    {
        printf("type unknown\n");
    }
	
    // Tests owner permission bits
    printf("Owner permissions: ");
    if (fs.st_mode & S_IRUSR)
    {
        printf("read ");
    }
    if (fs.st_mode & S_IWUSR)
    {
        printf("write ");
    }
    if (fs.st_mode & S_IXUSR)
    {
        printf("execute");
    }
    putchar('\n');
	
    // Tests group permission bits
    printf("Group permissions: ");
    if (fs.st_mode & S_IRGRP)
    {
        printf("read ");
    }
    if (fs.st_mode & S_IWGRP)
    {
        printf("write ");
    }
    if (fs.st_mode & S_IXGRP)
    {
        printf("execute");
    }
    putchar('\n');
	
    // Tests other permission bits
    printf("Other permissions: ");
    if (fs.st_mode & S_IROTH)
    {
        printf("read ");
    }
    if (fs.st_mode & S_IWOTH)
    {
        printf("write ");
    }
    if (fs.st_mode & S_IXOTH)
    {
        printf("execute");
    }
    putchar('\n');
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final
Specify a filename
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt
Info for file 'sonnet18.txt'
File 'sonnet18.txt' is a regular file
Owner permissions: read write 
Group permissions: read write 
Other permissions: read 

chan@CMA:~/C_Programming/test$ ./final libs
Info for file 'libs'
File 'libs' is a directory
Owner permissions: read write execute
Group permissions: read write execute
Other permissions: read execute
```



**Exercise 10.1**

The `if-else` structures contain a lot of repetition. The task for this exercise is to write a  function that outputs a file's permissions.

Call the function `permissions_out()`. It takes a `mode_t` argument of the `st_mode` member in a `stat` structure.

```C
void permissions_out(mode_t stm);
```

Use the function to output a string of permissions for each of the three access levels, owner, group, other. Use characters r,w,x, for read, write and execute access if a bit is set; use a dash (-) for unset items. The output is the same as shown in the `ls -l` listing, but without the leading character identifying the file type.

**Solution**

```C
void permissions_out(mode_t stm)
{
    putchar(stm & S_IRUSR ? 'r' : '-');
    putchar(stm & S_IWUSR ? 'w' : '-');
    putchar(stm & S_IXUSR ? 'x' : '-');
    putchar(stm & S_IRGRP ? 'r' : '-');
    putchar(stm & S_IWGRP ? 'w' : '-');
    putchar(stm & S_IXGRP ? 'x' : '-');
    putchar(stm & S_IROTH ? 'r' : '-');
    putchar(stm & S_IWOTH ? 'w' : '-');
    putchar(stm & S_IXOTH ? 'x' : '-');
    putchar('\n');
}


int main(int argc, char *argv[])
{
    char *filename;
    struct stat fs;
    int r;

    if (argc < 2)
    {
        fprintf(stderr, "Specify a filename\n");
        exit(1);
    }

    filename = argv[1];
    printf("Info for file '%s'\n", filename);
    r = stat(filename, &fs);
    if (r == -1)
    {
        fprintf(stderr, "Error reading '%s'\n", filename);
        exit(1);
    }

    printf("File '%s' is a ", filename);

    permissions_out(fs.st_mode);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final sonnet18.txt
Info for file 'sonnet18.txt'
File 'sonnet18.txt' is a rw-rw-r--
chan@CMA:~/C_Programming/test$ ./final libs
Info for file 'libs'
File 'libs' is a rwxrwxr-x

```



### Reading a directory

- A directory is a database of files.
- Just like a file, a directory database is stored on media.
- But we can't use the `fopen()` to open and read the contents of a directory.
- Instead, we use the `opendir()` function.

```C
DIR *opendir(const char *filename);
```

- The `opendir()` function accepts a single argument, a string representing the pathname of the directory to examine.
- Specifying the shortcuts . and .. for the current and parent directory are also valid.
- The function returns a pointer to a `DIR` handle, similar to the `FILE` handle used by the `fopen()` command.
- As the `FILE` handle represents a file stream, the `DIR` handle represents a directory stream.
- Upon an error, the NULL pointer is returned.
- The global `errno` value is set, indicating the specific booboo the function encountered.
- The `opendir()` features a companion `closedir()` function.
- The `closedir()` requires a single argument, the `DIR` handle of an open directory stream, humorously called "dirp" in the `man` page format example:

```C
int closedir(DIR *dirp);
```

- `dirp` can be remembered as "directory pathname".
- Upon success, the `closedir()` returns 0. Otherwise the value -1 is returned and the global `errno` value is set.
- Both the `opendir()` and `closedir()` are prototyped in the `dirent.h` header file.

```C
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main(){
    // Directory handle
    DIR *dp;
    
    // Opens the current directory, whatever it may be
    dp = opendir(".");
    
    if(dp == NULL){
        puts("Unable to read directory");
        exit(1);
    }
    
    puts("Directory is opened!");
    
    closedir(dp);
    
    puts("Directory is closed!");
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
Directory is opened!
Directory is closed!

```

- To access the files stored in the directory, we use another function, `readdir()`.
- This function is also prototyped in the `dirent.h` header file.

```C
struct dirent *readdir(DIR *dirp);
```

- The function consumes an open DIR handle as its only argument.
- The return value is the address of a `dirent` structure, which contains details about a directory entry.
- This function is called repeatedly to read file entries (inodes) from the directory stream.
- The value NULL is returned after the final entry in the directory has been read.



Table 10.4 Common members of the `dirent` structure

| Member     | Data type (placeholder) | Description   |
| ---------- | ----------------------- | ------------- |
| `d_ino`    | `ino_t` (%lu)           | inode number  |
| `d_reclen` | `unsigned short` (%u)   | Record length |

- The best structure member to use, and one that's consistently available across all compilers and platforms, is `d_name`.

```C
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>

int main(){
    DIR *dp;
    
    // The dirent structure is created as a pointer, a memory address.
    struct dirent *entry;
    
    dp = opendir(".");
    
    if(dp == NULL){
        puts("Unable to read directory");
        exit(1);
    }
    
    // The entry is read and stored in the dirent structure entry.
    entry = readdir(dp);
    
    // The d_name member is output
    printf("File %s\n", entry->d_name);
    
    closedir(dp);
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
File alphabeta.wtxt
```

- The program outputs only one file, most likely, the entry for the current directory itself, the single dot.
- If we want a real directory-reading program, we must modify the code.
- As with using the `fread()` function to read data from a regular file, the `readdir()` function is called repeatedly.
- When the function returns a pointer to a `dirent` structure, another entry is available in the directory.
- Only when the function returns NULL has the full directory been read.
- To achieve this, we must change the `readdir()` statement into a `while` loop condition.

```C
while( (entry = readdir(dp)) != NULL){
    printf("File %s\n", entry->d_name);
}
```

- With this update, the program now outputs all files in the current directory.
- To gather more information about files in a directory, use the `stat()` function.
- The `readdir()` function's `dirent` structure contains the file's name in the `d_name` member.
- When this detail is known, we use the `stat()` function to gather details on the file's type as well as other information.

```C
#include <stdio.h>
#include <stlib.h.
#include <sys/stat.h>
#include <dirent.h>
#include <time.h>

int main(){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    int r;
    char *filename;
    
    dp = opendir(".");
    if(dp == NULL){
        puts("Unable to read directory");
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        // Saves the directory entry's name for readibility and easy access.
        filename = entry->d_name;
        
        // Fills the stat structure for the current filename/directory entry
        r = stat(filename, &fs);
        
        if(r == -1){
            fprintf(stderr, "Error reading '%s'\n", filename);
            exit(1);
        }
        
        // Calls out directories from other file types
        if(S_ISDIR(fs.st_mode)){
            
            // Output the directory filename left-justified in a 16-character width
            printf(" Dir %-16s ",filename);
        }else{
            printf("File %-16s ", filename);
        }
        
        // Outputs the file size in an 8-character width
        printf("%8lu bytes ", fs.st_size);
        
        // Outputs the access time which automatically adds a newline
        printf("%s", ctime(&fs.st_atime));
    }
    
    closedir(dp);
    
    return 0;
}
```

- `r = stat(filename, &fs)` - The `stat()` function retrieves information about the file specified by `filename` and populates the provided `struct stat` structure with this data.
  - **Parameters:**
    1. **`filename`** (`char *`):
       - The name (path) of the file we want to inspect.
    2. **`&fs`** (`struct stat *`):
       - A pointer to a `struct stat` where the function will store the file's metadata.
  - **Return Value:**
    - **`0`**: Success. The file information has been successfully retrieved and stored in `fs`.
    - **`-1`**: Failure. An error occurred (e.g., the file does not exist), and `errno` is set to indicate the specific error.
- `-16%s` - Specifies the **minimum field width** ensuring that the string occupies at least **16 characters** in the output.
- If the string is shorter than 16 characters, it's padded with spaces.
- If the string is longer, it extends beyond 16 characters without truncation.
- The minus (-) sign indicates **left-justification** within the specified field width.
  - Aligns the string to the **left**, padding spaces to the **right** if necessary.
  - Without the minus sign(-), the string would be **right-justified**, padding spaces to the left.

```shell
chan@CMA:~/C_Programming/test$ ./final
File alphabeta.wtxt         49 bytes Sat Nov 16 22:29:34 2024
 Dir libs                4096 bytes Tue Nov 19 14:55:53 2024
File final               19136 bytes Tue Nov 19 15:23:56 2024
File main.c               1293 bytes Tue Nov 19 15:23:46 2024
File Makefile              949 bytes Mon Nov 18 20:58:48 2024
File sonnet18.txt          620 bytes Mon Nov 18 20:58:54 2024
 Dir ..                  4096 bytes Mon Nov 18 19:04:16 2024
File cyrillic.wtxt          65 bytes Sun Nov 17 19:47:36 2024
File hello.c               144 bytes Tue Nov 19 14:52:20 2024
 Dir obj                 4096 bytes Tue Nov 19 15:23:55 2024
 Dir .                   4096 bytes Tue Nov 19 15:23:55 2024
File hello.h               151 bytes Tue Nov 19 14:52:25 2024
File bytes.dat             256 bytes Sat Nov 16 22:32:09 2024

```

- To truly read a directory, we need both the `readdir()` and `stat()` functions.
- Together, they pull in details about files in the directory.



### Subdirectory exploration

Directories are referenced in three ways:

- As a named path
- As the ... shortcut to the parent directory
- As a directory entry in the current directory, a subdirectory
- Whatever the approach, pathnames are either direct or relative.
- A direct path is a fully named path, starting at the root directory, our home directory, or the current directory.
- A relative pathname uses the ... shortcut for the parent directory - sometimes a lot of them.

As an example, a full pathname could be:

```shell
/home/chan/documents/finances/bank/statements
```

- This direct pathname shows the directories as they branch from the root, through my home directory, down to the `statments` directory.
- If I have another directory, `/home/chan/documents/vacations`, but I'm using the `statements` directory, the relative path from `statements` to `vacations` is:

```shell
../../../vacations
```

- The first .. represents the `bank` directory. The second .. represents the `finances` directory. The third .. represents the `documents` directory, where `vacations` exists as a subdirectory.



### Using directory exploration tools

- Two C library functions that tells the program in which directory it's currently running: `chdir()` and `getcwd()`.

- The `getcwd()` function obtains the directory in which the program is operating.

  - Think of the name as Get the Current Working Directory.

  - It works like the `pwd` command in the terminal window.

  - This function is prototyped in the `unistd.h` header file.

  - ```C
    char *getcwd(char *buf, size_t size);
    ```

  - Buffer `buf` is a character array or buffer of `size` characters.

  - It's where the current directory string is saved, an absolute path from the root.

  - We can also use the `BUFSIZ` defined constant for the size of the buffer as well as the second argument to `getcwd()`.

  - The return value from `getcwd()` is the same character string saved in `buf`, or NULL upon an error.

  - For the specific error, check the global `errno` variable.

```C
#include <stdio.h>
#include <unistd.h>

int main(){
    char cwd[BUFSIZ];
    getcwd(cwd, BUFSIZ);
    printf("The current working directory is %s\n", cwd);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/test$ ./final
The current working directory is /home/chan/C_Programming/test
```



#### `chdir()`

The second useful directory function is `chdir()` . 

- This function works like the `cd` command in Linux.
- Like `getcwd()`, the `chdir()` function is prototyped in the `unistd.h` header file.

```C
int chdir(const char *path);
```

- The sole argument is a string representing the directory (path) to change to.
- The return value is 0 upon success, with -1 indicating an error.

#### **What Is `struct dirent`?**

`struct dirent` is a structure defined in the `<dirent.h>` header file. It represents a directory entry, providing information about files and directories within a directory.

```C
struct dirent {
    ino_t          d_ino;       // Inode number
    off_t          d_off;       // Offset to the next dirent
    unsigned short d_reclen;    // Length of this record
    unsigned char  d_type;      // Type of file
    char           d_name[256]; // Null-terminated filename
};
```

### **Member Breakdown:**

1. **`d_ino` (`ino_t`):**
   - **Purpose:** Represents the inode number of the file.
   - **Inode Number:** A unique identifier for a file within a filesystem. It points to metadata about the file, such as permissions, ownership, and data block locations.
2. **`d_off` (`off_t`):**
   - **Purpose:** Indicates the offset to the next `dirent` structure in the directory stream.
   - **Usage:** Primarily used internally by the system; not commonly manipulated directly by user programs.
3. **`d_reclen` (`unsigned short`):**
   - **Purpose:** Specifies the length of this directory record.
   - **Usage:** Useful for systems that support variable-length records, ensuring correct traversal of directory entries.
4. **`d_type` (`unsigned char`):**
   - **Purpose:** Denotes the type of the file.
   - Common Values:
     - `DT_REG`: Regular file
     - `DT_DIR`: Directory
     - `DT_LNK`: Symbolic link
     - `DT_FIFO`: FIFO/pipe
     - `DT_SOCK`: Socket
     - `DT_CHR`: Character device
     - `DT_BLK`: Block device
     - `DT_UNKNOWN`: Unknown file type
5. **`d_name` (`char[256]`):**
   - **Purpose:** Stores the null-terminated name of the entry (file or directory).
   - **Note:** The maximum length (`256` in this example) can vary based on the system's `NAME_MAX` value.

##### **Common Usage**

`struct dirent` is primarily used with directory handling functions to read entries within a directory. Here's how it's typically used:

##### **1. Opening a Directory**

Before reading directory entries, you need to open the directory using `opendir()`:

```C
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    DIR *dir;
    struct dirent *entry;

    dir = opendir("/path/to/directory");
    if (dir == NULL) {
        perror("opendir");
        exit(EXIT_FAILURE);
    }

    // ... (reading entries)

    closedir(dir);
    return 0;
}
```

##### **2. Reading Directory Entries**

Use `readdir()` in a loop to read each entry:

```C
while ((entry = readdir(dir)) != NULL) {
    printf("Name: %s\n", entry->d_name);
    printf("Type: ");
    
    switch (entry->d_type) {
        case DT_REG:
            printf("Regular File\n");
            break;
        case DT_DIR:
            printf("Directory\n");
            break;
        case DT_LNK:
            printf("Symbolic Link\n");
            break;
        // Add cases for other types as needed
        default:
            printf("Other\n");
    }
}
```



### Diving into a subdirectory

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

int main(int argc, char *argv[]){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    int r;
    char *dirname, *filename;
    
    if(argc < 2){
        fprintf(stderr, "Missing directory name\n");
        exit(1);
    }
    
    dirname = argv[1];
    
    r = chdir(dirname);
    
    if(r == -1){
        fprintf(stderr, "Unable to change to '%s'\n", dirname);
        exit(1);
    }
    
    dp = opendir(dirname);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirname);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        
        // Obtain inode details
        r = stat(filename, &fs);
        if(r == -1){
            fprintf(stderr, "Error on '%s'\n", filename);
            exit(1);
        }
        
        // Test to see whether the file is a directory (subdirectory)
        if(S_ISDIR(fs.st_mode)){
            
            // Outputs the directory's name
            printf("Found directory: %s\n", filename);
        }
    }
    
    closedir(dp);
    
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final /home
Found directory: chan
Found directory: vincent
Found directory: ..
Found directory: .
chan@CMA:~/C_Programming/test$ ./final /home/chan
Found directory: .pki
Found directory: .gnupg
Found directory: Downloads
Found directory: Music
Found directory: .wallaby
Found directory: directory...
Found directory: .thunderbird
Found directory: .cache
Found directory: Photos
Found directory: .dotnet
Found directory: ..
Found directory: Pictures
Found directory: .ssh
Found directory: exercise_2
Found directory: .quokka
Found directory: .gphoto
Found directory: Desktop
Found directory: .mozilla
Found directory: C_Programming
Found directory: .fontconfig
Found directory: .
Found directory: Videos
Found directory: .vscode
Found directory: .local
Found directory: Documents
Found directory: Templates
Found directory: .gnome
Found directory: test
Found directory: .config
Found directory: github.com
Found directory: Public
Found directory: snap

```

**Exercise 10.2**

Every directory has the dot and dot-dot entries. Plus, many directories host hidden subdirectories. All hidden files in Linux start with a single dot. Your task for this exercise is to modify the source code to have the program not output any file that starts with a single dot. 



**Solution**

```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <dirent.h>

int main(int argc, char *argv[]){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    int r;
    char *dirname, *filename;
    
    if(argc < 2){
        fprintf(stderr, "Missing directory name\n");
        exit(1);
    }
    
    dirname = argv[1];
    r = chdir(dirname);
    
    if(r == -1){
        fprintf(stderr, "Unable to change to %s\n", dirname);
        exit(1);
    }
    
    dp = opendir(dirname);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirname);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        
        // Skip hiiden files (those starting with a dot)
        if(filename[0] == '.'){
            continue;
        }
        
        r = stat(filename, &fs);
        if(r == -1){
            fprintf(stderr,"Error on '%s'\n", filename);
            exit(1);
        }
        
        if(S_ISDIR(fs.st_mode)){
            printf("Found directory: %s\n", filename);
        }
    }
    
    closedir(dp);
    return 0;
}
```

**The Author's Solution**

```C
filename = entry->d_name;
/* after obtaining the entry/filename, compare
		   the first character with the dot */
		if( strncmp( filename,".",1)==0 )
			/* continue the while loop */
			continue;
```

- `strncmp` Function:

   

  Compares up to `n` characters of two strings.

  - **Syntax:** `strncmp(const char *s1, const char *s2, size_t n)`

- Parameters:

  - **`filename`**: The first string (file name).
  - **`"."`**: The second string (a single dot).
  - **`1`**: Number of characters to compare.

- **Comparison:** It **compares the first character** of `filename` with `'.'`.

- **Outcome:** If the first character is a dot, the `continue` statement **skips** the current iteration, thus **excluding hidden files**.

### **Step-by-Step Explanation:**

1. **Loop Begins:**
   - **`while ((entry = readdir(dp)) != NULL)`**
     Iterates over each directory entry in the opened directory `dp`.
2. **Retrieve Filename:**
   - **`filename = entry->d_name;`**
     Extracts the name of the current directory entry.
3. **Check for Hidden Files:**
   - **Condition:**
     **`if (filename[0] == '.')`**
     Checks if the first character of the filename is a dot (`.`), which signifies a hidden file in Unix-like systems.
   - **Action if True:**
     **`continue;`**
     - Effect:
       - **Skips Remaining Code in Loop Body:** The program **does not** execute any further statements within the loop for this iteration.
       - **Proceeds to Next Iteration:** The loop **moves directly** to fetch the next directory entry.
4. **Process Non-Hidden Files:**
   - If the filename does not start with a dot, the program proceeds to:
     - **Retrieve File Metadata:**
       **`r = stat(filename, &fs);`**
     - Error Handling:
       - If `stat` fails, print an error and exit.
     - Check if Entry Is a Directory:
       - If it is, print the directory name.

### **Why Use `continue` Here?**

- **Selective Processing:**
  By using `continue`, the program **excludes all hidden files** from being processed further. This ensures that only visible (non-hidden) files and directories are considered for actions like printing.
- **Efficiency:**
  - **Avoid Unnecessary Operations:**
    Skipping hidden files **prevents** the program from performing operations (like `stat` and printing) on files that the user might not be interested in viewing.
  - **Streamlined Output:**
    Results in a **cleaner and more relevant output**, focusing only on the files and directories that are visible to the user.



```shell
chan@CMA:~/C_Programming/test$ ./final
Missing directory name
chan@CMA:~/C_Programming/test$ ./final /home/chan
Found directory: Downloads
Found directory: Music
Found directory: directory...
Found directory: Photos
Found directory: Pictures
Found directory: exercise_2
Found directory: Desktop
Found directory: C_Programming
Found directory: Videos
Found directory: Documents
Found directory: Templates
Found directory: test
Found directory: github.com
Found directory: Public
Found directory: snap
```



### Mining deeper with recursion

`hello.h`

- The first is the full pathname to the directory to scan.
- The second is the full pathname to the parent directory.
- Both are const char types because neither string is modified within the function.

```C
void dir(const char *dirpath, const char *parentpath);
```

`hello.c`

```C
void dir(const char *dirpath, const char *parentpath){
    
    DIR *dp; // Directory pointer
    struct dirent *entry; // Directory entry structure
    struct stat fs; // Structure to hold file information
    
    // Storage for the new directory to change to, storing the full pathname
    char subdirpath[BUFSIZ];
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    // Outputs the current directory path
    printf("%s\n", dirpath);
    
    while((entry = readdir(dp)) != NULL){
        if(stncmp(entry->d_name, ".", 1) == 0){
            continue;
        }
        
        // Get info for each directory entry (inode)
        stat(entry->d_name, &fs);
        
        // Checks for a subdirectory entry
        if(S_ISDIR(fs.st_mode)){
            // Changes to the subdirectory
            if(chdir(entry->d_name) == -1){
                fprintf(stderr, "Unable o change to %s\n", entry->d_name);
                exit(1);
            }
            
            // Gets the subdirectory's full pathname for the recursive call
            getcwd(subdirpath, BUFSIZ);
            
            // Recursively calls the function with the subdirectory and current directory as arguments
            dir(subdirpath, dirpath);
        }
    }
    
    closedir(dp);
    
    // Changes back to the parent directory - full pathname
    if(chdir(parentpath) == -1){
        
        // Checks for NULL, in which case, just returns
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

- `void dir(const char *dirpath, const char *parentpath)`

  - **Purpose:** Recursively traverses directories starting from `dirpath`, ignoring hidden files, and prints directory paths.
  - Parameters:
    - `dirpath`: Path of the current directory to process.
    - `parentpath`: Path of the parent directory to return to after processing subdirectories.

- ```C
  stat(entry->d_name, &fs);
          
   
  if(S_ISDIR(fs.st_mode)){
              
      if(chdir(entry->d_name) == -1){
           fprintf(stderr, "Unable o change to %s\n", entry->d_name);
           exit(1);
      }
              
              
  getcwd(subdirpath, BUFSIZ);
              
  dir(subdirpath, dirpath);
  ```

  - Uses `stat` to retrieve information about the entry.
  - Checks if the entry is a **directory** using `S_ISDIR`.
  - If it's a directory:
    - Attempts to **change to the subdirectory** using `chdir`.
    - If unable to change, it prints an error and exits.
    - Retrieves the **absolute path** of the subdirectory.
    - **Recursively calls** `dir` on the subdirectory to process its contents.

`main.c`

```C
int main(int argc, char *argv[]){
    
    // Buffer to store the current directory path
    char current[BUFSIZ];
    
    if(argc < 2){
        // For no arguments obtains and stores the full path to the current directory
        getcwd(current, BUFSIZ);
    }else{
        
        // copies the first argument
        strcpy(current, argv[1]);
        
        // Change to the directory and check for errors
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access directory %s\n", current);
            exit(1);
        }
        
        // Get the directory full pathname
        getcwd(current, BUFSIZ);
    }
    
    // Calls the function; NULL is checked in dir()
    dir(current, NULL);
    
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final
/home/chan/C_Programming/test
/home/chan/C_Programming/test/libs
/home/chan/C_Programming/test/obj
```

##### Explanation of `dir()` function

##### **Detailed Step-by-Step Visualization on the output**

1. **Determine Current Directory**

- **Action:**
  - Since no command-line argument is provided, the program retrieves the **current working directory**.
- **Code Snippet (`main.c`):**

```C
if (argc < 2)
{
    getcwd(current, BUFSIZ); // Get current directory
}
```

- Result:
  - `current` is set to `test`.

2. **Traverse Directories Recursively**

   - Action:
     - The program calls the `dir` function to start traversing directories from the `current` path.
   - Code Snippet (`main.c`):

   ```C
   dir(current, NULL);
   ```

   - Function call (`hello.c`):
     - `void dir(const char *dirpath, const char *parentpath)`

3. **First Call:** `dir("/home/chan/C_Programming/test", NULL)`

   - Opening Directory:
     - Opens `test`
   - **Reading Entries**:
     - Iterates over each entry in the directory.
   - **Skipping Hidden Files:**
     - Skips any file or directory starting with a dot(`.`)
   - **Identifying Subdirectories:**
     - Finds:
       - `libs` (Directory)
       - `obj` (Directory)
   - **Recursion**:
     - For each subdirectory (`libs` and `obj` ), the program:
       - **Changes Directory**:
         - `chdir("libs")` and `chdir("obj")`
       - **Gets Absolute Path**:
         - libs
         - obj
       - **Recursive Call**:
         - `dir("/home/chan/C_Programming/test/libs", "/home/chan/C_Programming/test")`
         - `dir("/home/chan/C_Programming/test/obj", "/home/chan/C_Programming/test")`

4. **Recursive Calls**:

   - For `libs` :
     - **Opening Directory**:
       - Opens `libs`
     - **Reading Entries**:
       - No subdirectories found or subdirectores are hidden.
     - **Output**:
       - libs
   - For `obj`:
     - **Opening Directory**:
       - Opens `obj`
     - **Reading Entries**:
       - No subdirectories found or subdirectories are hidden.
     - **Output**:
       - obj

5. **Output Directory Paths**:

```sh
/home/chan/C_Programming/test
/home/chan/C_Programming/test/libs
/home/chan/C_Programming/test/obj
```



### Pulling out the directory name

`hello.h`

```C
const char *extract(const char *path);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    // If the string is empty, return NULL
    if(len == 0){
        return NULL;
    }
    
    // Perform a special test for the root directory
    if(len == 1 & path[0] == '/'){
        return path;
    }
    
    // Positions pointer p at the end of string path
    p = path+len;
    
    // Backs up p to find the separator; for Windows, uses \\ as the separator
    while(*p != '/'){
        p--;
        
        // If p backs up too far, returns NULL
        if(p == path){
            return NULL;
        }
    }
    
    // Increments p over the separator character
    p++;
    
    // Test to see if the string is empty or malformed and returns NULL
    if(*p == '\0'){
        return NULL;
    }else{
        // Returns the address where the final directory name starts
        return p;
    }
}
```

`main.c`

```C
#define COUNT 4

int main(){
    const char *pathname[COUNT] = {
        "/home/chan", "/usr/local", "/", "nothing here"
    };
    int x;
    for(x = 0; x < COUNT; x++){
        printf("%s -> %s\n", pathname[x], extract(pathname[x]));
    }
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/test$ ./final
/home/chan -> chan
/usr/local -> local
/ -> /
nothing here -> (null)

```

- The `extract()` function successfully processes each string, returning the last part, the directory name. 
- It even catches the malformed string, properly returning NULL.



### Adding `extract()` function to the `dir()` program

`hello.h`

```C
const char *extract(const char *path);

void dir(const char *dirpath, const char *parentpath);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    if(len == 0){
        return NULL;
    }
    if(len == 1 && path[0] == '/'){
        return path;
    }
    
    p = path + len;
    while(*p != '/'){
        p--;
        
        if(p == path){
            return NULL;
        }
    }
    
    p++;
    
    if(*p == '\0'){
        return NULL;
    }else{
        return p;
    }
}



void dir(const char *dirpath, const char *parentpath){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[BUFSIZ];
    
    dp = opendir(dp);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    printf("%s\n", extract(dirpath));
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        if(strncmp(filename, ".", 1) == 0){
            continue;
        }
        
        stat(filename, &fs);
        
        if(S_ISDIR(fs_st_mode)){
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change directory to '%s'\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            dir(subdirpath, dirpath);
        }
    }
    
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        fprintf(stderr, "Parent direcotry lost\n");
        exit(1);
    }
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    char current[BUFSIZ];
    
    if(argc < 2){
        getcwd(current, BUFSIZ);
    }else{
        strcpy(current, argv[1]);
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access %s\n", current);
            exit(1);
        }
        getcwd(current, BUFSIZ);
    }
    dir(current, NULL);
    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
test
libs
obj
```



### Monitoring directory depth

- To monitor the directory depth (make the directory output a bit more "tree-like"), the `dir()` function is updated:

```C
void dir(const char *dirpath, const char *parentpath, int depth);
```

- Three arguments is the maximum for a function.
- Any more arguments and it becomes obvious that what should really be passed to the function is a structure.
- To complete the modification, three more changes are required. 
- First, in the `main()` function, the `dir()` function is originally called with zero as its third argument:

```C
dir(current, NULL, 0);
```

- The zero sets the indent depth as the program starts: the first directory is the top level.
- The second, the recursive call within the `dir()` function must be modified, adding the third argument `depth`:

```C
dir(subdirpath, dirpath, depth+1);
```

- For the recursive call, which means the program is diving down one directory level, the indent level `depth` is increased by one.
- Finally, something must be done with the `depth` variable within the `dir()` function. Adding a loop that outputs a chunk of three spaces for every depth level.

```C
for(i = 0; i < depth; i++){
    printf("   ");
}
```

- This loop appears before the `printf()` statement that outputs the directory's name, just before the `while` loop.
- The result is that each subdirectory is indented three spaces as the directory tree is output.



`hello.h`

```C
const char *extract(const char *path);

void dir(const char *dirpath, const char *parentpath, int depth);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    // If the string is empty, return NULL
    if(len == 0){
        return NULL;
    }
    
    // Perform a special test for the root directory
    if(len == 1 && path[0] == '/'){
        return path;
    }
    
    // Positions pointer p at the end of string path
    p = path + len;
    
    // Backs up p to find the separator;
    while(*p != '/'){
        p--;
        
        // If p backs up too far, returns NULL
        if(p == path){
            return NULL;
        }
    }
    
    // Increments p over the separator character
    p++;
    
    
    // Test to see if the string is empty or malformed and returns NULL
    if(*p == '\0'){
        return NULL;
    }else{
        // Returns the address where the final directory name starts
        return p;
    }
}


void dir(const char *dirpath, const char *parentpath, int depth){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[BUFSIZ];
    int i;
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    for(i = 0; i < depth; i++){
        printf("   "); // 3 spaces for each depth level
    }
    
    printf("%s\n", extract(dirpath));
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        if(strncmp(filename, ".", 1) == 0){
            continue;
        }
        
        stat(filename, &fs);
        if(S_ISDIR(fs.st_mode)){
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change directory to '%s'\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            dir(subdirpath, dirpath, depth + 1);
        }
    }
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

- **Functionality:**
  - **`chdir(parentpath)`:**
    Attempts to **change the current working directory back** to the **parent directory** after finishing the traversal of a subdirectory.
- **Reasoning:**
  - **Recursive Traversal Needs:**
    After entering a subdirectory and completing its processing, the program needs to **return to the parent directory** to continue processing other entries.
  - **Maintaining Directory State:**
    Ensures that each recursive call to `dir` operates within the correct directory context.

### **2. **Handling Edge Cases and Errors**

- **`if (chdir(parentpath) == -1)`:**
  Checks if changing back to the parent directory **fails**.
- **Sub-Conditions:**
  - **`if (parentpath == NULL)`:**
    - Scenario:
      - This condition is **true** when the `dir` function was initially called from `main` with `parentpath` set to `NULL`.
      - Implication:
        - Since there's **no parent directory** to return to (the initial call), the function simply **returns**, effectively ending the traversal.
  - **`else` Block:**
    - Scenario:
      - Occurs when `parentpath` is **not `NULL`**, meaning the function was called recursively for a subdirectory.
    - Implication:
      - Error Handling:
        - Indicates a critical failure in changing back to the parent directory, which disrupts the traversal process.
      - Actions Taken:
        - **`fprintf`:**
          Prints an error message indicating that the program **cannot return to the parent directory**.
        - **`exit(1)`:**
          **Terminates the program** with a failure status, preventing further undefined behavior.

`main.c`

```C
int main(int argc, char *argv[]){
    char current[BUFSIZ];
    
    if(argc < 2){
        getcwd(current, BUFSIZ);
    }else{
        strcpy(current, argv[1]);
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access directory %s\n", current);
            exit(1);
        }
        getcwd(current, BUFSIZ);
    }
    
    dir(current, NULL, 0);
    return 0;
}
```

**Visualization of Execution Flow**

```
main.c
  |
  |-- Calls dir("/home/chan/C_Programming/test", NULL, 0)
        |
        |-- Opens "/home/chan/C_Programming/test"
        |-- Prints extracted path
        |-- Iterates through entries:
              |-- Entry: "libs" (Directory)
                    |-- chdir("libs")
                    |-- Calls dir("/home/chan/C_Programming/test/libs", "/home/chan/C_Programming/test", 1)
                          |
                          |-- Opens "/home/chan/C_Programming/test/libs"
                          |-- Prints extracted path
                          |-- Iterates through entries:
                                |-- (Assume no subdirectories)
                          |-- closedir(dp)
                          |-- chdir("/home/chan/C_Programming/test")
          |-- Entry: "obj" (Directory)
                    |-- chdir("obj")
                    |-- Calls dir("/home/chan/C_Programming/test/obj", "/home/chan/C_Programming/test", 1)
                          |
                          |-- Opens "/home/chan/C_Programming/test/obj"
                          |-- Prints extracted path
                          |-- Iterates through entries:
                                |-- (Assume no subdirectories)
                          |-- closedir(dp)
                          |-- chdir("/home/chan/C_Programming/test")
        |-- closedir(dp)
        |-- chdir(NULL) --> Fails
              |-- Since parentpath == NULL
                    |-- return;
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final /home/chan/github.com
github.com
   MyLearningNotes
      Data Structures & Algorithms
      Databases
         Supabase
         MongoDB
      Next.js
      C_Learning
      CS
      Linux
chan@CMA:~/C_Programming/test$ ./final 
test
   libs
   obj

```

- The output shows the directory and Subdirectory in a tree-like structure.
- Each subdirectory is indented three spaces. The sub-directories of the `MyLearningNotes` are further indented.
- In the second output, there is a test directory, inside the test directory, two subdirectories `libs` and `obj` are displayed with three spaces from the left forming a tree like structure.



**Exercise 10.3**

Modify the source code above so that instead of indenting with blanks, the subdirectories appear with text mode graphics.

`hello.h`

```C
const char *extract(const char *path);

void dir(const char *dirpath, const char *parentpath, int depth);
```

`hello.c`

```C
const char *extract(const char *path){
    const char *p;
    int len;
    
    len = strlen(path);
    
    // If the string is empty, return NULL
    if(len == 0){
        return NULL;
    }
    
    // Perform a special test for the root directory
    if(len == 1 && path[0] == '/'){
        return path;
    }
    
    // Positions pointer p at the end of string path
    p = path + len;
    
    // Backs up p to find the separator;
    while(*p != '/'){
        p--;
        
        // If p backs up too far, returns NULL
        if(p == path){
            return NULL;
        }
    }
    
    // Increments p over the separator character
    p++;
    
    
    // Test to see if the string is empty or malformed and returns NULL
    if(*p == '\0'){
        return NULL;
    }else{
        // Returns the address where the final directory name starts
        return p;
    }
}


void dir(const char *dirpath, const char *parentpath, int depth){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[BUFSIZ];
    int i;
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    for(i = 0; i < depth; i++){
        printf("   "); // 3 spaces for each depth level
    }
    
    printf("%s\n", extract(dirpath));
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        if(strncmp(filename, ".", 1) == 0){
            continue;
        }
        
        stat(filename, &fs);
        if(S_ISDIR(fs.st_mode)){
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change directory to '%s'\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            dir(subdirpath, dirpath, depth + 1);
        }
    }
    closedir(dp);
    
    // If no further subdirectories are found, change the directory back to the parentpath to furthur process the directories inside the parent.
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

`main.c`

```C
int main(int argc, char *argv[]){
    char current[BUFSIZ];
    
    if(argc < 2){
        getcwd(current, BUFSIZ);
    }else{
        strcpy(current, argv[1]);
        if(chdir(current) == -1){
            fprintf(stderr, "Unable to access directory %s\n", current);
            exit(1);
        }
        getcwd(current, BUFSIZ);
    }
    
    dir(current, NULL, 0);
    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
test
+--libs
+--obj
chan@CMA:~/C_Programming/test$ ./final /home/chan/github.com
github.com
+--MyLearningNotes
|  +--Data Structures & Algorithms
|  +--Databases
|  |  +--Supabase
|  |  +--MongoDB
|  +--Next.js
|  +--C_Learning
|  +--CS
|  +--Linux

```

**Visual Representation of the output**:

- **Root Directory (`test`):**

  - **`depth = 0`**: No indentation or connectors.
  - **Output:** `test`

- **First Level (`libs`, `obj`):**

  - `depth = 1`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `+--libs`, `+--obj`

  

- **Root Directory (`github.com`):**

  - **`depth = 0`**: No indentation or connectors.
  - **Output:** `github.com`

- **First Level (`MyLearningNotes`):**

  - `depth = 1`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `+--MyLearningNotes`

- **Second Level (`Data Structures & Algorithms`, `Databases`, `Next.js`, `C_Learning`, `CS`, `Linux`):**

  - `depth = 2`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: False
      - **Output:** `|`
    - Iteration (`i = 1`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `| +--Data Structures & Algorithms`, `| +--Databases`, `| +--Next.js`, `| +--C_Learning`, `| +--CS`, `| +--Linux`

- **Third Level (`Supabase`, `MongoDB` under `Databases`):**

  - `depth = 3`:
    - Iteration (`i = 0`):
      - **`i == depth - 1`**: False
      - **Output:** `|`
    - Iteration (`i = 1`):
      - **`i == depth - 1`**: False
      - **Output:** `|`
    - Iteration (`i = 2`):
      - **`i == depth - 1`**: True
      - **Output:** `+--`
  - **Output:** `| | +--Supabase`, `| | +--MongoDB`

---



## Chapter 11 - File Finder

- Suppose we want to locate a file named `budget.csv`, located somewhere in our home directory tree.

```bash
find ~ -name budget.csv -print
```

- The pathname is `~`, shortcut for our home directory.
- The `-name` switch identifies the file to locate, `budget.csv`.
- The final switch, `-print` (the one everyone forgets), directs the `find` command to send the results to standard output.
- The other file-finding command is `grep`.

```shell
grep -r "time_t" *
```

- The `-r` switch directs `grep` to recursively look through directories.
- The string to find is `time_t` and the `*` wildcard directs the program to search all filenames.



### Coding the Find File utility

`hello.h`

```C
#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>
#include <limits.h>

#ifndef PATH_MAX
#define PATH_MAX 256
#endif

extern int count;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
};

void findFile(char *dirpath, char *parentpath, char *match);

#endif // HELLO_H
```

`hello.c`

```C
int count = 0;

void findFile(char *dirpath, char *parentpath, char *match){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[PATH_MAX];
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        
        // Performs a comparison for the filename found with the passed filename
        if(strcmp(filename, match) == 0){
            printf("%s/%s\n", dirpath, match);
            count++;
        }
        
        stat(filename, &fs);
        if(S_ISDIR(fs.st_mode)){
            
            // Avoid checking the hidden files
            if(strncmp(filename, ".", 1) == 0){
                continue;
            }
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change to %s\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            
            // The recursive call, again with the passed filename to match as the third argument
            findFile(subdirpath, dirpath, match);
        }
    }
    
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return;
        }
        
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

`main.c`

- The `main()` function's job is to fetch the filename from the command line, retrieve the current path, make the call to the `find()` function, and then report the results.

```C
int main(int argc, char *argv[]){
    char current[PATH_MAX];
    if(argc < 2){
        fprintf(stderr, "Format: ff filename\n");
        exit(1);
    }
    
    getcwd(current, PATH_MAX);
    if(chdir(current) == -1){
        fprintf(stderr, "Unable to access directory %s\n", current);
        exit(1);
    }
    
    count = 0;
    printf("Searching for '%s'\n", argv[1]);
    findFile(current, NULL, argv[1]);
    
    // Report the results
    printf(" Found %d match", count);
    
    // Adds "es" for any count value other than 1
    if(count != 1){
        print("es");
    }
    
    putchar('\n');
    return 0;
}
```



```shell
chan@CMA:~/C_Programming/test$ ./final *.c
Searching for 'hello.c'
/home/chan/C_Programming/test/hello.c
 Found 1 match
chan@CMA:~/C_Programming/test$ ./final libs
Searching for 'libs'
/home/chan/C_Programming/test/libs
 Found 1 match
```

- The utility attempts to locate all files with the `.c` extension in the current directory.
- Rather than return them all, we see only the first match reported: `hello.c`.
- The problem here is that the code doesn't recognize wildcards; it finds only specific filenames.
- To match files with wildcards, we must understand something known as the glob.



### Understanding the glob

- `glob` is short for `global` in the computer world.
- Specifically, `glob` is a way to use wildcards to specify or match filenames.
- The term is `glob`, the process is `globbing`.
- The C library function worthy of attention is `glob()`.

As a review, the filename wildcards are:

- `?` to match a single character
- `*` to match a group of more than one character



- In Windows, globbing takes place automatically. But in the Linux environment, the glob feature must be activated for wildcards to expand.
- If not, the `*` and `?` wildcards are interpreted literally, which isn't what most users expect.
- To ensure that globbing is active, type the `set -o` command. In the output, the `noglob` option should be set to `off`:

```shell
noglob         	off
```

- When globbing is active, the shell expands the `?` and `*` wildcards to match files.



```C
int main(int argc, char *argv[]){
    int x;
    
    if(argc > 1){
        for(x = 1; x < argc; x++){
            printf("%s\n", argv[x]);
        }
    }
    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final this that the other
this
that
the
other
chan@CMA:~/C_Programming/test$ ./final *.c
hello.c
main.c
```

- We can see the the program dutifully echoes all command-line options in the first run.
- In the second run, with a wildcard specified, the program outputs all the files in that directory which ends with `.c` extension.
- The `*.c`  wildcard(globby thing) is expanded by the shell, which feeds each matching filename from the current directory to the program as a command-line argument.
- Instead of a single argument, `*.c`, multiple arguments are supplied.



```C
int glob(const char *pattern, int flags, int (*errfunc) (const char *epath, int eerrno), glob_t *pglob);
```

- `const char *pattern` is a pathname wildcard pattern to match.
- `int flags` are options to customize the function's behavior, usually a series of defined constants logically OR'd together.
- `int (*errfunc)` is the name of an error-handling function (along with its two arguments), which is necessary because the `glob()` function can be quirky. Specify NULL to use the default error handler.
- `glob_t *pglob` is a structure containing details about the matching files. 
  - Two useful members are `gl_pathc`, which lists the number of matching files.
  - `gl_pathv`, which serves as the base of a pointer list referencing matching filenames in the current directory.
- The `glob()` function returns zero on success. Other return values include defined constants we can test to determine whether the function screwed up or failed to find any matching files.
- We must include `glob.h` header file.

```C
typedef struct {
    size_t gl_pathc;    // Count of paths matched by the pattern
    char **gl_pathv;    // List of matched pathnames
    size_t gl_offs;     // Slots to reserve at the beginning of gl_pathv
    // Other members...
} glob_t;
```



`hello.h`

```C
#include <limits.h>

#ifndef PATH_MAX
#define PATH_MAX 256
#endif
```



```C
#include <stdio.h>
#include <stdlib.h>
#include <glob.h>
#include <limits.h>

int main(){
    char filename[PATH_MAX]; // Pointer to the result of fgets
    char *r; // Pointer to the result of fgets
    int g; // the return value of glob()
    glob_t gstruct; // The structure specified in the glob() func
    char **found; // A double-pointer to the list of matching filenames
    
    printf("Filename or wildcard: ");
    r = fgets(filename, PATH_MAX, stdin);
    if(r == NULL){
        exit(1);
    }
    
    // Remove the newline character from the input
    while(*r != '\0'){
        if(*r == '\n'){
            *r = '\0';
            break;
        }
        r++;
    }
    
     // Use glob to find matching filenames
    // The call to the glob() function, mostly defaults except for the GLOB_ERR flag
    g = glob(filename, GLOB_ERR, NULL, &gstruct);
    
    // Checks for errors, specifically no matching filename
    if(g != 0){
        if(g == GLOB_NOMATCH){
            fprintf(stderr, "No matches for '%s'\n", filename);
        }else{
            fprintf(stderr, "Some kinda glob error\n");
        }
        exit(1);
    }
    
    // Outputs the matches using structure member gl_pathc; the placeholder %zu is used for a size_t value
    printf("Found %zu filename matches\n", gstruct.gl_pathc); // Print the number of matches found
    
    // The gl_pathv member is the base of a pointer list, assigned to double pointer found
    found = gstruct.gl_pathv; // Get the list of matched filenames
    
    // Loops as long as the string referenced by *found isn't NULL
    // Iterate over the matched filenames and print each one
    while(*found){
        
        // Outputs the matching filename
        printf("%s\n", *found);
        
        // Increments the found pointer to reference the next item in the list
        found++;
    }
    
    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
Filename or wildcard: hello*
Found 2 filename matches
hello.c
hello.h
```



### Using wildcards to find files

`hello.h`

```C
#include <stdio.h>
#include <limits.h>

#ifndef PATH_MAX
#define PATH_MAX 256
#endif

extern int count;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
};

void findFile(char *dirpath, char *parentpath, char *match);
```

`hello.c`

```C
int count = 0; // Global variable to count the number of matches

void findFile(char *dirpath, char *parentpath, char *match)
{
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[PATH_MAX];
    int g;
    glob_t gstruct;
    char **found;

    dp = opendir(dirpath);
    if (dp == NULL)
    {
        fprintf(stderr, "Cannot open directory %s\n", dirpath);
        exit(1);
    }

    // Uses glob() to find matching files in the directory
    g = glob(match, GLOB_ERR, NULL, &gstruct);
    
    // Upon success, outputs the found files
    if (g == 0)
    {
        found = gstruct.gl_pathv;
        while (*found)
        {
            printf("%s/%s\n", dirpath, *found);
            found++;
            count++;
        }
    }

    // This loop is still necessary to find and explore subdirectories
    while ((entry = readdir(dp)) != NULL)
    {
        filename = entry->d_name;
        stat(filename, &fs);
        if (S_ISDIR(fs.st_mode))
        {
            // Skip hidden files
            if (strncmp(filename, ".", 1) == 0)
            {
                continue;
            }

            if (chdir(filename) == -1)
            {
                fprintf(stderr, "Cannot change directory to %s\n", filename);
                exit(1);
            }

            // Get the current working directory
            getcwd(subdirpath, PATH_MAX);
            
            // Recursively search in subdirectories
            findFile(subdirpath, dirpath, match);
        }
    }

    closedir(dp);

    // Go back to the parent directory to futher process another directories inside the parent's directory.
    if (chdir(parentpath) == -1)
    {
        if (parentpath == NULL)
        {
            return;
        }
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
}
```

`main.c`

```C
int main(int argc, char *argv[])
{ 
    char current[PATH_MAX]; // Buffer to store the current directory path
    char filename[PATH_MAX]; // Buffer to store the filename or wildcard input
    char *r;

    printf("Filename or wildcard: ");

    r = fgets(filename, PATH_MAX, stdin);

    if (r == NULL)
    {
        exit(1);
    }

    // Loop thru each character in the input & Remove the newline character from the input
    while (*r != '\0')
    {
        if (*r == '\n')
        {
            *r = '\0';
            break;
        }
        r++;
    }

    // Get the current working directory
    getcwd(current, PATH_MAX);
    if (chdir(current) == -1)
    {
        fprintf(stderr, "Unable to access directory %s\n", current);
        exit(1);
    }

    count = 0;
    printf("Searching for '%s'\n", filename);
    
     // Call the function to find files
    findFile(current, NULL, filename);
    printf("Found %d match\n", count);
    if (count != 1)
    {
        printf("es");
    }

    putchar('\n');
    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
Filename or wildcard: *.c
Searching for '*.c'
/home/chan/C_Programming/test/hello.c
/home/chan/C_Programming/test/main.c
Found 2 match
es
chan@CMA:~/C_Programming/test$ ./final
Filename or wildcard: *.txt
Searching for '*.txt'
/home/chan/C_Programming/test/sonnet18.txt
Found 1 match

chan@CMA:~/C_Programming/test$ ./final
Filename or wildcard: *.wtxt
Searching for '*.wtxt'
/home/chan/C_Programming/test/alphabeta.wtxt
/home/chan/C_Programming/test/cyrillic.wtxt
Found 2 match
es
```

- Having the `glob()` function in the program allows wildcards to be used effectively.



### The duplicate file finder

- The process of creating a `Find Dupe` utility borrows heavily from the subdirectory scanning tools presented in chapter 10 and used earlier in this chapter.
- But the rest of the code - recording and scanning the list of saved files - is a new territory: a list of files must be created.
- The list must be scanned for duplicates and then the duplicates output, along with their pathnames.



### Building a file list

- The option to build a list of files found in subdirectories is to create a linked list.
- A linked list structure must have as a member a pointer to the next item, or node, in the list.
- This member becomes part of the structure that stores found filenames and their paths.

```C
struct finfo{
    int index;
    char name[BUFSIZ];
    char path[PATH_MAX];
    struct finfo *next;
}
```

This structure contains four members:

- `index`, which keeps a count of the files found (avoiding an external variable)
- `name`, which contains the name of the found file
- `path`, which contains the full path to the file
- `next`, which references the next node in the linked list, or NULL for the end of the list

This structure must be declared externally so that all functions in the code understand its definition.

In the next listing, the `main()` function allocates the first node in the linked list. 

- The structure must be empty; it's the recursive function `findFile()` that builds the linked list.
- The `main()` function fetches the starting directory for a call to the recursive function.
- Upon completion, a `while` loop outputs the names of the files referenced by the linked list.

`main.c`

```C
int main(){
    char startdir[PATH_MAX];
    
    // A pointer is needed for the base (first) and for examining the items in the list (current)
    struct finfo *first, *current;
    
    first = malloc(sizeof(struct finfo) * 1);
    if(first == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Fills the first node with empty values
    first->index = 0;
    strcpy(first->name, "");
    strcpy(first->path, "");
    first->next = NULL;
    
    // Obtail the current directory for the findFile() call
    getcwd(startdir, PATH_MAX);
    
    if(chdir(startdir) == -1){
        fprintf(stderr, "Unable to access directory %s\n", startdir);
        exit(1);
    }
    
    // Calls the recursive function
    findFile(startdir, NULL, first);
    
    // Sets the current pointer to the start of the list
    current = start;
    
    // Loops as long as the current pointer isn't NULL
    while(current){
        // Skip over the first item in the list, zero
        if(current->index > 0){
            
            // Output the index value, pathname, and filename
            printf("%d:%s/%s\n", current->index, current->path, current->name);
        }
        
        // Reference the next item in the list
        current = current->next;
    }
    
    return 0;
}
```



- The third argument of the `findFile()` function is replaced by a pointer to the current node in the linked list.
- The function's job is to create new nodes, filling their structures as it finds files in the current directory.

`hello.h`

```C
struct finfo{
    int index;
    char name[BUFSIZ];
    char path[PATH_MAX];
    struct finfo *next;
};

struct finfo *findFile(char *dirpath, char *parentpath, struct finfo *f){
    
}
```

`hello.c`

```C
struct finfo *find(char *dirpath, char *parentpath, struct finfo *f){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[PATH_MAX];
    int i;
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        stat(filename, &fs);
        
        // Test for a subdirectory and recursion
        if(S_ISDIR(fs.st_mode)){
            // Skip the hidden files
            if(strncmp(filename, ".", 1) == 0){
                continue;
            }
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change to %s\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            
            // The recursive call must capture the function's return value
            f = findFile(subdirpath, dirpath, f);
        }else{ // If not a subdirectory, saves the file information
            // Allocates the next node in the linked list
            f->next = malloc(sizeof(struct finfo) * 1);
            if(f->next == NULL){
                fprintf(stderr, "Unable to allocate new structure\n");
                exit(1);
            }
            
            // Saves the current index value
            i = f->index;
            
            // Reference the freshly allocated node
            f = f->next;
            
            // update the index value
            f->index = i + 1;
            
            // Saves the filename
            strcpy(f->name, filename);
            
            // Saves the pathname
            strcpy(f->path, dirpath);
            
            // Initiate the next pointer;
            f->next = NULL;
        }
    }
    
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return f;
        }
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
    
    return f;
}
```

- The `findFile()` function makes a simple decision based on whether a directory entry is a subdirectory or a file.
- When a subdirectory is found, the function is recursively called.
- Otherwise, a new node in the linked list is allocated and the file entry information is recorded.

`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
1:/home/chan/C_Programming/test/alphabeta.wtxt
2:/home/chan/C_Programming/test/libs/libhello.a
3:/home/chan/C_Programming/test/final
4:/home/chan/C_Programming/test/main.c
5:/home/chan/C_Programming/test/Makefile
6:/home/chan/C_Programming/test/sonnet18.txt
7:/home/chan/C_Programming/test/cyrillic.wtxt
8:/home/chan/C_Programming/test/hello.c
9:/home/chan/C_Programming/test/obj/main.o
10:/home/chan/C_Programming/test/obj/hello.o
11:/home/chan/C_Programming/test/hello.h
12:/home/chan/C_Programming/test/bytes.dat
```



### Locating the duplicates

- The purpose of creating a linked list in the Find Dupe program is to find duplicates.
- At some point, the list must be scanned and a determination made as to which filenames are repeated and in which directories the duplicates are found.

```C
struct finfo{
    int index;
    int repeat; // New member to track repeated filenames
    char name[BUFSIZ];
    char path[PATH_MAX];
    struct finfo *next;
}
```

- The `repeat` member tracks how many times a name repeats.
- Its value is initialized to one in the `findFile()` function as each node is created.
- After all, every filename found exists at least once.
- To track repeated filenames, the `repeat` member is incremented as the list is scanned after its creation.
- In the `main()` function, a nested loop works like a bubble sort. 
- It compares each node in the list sequentially with the rest of the nodes.
- To perform the second scan, we need another `struct finfo` variable declared in the `main()` function.
- This variable, `*scan`,  is used in addition to `*first` and `*current` to scan the linked list:

```C
struct finfo *first, *current, *scan;
```

- The nested `while` loop is added just before the `while` loop that outputs the list. This nested loop uses the `*current` pointer to process the entire linked list.
- The `*scan` pointer is used in an inner `while` loop to compare the `current->name` member with subsequent `name` members.
- When a match is found, the `current->repeat` structure member for the file with the repeated name is incremented.

```C
current = first;

while(current){
    if(current->index > 0){
        // obtain the address of the next entry, where the scanning starts
        scan = current->next;
        
        // Loop until scan references the final (NULL) node in the list
        while(scan){
            
            // Compares the filenames
            if(strncmp(current->name, scan->name) == 0){
                // If the names are identical, increments the repeat counter for the current entry.
                current->repeat++;
            }
            
            // Continues the scan
            scan = scan->next;
        }
    }
    
    // Continue incrementing through the entire list, comparing each node with the rest of the list
    current = current->next;
}
```

- These nested loops update the `repeat` member of structures containing identical filenames.
- They are followed by the existing `while` loop that outputs the list.
- The `printf()` statement in that second loop is updated to output the `repeat` value:

```C
printf("%d:%s/%s (%d)\n", current->index, current->path, current->name, current->repeat);
```



`hello.h`

```C
#include <stdio.h>
#include <limits.h>

#ifndef PATH_MAX
#define PATH_MAX 256
#endif

extern int count;

enum
{
    ERROR_CODE = -1,
    BSIZE = 32,
    TRUE,
    FALSE,
};

struct finfo
{
    int index;
    int repeat;
    char name[BUFSIZ];
    char path[PATH_MAX];
    struct finfo *next;
};

struct finfo *findFile(char *dirpath, char *parentpath, struct finfo *f);
```

`hello.c`

```C
struct finfo *find(char *dirpath, char *parentpath, struct finfo *f){
    DIR *dp;
    struct dirent *entry;
    struct stat fs;
    const char *filename;
    char subdirpath[PATH_MAX];
    int i;
    
    dp = opendir(dirpath);
    if(dp == NULL){
        fprintf(stderr, "Unable to read directory '%s'\n", dirpath);
        exit(1);
    }
    
    while((entry = readdir(dp)) != NULL){
        filename = entry->d_name;
        stat(filename, &fs);
        
        // Test for a subdirectory and recursion
        if(S_ISDIR(fs.st_mode)){
            // Skip the hidden files
            if(strncmp(filename, ".", 1) == 0){
                continue;
            }
            if(chdir(filename) == -1){
                fprintf(stderr, "Unable to change to %s\n", filename);
                exit(1);
            }
            
            getcwd(subdirpath, BUFSIZ);
            
            // The recursive call must capture the function's return value
            f = findFile(subdirpath, dirpath, f);
        }else{ // If not a subdirectory, saves the file information
            // Allocates the next node in the linked list
            f->next = malloc(sizeof(struct finfo) * 1);
            if(f->next == NULL){
                fprintf(stderr, "Unable to allocate new structure\n");
                exit(1);
            }
            
            // Saves the current index value
            i = f->index;
            
            // Reference the freshly allocated node
            f = f->next;
            
            // update the index value
            f->index = i + 1;
            
            f->repeat = 1;
            
            // Saves the filename
            strcpy(f->name, filename);
            
            // Saves the pathname
            strcpy(f->path, dirpath);
            
            // Initiate the next pointer;
            f->next = NULL;
        }
    }
    
    closedir(dp);
    
    if(chdir(parentpath) == -1){
        if(parentpath == NULL){
            return f;
        }
        fprintf(stderr, "Parent directory lost\n");
        exit(1);
    }
    
    return f;
}
```

`main.c`

```C
int main()
{
    char startdir[PATH_MAX];
    struct finfo *first, *current, *scan;
    int found = 0;

    first = malloc(sizeof(struct finfo) * 1);

    if (first == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    first->index = 0;
    strcpy(first->name, "");
    strcpy(first->path, "");
    first->next = NULL;

    getcwd(startdir, PATH_MAX);

    if (chdir(startdir) == -1)
    {
        fprintf(stderr, "Unable to access directory %s\n", startdir);
        exit(1);
    }

    findFile(startdir, NULL, first);

    puts("Locating duplicate files in this directory tree: ");
    current = first;
	
    
    // Loopt thru the list until the value of current is NULL
    while (current)
    {
        // Skip the first, empty entry
        if (current->index > 0)
        {
            
            // Obtain the address of the `next` entry, where the scanning starts
            scan = current->next;
            
            // Loops until scan references the final (NULL) node in the list
            while (scan)
            {
                if (strcmp(current->name, scan->name) == 0)
                {
                    // If the names are identical, increments the `repeat` counter for the current entry
                    current->repeat++;
                    found = 1;
                }
                
                // Continue the scan
                scan = scan->next;
            }
        }
        
        // Continue incrementing through the entire list, comparing each node with the rest of the list
        current = current->next;
    }

   	// The value of found need not accumulate, it's effectively a Boolean variable. When it stays at 0, no duplicate filenames are found and vice versa.
    if (!found)
    {
        puts("No duplicates found");
        return 1;
    }

    // Churns thru the entire list of files just as before
    current = first;
    while (current)
    {
        if (current->index > 0)
        {
            // Look for items with a repeat count higher than 1
            if (current->repeat > 1)
            {
                
                // Output the number of duplicates for the given filename
                printf("%d duplicates found of %s:\n", current->repeat, current->name);
				
                // Output the current filename and its path
                printf(" %s/%s\n", current->path, current->name);
                
                // Starts the nested loop to t output the names and paths of matching filenames
                scan = current->next;
                while (scan)
                {
                    if (strcmp(scan->name, current->name) == 0)
                    {
                        printf(" %s/%s\n", scan->path, scan->name);
                        // prevent a repeated filename from appearing later in the output
                        scan->repeat = 0;
                    }
                    scan = scan->next;
                }
            }
        }
        current = current->next;
    }

    return 0;
}
```

`Output`

```shell
chan@CMA:~/C_Programming/test$ ./final
Locating duplicate files in this directory tree: 
2 duplicates found of main.c:
 /home/chan/C_Programming/test/test_folder/main.c
 /home/chan/C_Programming/test/main.c
2 duplicates found of sonnet18.txt:
 /home/chan/C_Programming/test/test_folder/sonnet18.txt
 /home/chan/C_Programming/test/sonnet18.txt
2 duplicates found of hello.c:
 /home/chan/C_Programming/test/test_folder/hello.c
 /home/chan/C_Programming/test/hello.c


```

---

## Holiday detector

- The reason the `main()` function is cast as an `int` is that it must return a value to the operating system.

```C
int main(int argc, char *argv[]){
    if(argc > 1){
        return strtol(argv[1], NULL, 10);
    }else{
        return 0;
    }
}
```

- The `strtol()` function converts the string held in `argv[1]`, the first argument at the command prompt, into an integer value, base 10.
- If the string can't be converted (it contains no digits), the value 0 is returned.

```shell
chan@CMA:~/C_Programming/practice$ ./practice 27
chan@CMA:~/C_Programming/practice$ echo $?
27
chan@CMA:~/C_Programming/practice$ ./practice 1
chan@CMA:~/C_Programming/practice$ echo $?
1
chan@CMA:~/C_Programming/practice$ ./practice "Hello"
chan@CMA:~/C_Programming/practice$ echo $?
0

```



### Using the preset return values

```C
EXIT_FAILURE
EXIT_SUCCESS
```

- These two values are defined as 1 and 0 for failure and success, respectively.
- The following listing shows the program which generates a random integer, 0 or 1. This value is used to determine which defined constant is returned as an exit status: `EXIT_FAILURE` or `EXIT_SUCCESS`.

```C
int main(){
    int r;
    srand((unsigned)time(NULL));
    
    r = rand() % 2;
    
    // Use r to test success (zero) or failure (one)
    if(r){
        fprintf(stderr, "Welp, this program screwed up!\n");
        return EXIT_FAILURE;
    }else{
        printf("Everything went ducky\n");
        return EXIT_SUCCESS;
    }
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ ./practice
Welp, this program screwed up!
chan@CMA:~/C_Programming/practice$ echo $?
1
chan@CMA:~/C_Programming/practice$ ./practice
Everything went ducky!
chan@CMA:~/C_Programming/practice$ echo $?
0

```

- Return values need not be limited to 0 and 1.
- Many programs and utilities return different values, each of which can be interpreted by a shell script to determine what happened.
- The interpretation of these values is up to whatever purpose the program has, to help it fulfill its function.

### Getting today's date

The following listing shows the typical time code for the C language.

- The current epoch value - the number of seconds ticked since January 1, 1970 - is obtained from the `time()` function and stored in `time_t` variable `now`. 
- This variable is used in the `localtime()` function to fill a `tm` structure, `today`. 
- The `tm` structure's members contain individual time tidbit values, which are output.

```C
int main(){
    time_t now;
    struct tm *today;
    int month, day, year, weekday;
    
    // Obtains the number of seconds elapsed since January 1, 1970 - the Unix epoch
    now = time(NULL);
    
    // Fills the `tm` structure today with time tidbits
    today = localtime(&now);
    
    // The `tm mon` member starts with 0 for January.
    month = today->tm_mon + 1;
    day = today->tm_mday;
    weekday = today->tm_wday;
    
    // The tm_year member starts with 1901.
    year = today->tm_year + 1900;
    
    // Output the values obtained from the tm structure
    printf("Today is %d, %d, %d, %d\n", weekday, month, day, year);
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 5, 11, 22, 2024
```

- `5` means Friday. `11` = November, 22 = `day`, 2024 = `year`.



**Exercise 12.1**

Update the code to output strings for the days of the week and months. This improvement requires adding two string arrays to the code and other updates, including to the `printf()` function.

```C
int main(){
    time_t now;
    struct tm *today;
    int month, day, year, weekday;
    
    const char *months[] = {
        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};

    const char *days[] = {
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    
    // Obtains the number of seconds elapsed since January 1, 1970 - the Unix epoch
    now = time(NULL);
    
    // Fill the tm structure today with time tidbits
    today = localtime(&now);
    
    month = today->tm_mon;
    day = today->tm_mday;
    weekday = today->tm_wday;
    year = today->tm_year + 1900;
    
    printf("Today is %s, %s, %d, %d\n", days[weekday], months[month], day, year);
    
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is Friday, November, 22, 2024
```



### Obtaining any old date

- The `time()` function obtains the current time, a `time_t` value containing the number of seconds elapsed from January 1, 1970.
- This value is useless by itself, which is why functions like `localtime()` help sort out the details for us.
- It's possible to backfill a `tm` structure.
- We assign values to the various members, then use the `mktime()` function to translate these time tidbits into a `time_t` value.
- Further, the `mktime()` function fills in unknown details for us, such as the day of the week.
- This information is vital if we plan to determine upon which date a holiday falls.

```C
time_t mktime(struct tm *tm);
```

- The function is passed the address of a partially filled `tm` structure. A `time_t` value is returned, but more importantly, the rest of the `tm` structure is filled with key details.
- The `mktime()` function is prototyped in the `time.h` header file.



##### Table 12.1 Members of the `tm` structure

| Member     | References           | Range/ Notes                                                 |
| ---------- | -------------------- | ------------------------------------------------------------ |
| `tm_sec`   | Seconds              | 0 to 60 (60 allows for a leap second)                        |
| `tm_min`   | Minutes              | 0 to 59                                                      |
| `tm_hour`  | Hours                | 0 to 23                                                      |
| `tm_mday`  | Day of the month     | 1 to 31                                                      |
| `tm_mon`   | Month                | 0 to 11                                                      |
| `tm_year`  | Year                 | Current year minus 1900                                      |
| `tm_wday`  | Day of the week      | 0 to 6, Sunday to Saturday                                   |
| `tm_yday`  | Day of the year      | 0 to 365; zero is January 1                                  |
| `tm_isdst` | Daylight saving time | Positive values indicate daylight saving time; zero indicates not; negative values indicate that the data is unavailable |



Let's say we want to find out the day of the week for November 29, 2024. 

The next listing attempts to do so by filling in three members of the `tm` structure: `tm_mon`, `tm_day`, and `tm_year`.

```C
int main(){
    struct tm day;
    const char *days[] = {
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"
    };
    
    // Filling the six `tm` struct members
    day.tm_mon = 11 - 1; // November (months are 0-based in struct tm)
    day.tm_mday = 29; // The 29th day of the month
    day.tm_year = 2024 - 1900;
    day.tm_hour = 0;
    day.tm_min = 0;
    day.tm_sec = 0;
    
    mktime(&day);
    
    // mm/dd/yyyy format
    printf("%02d/%02d/%04d is on a %s\n", day.tm_mon+1, day.tm_mday, day.tm_year + 1900, days[day.tm_wday]);
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
11/29/2024 is on a Friday
```

- We can obtain details about a date if we know the month, day, and year, by filling the six `tm` structure members and calling the `mktime()` function.

- In the provided file, the `mktime()` function plays a crucial role in **determining the day of the week for a specific date**. 

- **Purpose of `mktime()`**:

  - The primary purpose of using the `mktime()` function in this context is to **convert a `struct tm` structure, which represents a calendar date and time, into a `time_t` value**. 
  - Additionally, `mktime()` **normalizes the `struct tm` structure** by computing the corresponding `tm_wday` (day of the week) and `tm_yday` (day of the year) fields based on the provided date information.

- **Calling `mktime(&day);`:**

  - This function takes the `struct tm` pointer and converts it to `time_t`, which represents the calendar time.

  - **Normalization:**

    Beyond conversion, `mktime()` adjusts the `struct tm` fields to ensure they represent a valid date and time. This includes calculating:

    - `tm_wday`: The day of the week (0 = Sunday, 6 = Saturday).
    - `tm_yday`: The day of the year.

  - **Setting `tm_wday`:** After calling `mktime()`, the `tm_wday` field in the `day` structure is populated with the correct day of the week for the specified date.



### Is today a holiday?

- For a computer holiday detector, three timely tidbits are necessary:
  - The month number
  - The day of the month
  - The day of the week



### Reporting regular date holidays

- New Year's Day, January 1
- Juneteenth, June 19
- Independence Day, July 4
- Veterans Day, November 11
- Christmas Day, December 25



To report these dates, we will use the `isholiday()` function.

```C
int isholiday(struct tm *d);
```

- The function's only argument is the address of a `tim` structure, the same structure returned from the `localtime()` function and used by the `mktime()` function.
- The `isholiday()` function returns an integer value: 0 for nonholiday days and 1 for a holiday.
- The function does a straight-up comparison of month-and-day values to report the regular date holidays.

```C
int isholiday(struct tm *d){
    // New Year's Day (Jan 1)
    if( d->tm_mon==0 && d->tm_mday==1)
		return 1;
	
    // Juneteenth (June 19)
	if( d->tm_mon==5 && d->tm_mday==19)
		return 1;
	
    // Independence Day(July 4)
	if( d->tm_mon==6 && d->tm_mday==4)
		return 1;
	
    // Veterans Day (Nov 11)
	if( d->tm_mon==10 && d->tm_mday==11)
		return 1;
	
    // Christmas (Dec 25)
	if( d->tm_mon == 11 && d->tm_mday == 25)
		return 1;

	return 0;
}

int main(){
    time_t now;
    struct tm *today;
    int r;
    
    now = time(NULL);
    today = localtime(&now);
    
    printf("Today is %d/%02d/%d, ",
			today->tm_mon+1,
			today->tm_mday,
			today->tm_year+1900
		  );
    r = isholiday(today);
    
    if(r){
        puts("a holiday");
    }else{
        puts("not a holiday");
    }
    
    return r;
}
```

- The `main()` function calls the `time()` and `localtime()` functions to obtain the current time info and pack it into the `tm` structure.
- This structure is passed to `isholiday()` and the results reported.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/23/2024, not a holiday
```



First update to the `isholiday()` function, we can make it to report the holiday's name.

- To make this improvement, the `tm` structure must be ditched as the `isholiday()` function's argument.
- Instead, we will use a new structure `holiday`, defined with these members:

```C
struct holiday{
    int month;
    int day;
    char *name;
}
```

- The `month` and `day` members match up to the `tm_mon` and `tm_mday` members of the `tm` structure.
- The `name` member is a `char` pointer to hold the holiday's name.
- The strings assigned to this pointer are declared in the `isholiday()` function.

#### Holiday Detector Program

`practice.h`

```C
struct holiday{
    int month;
    int day;
    char *name;
}

int isholiday(struct holiday *h);
```

`functions.c`

```C
int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Year's Day",
        "Juneteenth",
        "Independence Day",
        "Veterans Day",
        "Christmas"};

    if (h->month == 0 && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }

    if (h->month == 5 && h->day == 19)
    {
        h->name = n[1];
        return 1;
    }

    if (h->month == 6 && h->day == 4)
    {
        h->name = n[2];
        return 1;
    }

    if (h->month == 10 && h->day == 11)
    {
        h->name = n[3];
        return 1;
    }

    if (h->month == 11 && h->day == 25)
    {
        h->name = n[4];
        return 1;
    }

    return 0;
}
```



`practice.c (main)`

```C
int main(){
    time_t now;
    struct tm *today;
    struct holiday h;
    int r;
    
    now = time(NULL);
    today = localtime(&now);
    
    h.month = today->tm_mon;
    h.day = today->tm_mday;
    h.name = NULL;
    
    printf("Today is %d/%02d/%d, ", today->tm_mon + 1, today->tm_mday, today->tm_year + 1900);
    
    r = isholiday(&h);
    
    // if(r) == if(r == 1)
    if(r){
        puts(h.name);
    }else{
        puts("Not a holiday");
    }
    
    return r;
}
```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/23/2024, Not a holiday
```

- To set and test a specific date instead of using the current date in our program,

`practice.c (main)`

```C
int main()
{
    struct holiday h;
    int r;

    h.month = 5;
    h.day = 19;
    h.name = NULL;

    printf("Today is %d/%02d/%d, ", h.month + 1, h.day, 2024);

    r = isholiday(&h);

    if (r)
    {
        puts(h.name);
    }
    else
    {
        puts("Not a holiday");
    }

    return r;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 6/19/2024, Juneteenth
```



Specifically, when one of these holidays falls on a weekend, it's often the Friday before or the Monday after that everyone takes a day off.

- When Independence Day (July 4) is on a Sunday, the country takes off Monday, July 5.

- Though when this type of holiday falls on a Tuesday, Wednesday, or Thursday, the day before or after isn't considered a holiday.

- To update our program, we will add a new member to our `holiday` structure, `wday`.

  - This member echoes the `tm_wday` member of the `tm` structure.
  - It indicates a day of the week - 0 for Sunday thru 6 for Saturday.

  ```C
  struct holiday{
      int month;
      int day;
      int wday;
      char *name;
  }
  ```

- Because only two days are required for testing, two enum constants are added.

  ```C
  enum{
      FRIDAY = 5,
      MONDAY = 1
  };
  ```

- When New Year's Day is observed on a Friday, the date is December 31 of the prior year.

- This difference makes the New Year's Day test a bit more complex than other Friday/Monday tests.



`practice.h`

```C
enum
{
    ERROR_CODE = -1,
    FRIDAY = 5,
    MONDAY = 1,
};

struct holiday
{
    int month;
    int day;
    int wday;
    char *name;
};

int isholiday(struct holiday *h);
```

`functions.c`

```C
int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Year's Day",
        "Juneteenth",
        "Independence Day",
        "Veterans Day",
        "Christmas"};

    // Specifically check for Friday, December 31
    if (h->month == 11 && h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        
        // Return 2 for "celebration" holidays
        return 2;
    }
	
    // Check for New Year's Day
    if (h->month == 0 && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }
	
    // Specifically check for Monday, Jan 2
    if (h->month == 0 && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Juneteenth is always in June
    if (h->month == 5)
    {
        
        // Focuses on the relevant days, before (18), the day (19), and after (20)
        if (h->day > 17 && h->day < 21)
        {
            // Check for the day before celebration
            if (h->day == 18 && h->wday == FRIDAY)
            {
                h->name = n[1];
                // Return 2 for celebration days
                return 2;
            }
            
            // Checks for the day after celebration
            if (h->day == 20 && h->wday == MONDAY)
            {
                h->name = n[1];
                return 2;
            }
            
            // Check for the actual holiday
            if (h->day == 19)
            {
                h->name = n[1];
                
                // Return 1 for the holiday
                return 1;
            }
        }
    }

    // Check for Independence Day (July 4th)
    if (h->month == 6)
    {
        if (h->day > 2 && h->day < 6)
        {
            // Check for the day before celebration
            if (h->day == 3 && h->wday == FRIDAY)
            {
                h->name = n[2];
                return 2;
            }
                        
            // Checks for the day after celebration
            if (h->day == 5 && h->wday == MONDAY)
            {
                h->name = n[2];
                return 2;
            }

             // Check for the actual holiday
            if (h->day == 4)
            {
                h->name = n[2];
                return 1;
            }
        }
    }
	
    //Check for Veterans Day (Nov 11th)
    if (h->month == 10)
    {
        if (h->day > 9 && h->day < 13)
        {
            // Check for the day before celebration
            if (h->day == 10 && h->wday == FRIDAY)
            {
                h->name = n[3];
                return 2;
            }
            
            // Checks for the day after celebration
            if (h->day == 12 && h->wday == MONDAY)
            {
                h->name = n[3];
                return 2;
            }
            
             // Check for the actual holiday
            if (h->day == 11)
            {
                h->name = n[3];
                return 1;
            }
        }
    }
	
    
    // Check for Christmas Day (Dec 25th)
    if (h->month == 11)
    {
        
        if (h->day > 23 && h->day < 27)
        {
            // Check for the day before celebration
            if (h->day == 24 && h->wday == FRIDAY)
            {
                h->name = n[4];
                return 2;
            }
            
            // Checks for the day after celebration
            if (h->day == 26 && h->wday == MONDAY)
            {
                h->name = n[4];
                return 2;
            }
            
             // Check for the actual holiday
            if (h->day == 25)
            {
                h->name = n[4];
                return 1;
            }
        }
    }

    return 0;
}
```



`practice.c (main)`

```C
#define _XOPEN_SOURCE 700
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <math.h>
#include <pthread.h>
#include "practice.h"
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <stdbool.h>
#include <tgmath.h>
#include <stdint.h>
#include <complex.h>
#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <ctype.h>

int main()
{
    struct holiday h;
    int r;

    h.month = 11; // December
    h.day = 26;
    h.name = NULL;
    h.wday = MONDAY; // Assuming December 26, 2024, is a Monday

    printf("Today is %d/%02d/%d, ", h.month + 1, h.day, 2024);

    r = isholiday(&h);

    if (r == 1)
    {
        puts(h.name);
    }
    else if (r == 2)
    {
        printf("%s observed\n", h.name);
    }
    else
    {
        puts("Not a holiday");
    }

    return r;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 12/26/2024, Christmas observed
```

**Scenario 2: Holiday Observed on Different Day**

- **Date Set:** December 24, 2024 (Christmas Observed on Friday)
- **Assumed `wday`:** FRIDAY (`5`)

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 12/24/2024, Christmas observed
```

### **Scenario 3: Not a Holiday**

- **Date Set:** April 27, 2024
- **Assumed `wday`:** Wednesday (`3`)

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 4/27/2024, Not a holiday
```



However there are so many repetition in the code which cries out for a function.

```C
int weekend(int holiday, int mday, int wday);
```

- Integer `holiday` is the day of the month on which the holiday occurs.
- Integers `mday` and `wday` are the day of the month and day of the week values, respectively.



```C
int weekend(int holiday, int mday, int wday){
    
    // Narrows down the days to search (2 days before and after the holiday)
    if(mday > holiday - 2 && mday < holiday + 2){
        // Test for the Friday before the holiday
        if(mday == holiday - 1 && wday == FRIDAY){
            return 2;
        }
        
        // Test for the Monday after the holiday
        if(mday == holiday + 1 && wday == MONDAY){
            return 2;
        }
        
        // Test for the holiday date itself
        if(mday == holiday){
            return 1;
        }
    }
    
    // Return zero for no matches
    return 0;
}
```



**Full Program**

`practice.h`

```C
enum
{
    ERROR_CODE = -1,
    FRIDAY = 5,
    MONDAY = 1,
};

struct holiday
{
    int month;
    int day;
    int wday;
    char *name;
};

int weekend(int holiday, int mday, int wday);

int isholiday(struct holiday *h);
```

`functions.c`

```C
int weekend(int holiday, int mday, int wday){
    
    // Narrows down the days to search (2 days before and after the holiday)
    if(mday > holiday - 2 && mday < holiday + 2){
        // Test for the Friday before the holiday
        if(mday == holiday - 1 && wday == FRIDAY){
            return 2;
        }
        
        // Test for the Monday after the holiday
        if(mday == holiday + 1 && wday == MONDAY){
            return 2;
        }
        
        // Test for the holiday date itself
        if(mday == holiday){
            return 1;
        }
    }
    
    // Return zero for no matches
    return 0;
}

int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Year's Day",
        "Juneteenth",
        "Independence Day",
        "Veterans Day",
        "Christmas"};
    int r;

    if (h->month == 11 & h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        return 2;
    }

    if (h->month == 0 && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }

    if (h->month == 0 && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    if (h->month == 5)
    {
        r = weekend(19, h->day, h->wday);
        h->name = n[1];
        return r;
    }

    if (h->month == 6)
    {
        r = weekend(4, h->day, h->wday);
        h->name = n[2];
        return r;
    }

    if (h->month == 10)
    {
        r = weekend(11, h->day, h->wday);
        h->name = n[3];
        return r;
    }

    if (h->month == 11)
    {
        r = weekend(25, h->day, h->wday);
        h->name = n[4];
        return r;
    }
    return 0;
}
```

`practice.c (main)`

```C
nt main()
{
    time_t now;
    struct tm *today;
    struct holiday h;
    int r;

    now = time(NULL);
    today = localtime(&now);
	
    // Test for Friday before the holiday
    h.month = 5;
    h.day = 18;
    h.name = NULL;
    h.wday = FRIDAY; //test for Friday

    printf("Today is %d/%02d/%d, ", h.month + 1, h.day, today->tm_year + 1900);

    r = isholiday(&h);

    if (r == 1)
    {
        puts(h.name);
    }
    else if (r == 2)
    {
        printf("%s observed\n", h.name);
    }
    else
    {
        puts("Not a holiday");
    }

    return r;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 6/18/2024, Juneteenth observed
```



With `h.wday = MONDAY` and `h.day = 20`,

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 6/20/2024, Juneteenth observed
```

With `h.wday = 0` and `h.day = 19`,

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 6/19/2024, Juneteenth
```



### Dealing with irregular holidays

- Unlike specific date holidays, irregular holidays occur on specific weeks and days of the month.
- These holidays are irregular in that they fall within a range of dates each year.
- The irregular holidays in the United States:
  - Martin Luther King Jr. Day, third Monday of January
  - Presidents Day, third Monday of February
  - Memorial Day, last Monday of May
  - Labor Day, first Monday of September
  - Columbus Day, second Monday of October
  - Thanksgiving, fourth Thursday of November
- Unlike the regular date holidays, we don't need to worry about a shifting observance day; these are all specific day-of-the-week holidays.
- This consistency means that it's possible to calculate a day-of-the-month range for each holiday.



**Table 12.4 Day ranges for Monday holidays on a given week**

| Week of month | Monday range  |
| ------------- | ------------- |
| First         | 1 to 7        |
| Second        | 8 to 14       |
| Third         | 15 to 21      |
| Fourth        | 22 to 28      |
| Last          | 25 and higher |

- The difference between the fourth and last week occurs in those months with five Mondays, such as May, as shown in figure 12.1.

![Screenshot from 2024-11-23 22-10-14](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-23 22-10-14.png)

- when the 31st of May falls on a Monday, it's the fifth Monday.
- The 24th of May is still in the fourth week, but in this month configuration, where the 31st is on a Monday, it's the last day.
- This reason is why the last week has a different range than the fourth week.
- For Thanksgiving, the final Thursday of the month could fall on any day from the 22nd through the 28th.



`practice.h`

```C
// Macros to determine the week of the month based on the day
#define FIRST_WEEK h->day < 8
#define SECOND_WEEK h->day > 7 && h->day < 15
#define THIRD_WEEK h->day > 14 && h->day < 22
#define FOURTH_WEEK h->day > 21 && h->day < 29
#define LAST_WEEK h->day > 24 && h->day < 32

enum
{
    ERROR_CODE = -1,
    FRIDAY = 5,
    MONDAY = 1,
    THURSDAY = 4,
};

struct holiday
{
    int month;
    int day;
    int wday;
    char *name;
};

int weekend(int holiday, int mday, int wday);

int isholiday(struct holiday *h);
```

`functions.c`

```C

int weekend(int holiday, int mday, int wday)
{
    if (mday > holiday - 2 && mday < holiday + 2)
    {
        if (mday == holiday - 1 && wday == FRIDAY)
        {
            return 2;
        }
        if (mday == holiday + 1 && wday == MONDAY)
        {
            return 2;
        }
        if (mday == holiday)
        {
            return 1;
        }
    }
}

int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Years Day",
        "Martin Luther King Day",
        "Presidents Day",
        "Memorial Day",
        "Juneteenth",
        "Independence Day",
        "Labor Day",
        "Columbus Day",
        "Veterans Day",
        "Thanksgiving",
        "Christmas"};
    int r;

    // Check for New Year's Day observed on Friday, December 31st
    if (h->month == 11 & h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for New Year's Day on January 1st
    if (h->month == 0 && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }

    // Check for New Year's Day observed on Monday, January 2nd
    if (h->month == 0 && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for Martin Luther King Jr. Day (third Monday of January)
    if (h->month == 0 && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[1];
            return 1;
        }
    }

    // Check for Presidents' Day (third Monday of February)
    if (h->month == 1 && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[2];
            return 1;
        }
    }

    // Check for Memorial Day (last Monday of May)
    if (h->month == 4 && h->wday == MONDAY)
    {
        if (LAST_WEEK)
        {
            h->name = n[3];
            return 1;
        }
    }

    // Check for Juneteenth (June 19th)
    if (h->month == 5)
    {
        r = weekend(19, h->day, h->wday);
        h->name = n[4];
        return r;
    }

    // Check for Independence Day (July 4th)
    if (h->month == 6)
    {
        r = weekend(4, h->day, h->wday);
        h->name = n[5];
        return r;
    }

    // Check for Labor Day (first Monday of September)
    if (h->month == 8 && h->wday == MONDAY)
    {
        if (FIRST_WEEK)
        {
            h->name = n[6];
            return 1;
        }
    }

    // Check for Columbus Day (second Monday of October)
    if (h->month == 9 && h->wday == MONDAY)
    {
        if (SECOND_WEEK)
        {
            h->name = n[7];
            return 1;
        }
    }

    // Check for Thanksgiving (fourth Thursday of November)
    if (h->month == 10)
    {
        if (h->wday == THURSDAY && FOURTH_WEEK)
        {
            h->name = n[9];
            return 1;
        }
        // Check for Veterans Day observed on a different day
        r = weekend(11, h->day, h->wday);
        h->name = n[8];
        return r;
    }

    // Check for Christmas Day (December 25th)
    if (h->month == 11)
    {
        r = weekend(25, h->day, h->wday); // Determine if Christmas is observed on a different day
        h->name = n[10];
        return r;
    }
    
    // If no holiday matches, return 0
    return 0;
}
```

`practice.c (main)`

```C
int main()
{
    time_t now;
    struct tm *today;
    struct holiday h;
    int r;

    now = time(NULL);
    today = localtime(&now);
	
    // Test for the third Monday of Jan
    h.month = 0;
    h.day = 16;
    h.name = NULL;
    h.wday = MONDAY;

    printf("Today is %d/%02d/%d, ", h.month + 1, h.day, today->tm_year + 1900);

    r = isholiday(&h);

    if (r == 1)
    {
        puts(h.name);
    }
    else if (r == 2)
    {
        printf("%s observed\n", h.name);
    }
    else
    {
        puts("Not a holiday");
    }

    return r;
}

```



`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 1/16/2024, Martin Luther King Day
```



```C
h.month = 10;
    h.day = 24;
    h.name = NULL;
    h.wday = THURSDAY;
```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/24/2024, Thanksgiving

```



**Exercise 12.2**

In a major update to the code, add constants for the months of the year.

`practice.h`

```C
#define FIRST_WEEK h->day < 8
#define SECOND_WEEK h->day > 7 && h->day < 15
#define THIRD_WEEK h->day > 14 && h->day < 22
#define FOURTH_WEEK h->day > 21 && h->day < 29
#define LAST_WEEK h->day > 24 && h->day < 32


enum
{
    FRIDAY = 5,
    MONDAY = 1,
    THURSDAY = 4,
    JANUARY = 0,
    FEBRUARY = 1,
    MARCH = 2,
    APRIL = 3,
    MAY = 4,
    JUNE = 5,
    JULY = 6,
    AUGUST = 7,
    SEPTEMBER = 8,
    OCTOBER = 9,
    NOVEMBER = 10,
    DECEMBER = 11
};

struct holiday
{
    int month;
    int day;
    int wday;
    char *name;
};

int weekend(int holiday, int mday, int wday);

int isholiday(struct holiday *h);
```

`functions.c`

```C
int weekend(int holiday, int mday, int wday)
{
    if (mday > holiday - 2 && mday < holiday + 2)
    {
        if (mday == holiday - 1 && wday == FRIDAY)
        {
            return 2;
        }
        if (mday == holiday + 1 && wday == MONDAY)
        {
            return 2;
        }
        if (mday == holiday)
        {
            return 1;
        }
    }
}

int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Years Day",
        "Martin Luther King Day",
        "Presidents Day",
        "Memorial Day",
        "Juneteenth",
        "Independence Day",
        "Labor Day",
        "Columbus Day",
        "Veterans Day",
        "Thanksgiving",
        "Christmas"};
    int r;

    // Check for New Year's Day observed on Friday, December 31st
    if (h->month == DECEMBER && h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for New Year's Day on January 1st
    if (h->month == JANUARY && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }

    // Check for New Year's Day observed on Monday, Jan 2nd
    if (h->month == JANUARY && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for Martin Luther King Day (third Monday of January)
    if (h->month == JANUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[1];
            return 1;
        }
    }

    // Check for Presidents' Day (third Monday of February)
    if (h->month == FEBRUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[2];
            return 1;
        }
    }

    // Check for Memorial Day (last Monday of May)
    if (h->month == MAY && h->wday == MONDAY)
    {
        if (LAST_WEEK)
        {
            h->name = n[3];
            return 1;
        }
    }

    // Check for Juneteenth (June 19th)
    if (h->month == JUNE)
    {
        r = weekend(19, h->day, h->wday);
        h->name = n[4];
        return r;
    }

    // Check for Independence Day (July 4th)
    if (h->month == JULY)
    {
        r = weekend(4, h->day, h->wday);
        h->name = n[5];
        return r;
    }

    // Check for Labor Day (first Monday of September)
    if (h->month == SEPTEMBER && h->wday == MONDAY)
    {
        if (FIRST_WEEK)
        {
            h->name = n[6];
            return 1;
        }
    }

    // Check for Columbus Day (second Monday of October)
    if (h->month == OCTOBER && h->wday == MONDAY)
    {
        if (SECOND_WEEK)
        {
            h->name = n[7];
            return 1;
        }
    }

    // Check for Thanksgiving (fourth Thursday of November)
    if (h->month == NOVEMBER)
    {
        if (h->wday == THURSDAY && FOURTH_WEEK)
        {
            h->name = n[9];
            return 1;
        }

        // Check for Veterans Day (November 11th)
        r = weekend(11, h->day, h->wday);
        h->name = n[8];
        return r;
    }

    // Check for Christmas Day (December 25th)
    if (h->month == DECEMBER)
    {
        r = weekend(25, h->day, h->wday);
        h->name = n[10];
        return r;
    }

    // If no holiday matches, return 0;
    return 0;
}
```



`practice.c (main)`

```C
int main()
{
    time_t now;
    struct tm *today;
    struct holiday h;
    int r;

    now = time(NULL);
    today = localtime(&now);

    // Test for Labor Day
    h.month = SEPTEMBER;
    h.day = 1;
    h.wday = MONDAY;

    printf("Today is %d/%02d/%d, ", h.month + 1, h.day, today->tm_year + 1900);

    r = isholiday(&h);

    if (r == 1)
    {
        puts(h.name);
    }
    else if (r == 2)
    {
        printf("%s is observed\n", h.name);
    }
    else
    {
        puts("Not a holiday");
    }
    return r;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 9/01/2024, Labor Day

```



```C
// Test for Veterans Day
    h.month = NOVEMBER;
    h.day = 11;
    h.wday = 0;
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/11/2024, Veterans Day
```



```C
// Test when the day before holiday is FRIDAY
h.month = NOVEMBER;
    h.day = 10;
    h.wday = FRIDAY;
```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/10/2024, Veterans Day is observed
```



```C
// Test when the day after the holiday is MONDAY
h.month = NOVEMBER;
    h.day = 12;
    h.wday = MONDAY;
```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/12/2024, Veterans Day is observed
```



### Calculating Easter

- Easter falls on different dates each year because it's the last holiday remaining in Western culture based on the lunar calendar.
- On the solar calendar, the date of Easter can be as early as March 22 or as late as April 25.]
- It's always on Sunday.
- For the lunar calender, Easter is the first Sunday after the first new moon after the vernal equinox.

```C
// Accepts a year value as the only argument
void easter(int year)
{
    // Lots of int and double variables
    int Y, a, c, e, h, k, L;
    double b, d, f, g, i, m, month, day;

    Y = year;
    a = Y % 19;
    b = floor(Y / 100);
    c = Y % 100;
    d = floor(b / 4);
    e = (int)b % 4;

    f = floor((b + 8) / 25);
    g = floor((b - f + 1) / 3);
    h = (19 * a + (int)b - (int)d - (int)g + 15) % 30;
    i = floor(c / 4);
    k = c % 4;
    L = (32 + 2 * e + 2 * (int)i - h - k) % 7;
    m = floor((a + 11 * h + 22 * L) / 451);
    
    // Obtain the month for Easter, either 3 (March) or 4 (April)
    month = floor((h + L - 7 * m + 114) / 31);
    
    // Obtain the day of the month
    day = ((h + L - 7 * (int)m + 114) % 31) + 1;

    printf("In %d, Easter is ", Y);
    if (month == 3)
    {
        printf("March %d\n", (int)day);
    }
    else
    {
        printf("April %d\n", (int)day);
    }
}

int main()
{
    int x;
    for (x = 2018; x < 2036; x++)
    {
        easter(x);
    }
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
In 2018, Easter is April 1
In 2019, Easter is April 21
In 2020, Easter is April 12
In 2021, Easter is April 4
In 2022, Easter is April 17
In 2023, Easter is April 9
In 2024, Easter is March 31
In 2025, Easter is April 20
In 2026, Easter is April 5
In 2027, Easter is March 28
In 2028, Easter is April 16
In 2029, Easter is April 1
In 2030, Easter is April 21
In 2031, Easter is April 13
In 2032, Easter is March 28
In 2033, Easter is April 17
In 2034, Easter is April 9
In 2035, Easter is March 25
```



In order to merge `easter()` function into the `isholiday()` function, the `easter()` function must:

- be modified to accept a date value and return 1 or 0 depending on whether the date matches Easter for the given year.
- First, the `holiday` structure must be modified to also include a `year` member:

```C
struct holiday{
    int month;
    int day;
    int year;
    int wday;
    char *name;
};
```

- Second, the `year` member's value must be assigned in the `main()` function:

```C
h.year = today->tm_year + 1900;
```

- Third, a call must be made to `easter()` in the `isholiday()` function.
- At the start of the function, a string for Easter is added to the `n[]` pointer array.
- The "Easter" string is last in the array declaration, `n[11]`.
- These statements in the `isholiday()` function call the `easter()` function.
- They are the last few statements in the function, right before the final `return`:

```C
r = easter(h);
if(r == 1){
    h->name = n[10];
    return r;
}
```



`practice.h`

```C
// Functions.c

#define FIRST_WEEK h->day < 8
#define SECOND_WEEK h->day > 7 && h->day < 15
#define THIRD_WEEK h->day > 14 && h->day < 22
#define FOURTH_WEEK h->day > 21 && h->day < 29
#define LAST_WEEK h->day > 24 && h->day < 32

enum
{
    FRIDAY = 5,
    MONDAY = 1,
    THURSDAY = 4,
    JANUARY = 0,
    FEBRUARY = 1,
    MARCH = 2,
    APRIL = 3,
    MAY = 4,
    JUNE = 5,
    JULY = 6,
    AUGUST = 7,
    SEPTEMBER = 8,
    OCTOBER = 9,
    NOVEMBER = 10,
    DECEMBER = 11
};

struct holiday
{
    int month;
    int day;
    int year;
    int wday;
    char *name;
};

int weekend(int holiday, int mday, int wday);

int isholiday(struct holiday *h);

// Functions_2.c
int easter(struct holiday *hday);
```

`functions.c`

```C

int easter(struct holiday *hday)
{
    // Lots of int variables
    int Y, a, c, e, h, k, L;
    double b, d, f, g, i, m, month, day;

    Y = hday->year;
    a = Y % 19;
    b = floor(Y / 100);
    c = Y % 100;
    d = floor(b / 4);
    e = (int)b % 4;

    f = floor((b + 8) / 25);
    g = floor((b - f + 1) / 3);
    h = (19 * a + (int)b - (int)d - (int)g + 15) % 30;
    i = floor(c / 4);
    k = c % 4;
    L = (32 + 2 * e + 2 * (int)i - h - k) % 7;
    m = floor((a + 11 * h + 22 * L) / 451);
    month = floor((h + L - 7 * m + 114) / 31) - 1;
    day = ((h + L - 7 * (int)m + 114) % 31) + 1;

    if (hday->month == month && hday->day == day)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int weekend(int holiday, int mday, int wday)
{
    if (mday > holiday - 2 && mday < holiday + 2)
    {
        if (mday == holiday - 1 && wday == FRIDAY)
        {
            return 2;
        }
        if (mday == holiday + 1 && wday == MONDAY)
        {
            return 2;
        }
        if (mday == holiday)
        {
            return 1;
        }
    }
}

int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Years Day",
        "Martin Luther King Day",
        "Presidents Day",
        "Memorial Day",
        "Juneteenth",
        "Independence Day",
        "Labor Day",
        "Columbus Day",
        "Veterans Day",
        "Thanksgiving",
        "Christmas", "Easter"};
    int r;

    // Check for New Year's Day observed on Friday, December 31st
    if (h->month == DECEMBER && h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for New Year's Day on January 1st
    if (h->month == JANUARY && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }

    // Check for New Year's Day observed on Monday, Jan 2nd
    if (h->month == JANUARY && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for Martin Luther King Day (third Monday of January)
    if (h->month == JANUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[1];
            return 1;
        }
    }

    // Check for Presidents' Day (third Monday of February)
    if (h->month == FEBRUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[2];
            return 1;
        }
    }

    // Check for Memorial Day (last Monday of May)
    if (h->month == MAY && h->wday == MONDAY)
    {
        if (LAST_WEEK)
        {
            h->name = n[3];
            return 1;
        }
    }

    // Check for Juneteenth (June 19th)
    if (h->month == JUNE)
    {
        r = weekend(19, h->day, h->wday);
        h->name = n[4];
        return r;
    }

    // Check for Independence Day (July 4th)
    if (h->month == JULY)
    {
        r = weekend(4, h->day, h->wday);
        h->name = n[5];
        return r;
    }

    // Check for Labor Day (first Monday of September)
    if (h->month == SEPTEMBER && h->wday == MONDAY)
    {
        if (FIRST_WEEK)
        {
            h->name = n[6];
            return 1;
        }
    }

    // Check for Columbus Day (second Monday of October)
    if (h->month == OCTOBER && h->wday == MONDAY)
    {
        if (SECOND_WEEK)
        {
            h->name = n[7];
            return 1;
        }
    }

    // Check for Thanksgiving (fourth Thursday of November)
    if (h->month == NOVEMBER)
    {
        if (h->wday == THURSDAY && FOURTH_WEEK)
        {
            h->name = n[9];
            return 1;
        }

        // Check for Veterans Day (November 11th)
        r = weekend(11, h->day, h->wday);
        h->name = n[8];
        return r;
    }

    // Check for Christmas Day (December 25th)
    if (h->month == DECEMBER)
    {
        r = weekend(25, h->day, h->wday);
        h->name = n[10];
        return r;
    }

    r = easter(h);
    if (r == 1)
    {
        h->name = n[11];
        return r;
    }

    // If no holiday matches, return 0;
    return 0;
}
```



`practice.c (main)`

```C
int main()
{
    time_t now;
    struct tm *today;
    struct holiday h;
    int r;

    now = time(NULL);
    today = localtime(&now);

    // Testing for today's date
    h.month = today->tm_mon;
    h.day = today->tm_mday;
    h.year = today->tm_year + 1900;
    h.wday = today->tm_wday;
    h.name = NULL;

    printf("Today is %d/%02d/%d, ", today->tm_mon + 1, today->tm_mday, today->tm_year + 1900);

    r = isholiday(&h);
    if (r == 1)
    {
        puts(h.name);
    }
    else if (r == 2)
    {
        printf("%s observed\n", h.name);
    }
    else
    {
        puts("Not a holiday");
    }
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 11/24/2024, Not a holiday
```

```C
// Test for March 31st 2024
h.month = MARCH;
    h.day = 31;
    h.year = today->tm_year + 1900;
    h.wday = today->tm_wday;
    h.name = NULL;

    printf("Today is %d/%02d/%d, ", h.month, h.day, today->tm_year + 1900);
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is 2/31/2024, Easter
```



### Running the date gauntlet

- To test the `isholiday()` function, we must run it through the date gauntlet.
- This test is a program that generates dates from January 1 through December 31 for a given year.
- The goal is to ensure that the `isholiday()` function properly reacts, reporting the national holidays.
- The next listing contains two arrays of string constants to represent months and days of the week.
- The `mdays[]` array lists the member of days in each month, where it's assumed the year isn't a leap year.
- February has only 28 days in the code.
- The dates are output in a nested loop: the outer loop processes months, and the inner loop churns days of the month.

```C
int main(){
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };
	
    // Determines days of each month, assuming it isn't a leap year
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    enum{SU, MO, TU, WE, TH, FR, SA};
    
    int start_day, dom, doy, year, m, r;
    struct holiday h;
    //Set the starting day for 2025, Saturday
    start_day = SA;
    
    // The first day of the year
    doy = 1;
    
    // The year to be output (not a leap year)
    year = 2025;
    
    // Loop thru 12 months of the year
    for(m = 0; m < 12; m++){
        // Loop thru each day of the month
        for(dom = 1; dom <= mdays[m]; dom++){
            // Math to Determine the proper day of the week
            printf("%s, %s %d, %d\n", weekday[(doy + start_day - 1)] % 7), month[m], dom, year);
            
            // increment the day of the year
            doy++;
        }
    }
    return 0;
}
```

- The math in the code determines the proper day of the week.
- This detail is based on the `start_day` variable set to the proper day of the week for January 1, which is a Saturday - enumerated constant `SA` in the code.
- The day-of-the-year variable, `doy`, is used in this calculation, incremented in the inner loop to keep track of each day of the year.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Saturday, January 1, 2025
Sunday, January 2, 2025
Monday, January 3, 2025
Tuesday, January 4, 2025
Wednesday, January 5, 2025
Thursday, January 6, 2025
Friday, January 7, 2025
Saturday, January 8, 2025
....
....
....
....
Friday, December 23, 2025
Saturday, December 24, 2025
Sunday, December 25, 2025
Monday, December 26, 2025
Tuesday, December 27, 2025
Wednesday, December 28, 2025
Thursday, December 29, 2025
Friday, December 30, 2025
Saturday, December 31, 2025
chan@CMA:~/C_Programming/practice$ 

```



The next step is to add the functions `isholiday()`, `weekend()`, and `easter()` to the code to confirm that all holidays are properly tracked throughout the year.

- As the gaunlet code churns through days of the year, the `isholiday()` function is called.
- Only holidays are output.
- Only a minor changes are needed to be applied to the `main()` function.



#### Full Holiday Detector Program (Completed Version)

`practice.h`

```C
// Functions.c

#define FIRST_WEEK h->day < 8
#define SECOND_WEEK h->day > 7 && h->day < 15
#define THIRD_WEEK h->day > 14 && h->day < 22
#define FOURTH_WEEK h->day > 21 && h->day < 29
#define LAST_WEEK h->day > 24 && h->day < 32

enum
{
    FRIDAY = 5,
    MONDAY = 1,
    THURSDAY = 4,
    JANUARY = 0,
    FEBRUARY = 1,
    MARCH = 2,
    APRIL = 3,
    MAY = 4,
    JUNE = 5,
    JULY = 6,
    AUGUST = 7,
    SEPTEMBER = 8,
    OCTOBER = 9,
    NOVEMBER = 10,
    DECEMBER = 11
};

struct holiday
{
    int month;
    int day;
    int year;
    int wday;
    char *name;
};

int weekend(int holiday, int mday, int wday);

int isholiday(struct holiday *h);

// Functions_2.c
int easter(struct holiday *hday);
```

`functions.c`

```C
int easter(struct holiday *hday)
{
    // Lots of int variables
    int Y, a, c, e, h, k, L;
    double b, d, f, g, i, m, month, day;

    Y = hday->year;
    a = Y % 19;
    b = floor(Y / 100);
    c = Y % 100;
    d = floor(b / 4);
    e = (int)b % 4;

    f = floor((b + 8) / 25);
    g = floor((b - f + 1) / 3);
    h = (19 * a + (int)b - (int)d - (int)g + 15) % 30;
    i = floor(c / 4);
    k = c % 4;
    L = (32 + 2 * e + 2 * (int)i - h - k) % 7;
    m = floor((a + 11 * h + 22 * L) / 451);
    month = floor((h + L - 7 * m + 114) / 31) - 1;
    day = ((h + L - 7 * (int)m + 114) % 31) + 1;

    if (hday->month == month && hday->day == day)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int weekend(int holiday, int mday, int wday)
{
    if (mday > holiday - 2 && mday < holiday + 2)
    {
        if (mday == holiday - 1 && wday == FRIDAY)
        {
            return 2;
        }
        if (mday == holiday + 1 && wday == MONDAY)
        {
            return 2;
        }
        if (mday == holiday)
        {
            return 1;
        }
    }
}

int isholiday(struct holiday *h)
{
    char *n[] = {
        "New Years Day",
        "Martin Luther King Day",
        "Presidents Day",
        "Memorial Day",
        "Juneteenth",
        "Independence Day",
        "Labor Day",
        "Columbus Day",
        "Veterans Day",
        "Thanksgiving",
        "Christmas", "Easter"};
    int r;

    // Check for New Year's Day observed on Friday, December 31st
    if (h->month == DECEMBER && h->day == 31 && h->wday == FRIDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for New Year's Day on January 1st
    if (h->month == JANUARY && h->day == 1)
    {
        h->name = n[0];
        return 1;
    }

    // Check for New Year's Day observed on Monday, Jan 2nd
    if (h->month == JANUARY && h->day == 2 && h->wday == MONDAY)
    {
        h->name = n[0];
        return 2;
    }

    // Check for Martin Luther King Day (third Monday of January)
    if (h->month == JANUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[1];
            return 1;
        }
    }

    // Check for Presidents' Day (third Monday of February)
    if (h->month == FEBRUARY && h->wday == MONDAY)
    {
        if (THIRD_WEEK)
        {
            h->name = n[2];
            return 1;
        }
    }

    // Check for Memorial Day (last Monday of May)
    if (h->month == MAY && h->wday == MONDAY)
    {
        if (LAST_WEEK)
        {
            h->name = n[3];
            return 1;
        }
    }

    // Check for Juneteenth (June 19th)
    if (h->month == JUNE)
    {
        r = weekend(19, h->day, h->wday);
        h->name = n[4];
        return r;
    }

    // Check for Independence Day (July 4th)
    if (h->month == JULY)
    {
        r = weekend(4, h->day, h->wday);
        h->name = n[5];
        return r;
    }

    // Check for Labor Day (first Monday of September)
    if (h->month == SEPTEMBER && h->wday == MONDAY)
    {
        if (FIRST_WEEK)
        {
            h->name = n[6];
            return 1;
        }
    }

    // Check for Columbus Day (second Monday of October)
    if (h->month == OCTOBER && h->wday == MONDAY)
    {
        if (SECOND_WEEK)
        {
            h->name = n[7];
            return 1;
        }
    }

    // Check for Thanksgiving (fourth Thursday of November)
    if (h->month == NOVEMBER)
    {
        if (h->wday == THURSDAY && FOURTH_WEEK)
        {
            h->name = n[9];
            return 1;
        }

        // Check for Veterans Day (November 11th)
        r = weekend(11, h->day, h->wday);
        h->name = n[8];
        return r;
    }

    // Check for Christmas Day (December 25th)
    if (h->month == DECEMBER)
    {
        r = weekend(25, h->day, h->wday);
        h->name = n[10];
        return r;
    }

    r = easter(h);
    if (r == 1)
    {
        h->name = n[11];
        return r;
    }

    // If no holiday matches, return 0;
    return 0;
}
```

`practice.c (main)`

```C
int main(){
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };
	
    // Determines days of each month, assuming it isn't a leap year
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    
    enum{SU, MO, TU, WE, TH, FR, SA};
    
    int start_day, dom, doy, year, m, r;
    struct holiday h;
    //Set the starting day for 2025, Saturday
    start_day = SA;
    
    // The first day of the year
    doy = 1;
    
    // The year to be output (not a leap year)
    year = 2025;
    
    // Loop thru 12 months of the year
    for(m = 0; m < 12; m++){
        // Loop thru each day of the month
        for(dom = 1; dom <= mdays[m]; dom++){
            h.month = m;
            h.day = dom;
            h.year = year;
            h.wday = (doy + start_day - 1) % 7;
            h.name = NULL;
            
            r = isholiday(&h);
            
            if (r == 1)
            {
                printf("%s, %s %d, %d is %s\n", weekday[h.wday], month[h.month], h.day, h.year, h.name);
            }
            if (r == 2)
            {
                printf("%s, %s %d, %d %s is observed\n", weekday[h.wday], month[h.month], h.day, h.year, h.name);
            }
            // increment the day of the year
            doy++;
        }
    }
    return 0;
}
```



`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Saturday, January 1, 2025 is New Years Day
Monday, January 17, 2025 is Martin Luther King Day
Monday, February 21, 2025 is Presidents Day
Wednesday, April 20, 2025 is Easter
Monday, May 30, 2025 is Memorial Day
Sunday, June 19, 2025 is Juneteenth
Monday, June 20, 2025 Juneteenth is observed
Monday, July 4, 2025 is Independence Day
Monday, September 5, 2025 is Labor Day
Monday, October 10, 2025 is Columbus Day
Friday, November 11, 2025 is Veterans Day
Thursday, November 24, 2025 is Thanksgiving
Sunday, December 25, 2025 is Christmas
Monday, December 26, 2025 Christmas is observed

```



---

## Chapter 13 - Calendar



### The calendar program

```shell
chan@CMA:~$ cal
   November 2024      
Su Mo Tu We Th Fr Sa  
                1  2  
 3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30  
```

- We can follow `cal` with a year argument to obtain the full, 12-month calendar for the given year:

```shell
chan@CMA:~$ cal 1999
```

-  We can add a month argument to see the calendar for a specific month in a specific year:

```shell
chan@CMA:~$ cal 11 1999
   November 1999      
Su Mo Tu We Th Fr Sa  
    1  2  3  4  5  6  
 7  8  9 10 11 12 13  
14 15 16 17 18 19 20  
21 22 23 24 25 26 27  
28 29 30              
```

- The month can be specified numerically or by name.



- To see the next three months of output, specify the `-A2` argument:

```shell
chan@CMA:~$ cal -A2
   November 2024         December 2024          January 2025      
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
                1  2   1  2  3  4  5  6  7            1  2  3  4  
 3  4  5  6  7  8  9   8  9 10 11 12 13 14   5  6  7  8  9 10 11  
10 11 12 13 14 15 16  15 16 17 18 19 20 21  12 13 14 15 16 17 18  
17 18 19 20 21 22 23  22 23 24 25 26 27 28  19 20 21 22 23 24 25  
24 25 26 27 28 29 30  29 30 31              26 27 28 29 30 31 
```



### Creating constants and enumerating dates

- For weekday and month names, `const char` pointers - string constants will be used.

```C
const char *weekday[] ={
    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
};
```

```C
const char *weekday[] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};
```

```C
const char *month[] = {
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
};
```

- Each statement creates an array of pointers: storage for each string is allocated by the program at runtime.
- What remains is an array of addresses.
- Each array in in a sequence that matches the `tm_wday` and `tm_mon` members of the `tm` structure returned from the `localtime()` function.
- For example, the `tm_mon` member for January is numbered 0, and the zeroth element of the `month[]` array is the string for January.
- The `const` classifier declares these arrays as immutable, which prevents them from being accidentally altered elsewhere in the code.
- The strings can be passed to functions, but don't change them!.
- Doing so leads to unpredictable behavior, but not when they're classified as constants.
- Paring with these two arrays, enumerated constants will be used to represent the weekday and month values.
- `enum` helps us define constants similarly to the way an array defines groups of variables with the same data type.
- Values in `enum` are assigned sequentially, starting with 0:

```C
enum{FALSE, TRUE};
```

- Here, constant `FALSE` is defined as 0; `TRUE` as 1.

```C
enum{ALPHA = 1, GAMMA = 5, DELTA, EPSILON, THETA};
```

- This statement defines constant `ALPHA` as 1.
- Constant `GAMMA` is set equal to 5, with the rest of the constants numbered sequentially: `DELTA` is 6, `EPSILON` is 7, and `THETA` is 8.

In the following listing, the `time()` function obtains the current epoch value, a `time_t` data type.

- The `localtime()` function uses this value to fill a `tm` structure, `date`.
- The month, month day, year, and weekday values are then interpreted and output, displaying the current day and date.

```C
int main()
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    time_t now;
    struct tm *date;
	
    // Obtain the current clock tick value
    time(&now);
    
    // Fills the `tm_date` structure with individual time values
    date = localtime(&now);

    printf("Today is %s %d, %d, a %s\n", month[date->tm_mon], date->tm_mday, date->tm_year + 1900, weekday[date->tm_wday]);
    return 0;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
Today is November 25, 2024, a Monday
```





### Demonstrating an algorithm to find the weekday for any day, month and year

`Sakamoto Algorithm`

- **Sakamoto's Algorithm** is a concise method to calculate the day of the week for any given date. 
- It was devised by **Hideo Sakamoto** and is known for its simplicity and efficiency. 

- The algorithm assigns specific values to each month, adjusts the year based on the month, and then applies a formula to compute the day of the week.
- **Key Components:**
  1. **Month Table (`t[]`):**
     - An array that holds values corresponding to each month.
     - These values are used in the calculation to account for the varying number of days in each month.
  2. **Year Adjustment:**
     - If the month is January or February (i.e., month < 3), the year is decremented by 1. This adjustment aligns the months correctly within the Gregorian calendar leap year rules.
  3. **Day of the Week Calculation:**
     - The formula combines the adjusted year, month table value, day, and leap year considerations to compute the day of the week.
     - The result is taken modulo 7 to obtain a value between 0 and 6, each representing a day from Sunday to Saturday.

```C
int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
year -= month < 3;
r = (year + year / 4 - year / 100 + year / 400 + t[month - 1] + day) % 7;
```



```C
// The month value, m, ranges from 0 thru 11 for Jan thru Dec. d is the day of the month, and y is the full year value (tm_year + 1900)
int dayoftheweek(int m, int d, int y)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    int r = 0;
    ;

    // The m < 2 evaluation is either 1 or 0, which is added to the year variable
    y -= m < 2;
    r = (y + y / 4 - y / 100 + y / 400 + t[m] + d) % 7;
    return r;
}

int main()
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    int m, d, y, r;

    m = 10;
    d = 29;
    y = 1999;

    r = dayoftheweek(m, d, y);

    printf("%s %d, %d was a %s\n", month[m], d, y, weekday[r]);
    return 0;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
November 29, 1999 was a Monday
```



**Exercise 13.1**

Modify the source code so that command-line arguments are interpreted as the month, day, and year for which we want to find the day of the week.

**Author's Solution**

```C
int dayoftheweek(int m, int d, int y)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    y -= m < 2;
    int r = (y + y / 4 - y / 100 + y / 400 + t[m] + d) % 7;
    return r;
}

int main(int argc, char *argv[])
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    int m, d, y, r;

    if (argc < 4)
    {
        fprintf(stderr, "Format: month day year\n");
        exit(1);
    }

    // Convert command-line arguments into integers
    m = strtol(argv[1], NULL, 10);

    // No human will type 0 for January
    m--;

    d = strtol(argv[2], NULL, 10);
    y = strtol(argv[3], NULL, 10);

    r = dayoftheweek(m, d, y);

    printf("%s %d, %d was a %s\n", month[m], d, y, weekday[r]);
    return 0;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice 11 29 1999
November 29, 1999 was a Monday
chan@CMA:~/C_Programming/practice$ ./practice 10 19 1987
October 19, 1987 was a Monday

```



**My Solution**

```C
int dayoftheweek(int m, int d, int y)
{
    int t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};

    if (m < 3)
    {
        y -= 1;
    }
    int r = (y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7;
    return r;
}

int main()
{
    const char *month[] = {
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    };

    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    int m, d, y, r;

    printf("Enter month, day, year: ");

    if (scanf("%d %d %d", &m, &d, &y) != 3)
    {
        printf("Invalid input format.\n");
        return 1;
    }

    if (m < 1 || m > 12)
    {
        printf("Invalid month. Please enter a value between 1 and 12.\n");
        return 1;
    }
    if (d < 1 || d > 31)
    {
        printf("Invalid day. Please enter a value between 1 and 31.\n");
        return 1;
    }

    r = dayoftheweek(m, d, y);

    printf("%s %d, %d was a %s\n", month[m - 1], d, y, weekday[r]);
    return 0;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Enter date (MM DD YYYY): 11 29 1999
November 29, 1999 was a Monday
chan@CMA:~/C_Programming/practice$ ./practice
Enter date (MM DD YYYY): 10 19 1987
October 19, 1987 was a Monday

```



### Calculating the first day of the month

![Screenshot from 2024-11-25 21-22-50](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-25 21-22-50.png)

- If today is  Monday the 20th, the first of the month is on a Wednesday, always, for any month where Monday is the 20th.
- When given a day of the month and its weekday, the computer can easily calculate upon which day the first of the month falls.

```C
first = weekday - (day % 7) + 1;
```

- Assume today is the 23rd. It's a Thursday, numeric value 4:

```C
first = 4 - (23 % 7) + 1;
first = 4 - 2 + 1;
first  = 3;
```

- When a month has the 23rd fall on a Thursday, the first is on a Wednesday (value 3.)
- The next listing shows code that obtains the current date. 
  - It uses the weekday and day of the month values to work the algorithm, outputting on which weekday the first of the month falls.

```C
int thefirst(int wday, int mday)
{
    int first = wday - (mday % 7) + 1;
    if (first < 0)
    {
        first += 7;
    }
    return first;
}

int main()
{
    enum
    {
        SUNDAY,
        MONDAY,
        TUESDAY,
        WEDNESDAY,
        THURSDAY,
        FRIDAY,
        SATURDAY
    };
    const char *weekday[] = {
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    };

    printf("If day %d is a %s, the first is on a %s\n", 25, weekday[SATURDAY], weekday[thefirst(SATURDAY, 25)]);
    return 0;
}

```

![Screenshot from 2024-11-25 21-22-50](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-25 21-22-50.png)

```shell
chan@CMA:~/C_Programming/practice$ ./practice
If day 25 is a Saturday, the first is on a Wednesday
```



### Identifying leap years

- Leap year rules:
  - If the year is divisible by both 100 and 400, it's a leap year.
  - If the year is divisible only by 100, it's not a leap year.
  - If the year is divisible by four, it's a leap year.

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

int main()
{
    int y;
    for (y = 1999; y <= 2024; y++)
    {
        if (february(y) == 29)
        {
            printf("%d is a leap year\n", y);
        }
    }
    return 0;
}

```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
2000 is a leap year
2004 is a leap year
2008 is a leap year
2012 is a leap year
2016 is a leap year
2020 is a leap year
2024 is a leap year
```



- In Linux, we can check the computer's time zone information by examining the `/etc/localtime` symbolic link.

```shell
chan@CMA:~$ ls -l /etc/localtime
lrwxrwxrwx 1 root root 32 Oct 22 22:38 /etc/localtime -> /usr/share/zoneinfo/Asia/Bangkok
```

- The output we see is local to my system, a value set when Linux was first configured.



### `putenv()` and `tzset()`

#### `putenv()`

- The `putenv()` adds an environment variable to the program's local environment; the change doesn't affect the shell.

```C
int putenv(char *string);
```

- The `string` is the environment entry to add.
- In this case, it's `TZ=GMT` for "time zone equals Greenwich Mean Time".
- This function requires the inclusion of the `stdlib.h` library.



#### `tzset()`

- The `tzset()` function sets the program's time zone but only while it runs.
- The function doesn't otherwise alter the system.

```C
void tzset(void);
```

- The `tzset()` requires no arguments because it uses the `TZ` environment variable to set the program's time zone.
- The `time.h` header must be included for this function to behave properly.



```C
int main()
{
    time_t epoch = 0;

    putenv("TZ=GMT");
    tzset();
    printf("Time is %s", ctime(&epoch));
    return 0;
}

```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Time is Thu Jan  1 00:00:00 1970
```

- The output now reflects the true Unix epoch as the program's time zone is changed to GMT internally.
- One decision to make right way with any calendar utility is whether the week starts on Monday or Sunday.



```C
int main()
{
    const char *months[] = {
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"};
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d;
	
    // obtain the current time in clock ticks
    time(&now);
    
    // convert the time_t value into tm structure members
    date = localtime(&now);

    day = date->tm_mday;
    month = date->tm_mon;
    weekday = date->tm_wday;
    
    // calculate the date for Sunday
    sunday = day - weekday;

    printf("  %s\n", months[month]);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    
    // Loop thru days of the week, Sunday thru Sunday + 7
    for (d = sunday; d < sunday + 7; d++)
    {
        // for the current day, output its value in brackets
        if (d == day)
        {
            printf("[%2d]", d);
        }
        else
        {
            // Output every other day without brackets
            printf(" %2d ", d);
        }
    }

    putchar('\n');
    return 0;
}
```

- The `localtime()` function reports details about the current day of the week.

- ```C
  sunday = day_of_the_month - weekday;
  ```

- The `day_of_the_month` value is found in the `tm` structure, member `tm_mday`. 

- Today's `weekday` value is member `tm_wday`.

- As an example, if today is Thursday the 16th, the formula reads:

```C
sunday = 16 - 4;
```

- The `sunday` value is then used in a loop to output the seven days of the week.

- The primary reason for using `sunday + 7` in the loop condition is to ensure that the loop iterates exactly **seven times**, corresponding to the **seven days of the week** (Sunday through Saturday). 

- By setting the loop to run while `d < sunday + 7`, we cover a range of seven days:

  - **Start:** `d = sunday`
  - **End:** `d = sunday + 6`
    (since the loop stops before `d` reaches `sunday + 7`)

  This range (`sunday` to `sunday + 6`) encompasses all seven days of the week:

  - **Sunday:** `d = sunday`
  - **Monday:** `d = sunday + 1`
  - ...
  - **Saturday:** `d = sunday + 6`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
Sun Mon Tue Wed Thu Fri Sat
 24 [25] 26  27  28  29  30 
```

- The loop outputs days of the week, starting at Sunday. The current day is highlighted.
- Of course, this code isn't perfect. If the first of the month falls on any day other than Sunday, we see output like this:

![Screenshot from 2024-11-26 16-53-02](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-26 16-53-02.png)

- Likewise, at the end of the month, we can see output like this:

![Screenshot from 2024-11-26 17-07-34](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-26 17-07-34.png)

- For the first update to the code, in the `for` loop, if the value of variable `d` is less than one, spaces are output instead of the day value.
- Likewise, spaces are output when the day value is greater than the number of days in the current month.
- Determining the last day of the month requires more code.
- Specifically, we must add the `mdays[]` array that lists days of each month, and also the `february()` function.
  - This function is necessary to ensure that the proper number of days in February is known for the current year.
- The `mdays[]` array is added to the code in the variable declaration part of the `main()` function:

```C
int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
```

- The `february()` function is also added to the code.
- After the `localtime()` function is called, the `february()` function is called to update the `mdays[]` array, element one:

```C
mdays[1] = february(date->tm_year + 1900);
```



`practice.c (main)`

```C
#include <stdio.h>
#include <time.h>

int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }  
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

int main(){
    const char *months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
	int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d;
    
    time(&now);
    date = localtime(&now);
    mdays[1] = february(date->tm_year + 1900);
    
    month = date->tm_mon;
    day = date->tm_mday;
    weekday = date->tm_wday;
    sunday = day - weekday;
    
    printf("  %s\n", months[month]);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    for(d = sunday; d < sunday + 7; d++){
        
        // If date d is out of range, less than 1, or greater than the number of days in the current month, outputs spaces
        if(d < 1 || d > mdays[month]){
            printf("   ");
        }else{
            // Output current day with brackets
            if(d == day){
                printf("[%02d]", d);
            }else{ // Outputs other days without brackets
                printf(" %2d ", d);
            }
        }
    }
    putchar('\n');
    return 0;
}
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
Sun Mon Tue Wed Thu Fri Sat
 24  25 [26] 27  28  29  30 
```

```C
// Manually setting the date to be close to the end of the month to test the code
month = date->tm_mon;
    day = 29;
    weekday = date->tm_wday;
    sunday = day - weekday;
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
Sun Mon Tue Wed Thu Fri Sat
 27  28 [29] 30  
```



To update the above program, `pmonth` is added, which holds the value of the previous month. 

- The `pmonth` calculation takes place after the current month's value is read and stored in variable `month`:

```C
pmonth = month - 1;
if(pmonth < 0){
    pmonth = 11;
}
```

- The previous month's value is the current month's value minus one.
- If it's January (0), the previous month's value is negative.
- The `if` test catches this condition, in which case the value of `pmonth` is set to 11, December.

```C
#include <stdio.h>
#include <time.h>

int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

int main(){
    const char *months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
	int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d, pmonth;
    
    time(&now);
    date = localtime(&now);
    
    mdays[1] = february(date->tm_year + 1900);
    
    month = date->tm_mon;
    pmonth = month - 1;
    if(pmonth < 0){
        pmonth = 11;
    }
    day = date->tm_mday;
    weekday = date->tm_wday;
    sunday = day - weekday;
    
    // When days from the previous month are calculated
    // If the calculated Sunday date is less than 1, it belongs to the previous month
    if(sunday < 1){
        // Shows the previous and current months
        // Example: "  October / November"
        printf("  %s / %s\n", months[pmonth], months[month]);
        
        // Else if the calculated Saturday date exceeds the number of days in the current month
    }else if(sunday + 6 > mdays[month]){ // Test to see whether days from the next month are output
        
        // For Dec, outputs December and January directly
        // Example: "  December / January"
        if(month == 11){
            printf("  %s / %s\n", months[month], months[0]);
        }else{
            
            // For other months, output the current, and next month names
            printf("  %s / %s\n", months[month], months[month + 1]);
        }
    }else{ // No previous or next month dates appear in the output
        // If the entire week falls within the current month, print only the current month
        // Example: "  November"
        printf("  %s\n", months[month]);
    }
    
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    for(d = sunday; d < sunday + 7; d++){
        
        // If the day is less than 1, it belongs to the previous month
        // The previous month still has days to output
        if(d < 1){
            
            // Print the corresponding day from the previous month
            // Example: " 30 " for day 30 of the previous month
            printf("%2d", mdays[pmonth] + d);
        }else if(d > mdays[month]){ // Else if the day exceeds the number of days in the current month, it belongs to the next month
            
            // Print the corresponding day from the next month
            // Example: " 1 " for day 1 of the next month
            //Output days from the next month using d minus the number of days in the current month
            printf(" %2d ", d - mdays[month]);
        }else{
            if(d == day){
                printf("[%2d]", d);
            }else{
                printf(" %2d ", d);
            }
        }
    }
    
    putchar('\n');
    return 0;
}
```



To update the program, we can also make it to output the current week number as well.

```C
weekno = (9 + day_of_the_year - weekday) / 7;
```

- The `day_of_the_year` value is kept in the `tm` structure as member `tm_yday`.
- The weekday value is `tm` structure member `tm_wday`, where Sunday is zero.
- The expression is divided by seven, which is rounded as an integer value and stored in variable `weekno`.
- The value of `weekno` must be tested for the first week of the year - specifically, when the first of January falls late in the week.
- The `weekno` value returned by the equation is 0. 
- It should be 52, as it's technically the last week of the previous year.

```C
if(weekno == 0){
    weekno = 52;
}
```



```C
#include <stdio.h>
#include <time.h>

int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

int main(){
    const char *months[] = {
		"January", "February", "March", "April",
		"May", "June", "July", "August",
		"September", "October", "November", "December"
	};
	int mdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    
    time_t now;
    struct tm *date;
    int day, weekday, month, sunday, d, pmonth, weekno;
    
    time(&now);
    date = localtime(&now);
    
    mdays[1] = february(date->tm_year + 1900);
    
    month = date->tm_mon;
    pmonth = month - 1;
    if(pmonth < 0){
        pmonth = 11;
    }
    day = date->tm_mday;
    weekday = date->tm_wday;
    sunday = day - weekday;
    
    // When days from the previous month are calculated
    // If the calculated Sunday date is less than 1, it belongs to the previous month
    if(sunday < 1){
        // Shows the previous and current months
        // Example: "  October / November"
        printf("  %s / %s\n", months[pmonth], months[month]);
        
        // Else if the calculated Saturday date exceeds the number of days in the current month
    }else if(sunday + 6 > mdays[month]){ // Test to see whether days from the next month are output
        
        // For Dec, outputs December and January directly
        // Example: "  December / January"
        if(month == 11){
            printf("  %s / %s\n", months[month], months[0]);
        }else{
            
            // For other months, output the current, and next month names
            printf("  %s / %s\n", months[month], months[month + 1]);
        }
    }else{ // No previous or next month dates appear in the output
        // If the entire week falls within the current month, print only the current month
        // Example: "  November"
        printf("  %s\n", months[month]);
    }
    
    // Calculate the current week number based on the day of the year and the current weekday
    // Example: If today is the 250th day of the year and it's a Wednesday (wday = 3),
    // weekno = (9 + 250 - 3) / 7 = 256 / 7 = 36
    weekno = (9 + date->tm_yday - weekday) / 7;
    
    // If the calculated week number is 0, it implies that the date belongs to the last week of the previous year
    // Thus, we adjust it to week 52
    // Example: For January 1st, weekno might be calculated as 0, so we set it to 52
    if(weekno == 0){
        weekno = 52;
    }
    printf(" - Week %d\n", weekno);
    
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    for(d = sunday; d < sunday + 7; d++){
        
        // If the day is less than 1, it belongs to the previous month
        // The previous month still has days to output
        if(d < 1){
            
            // Print the corresponding day from the previous month
            // Example: " 30 " for day 30 of the previous month
            printf("%2d", mdays[pmonth] + d);
        }else if(d > mdays[month]){ // Else if the day exceeds the number of days in the current month, it belongs to the next month
            
            // Print the corresponding day from the next month
            // Example: " 1 " for day 1 of the next month
            //Output days from the next month using d minus the number of days in the current month
            printf(" %2d ", d - mdays[month]);
        }else{
            
            // If the day falls within the current month
            if(d == day){
                printf("[%2d]", d);
            }else{
                printf(" %2d ", d);
            }
        }
    }
    
    putchar('\n');
    return 0;
}
```

- ```C
  // Calculate the current week number based on the day of the year and the current weekday
  // Example: If today is the 250th day of the year and it's a Wednesday (wday = 3),
  // weekno = (9 + 250 - 3) / 7 = 256 / 7 = 36
  weekno = (9 + date->tm_yday - weekday) / 7;
  ```

- **Purpose:**
  Determines the current week number of the year.

- **Breakdown:**

  - `date->tm_yday`: The day of the year (0-based, where January 1st is 0).

  - `weekday`: The current day of the week (0 = Sunday, 1 = Monday, ..., 6 = Saturday).

  - **Formula:**
    `(9 + tm_yday - wday) / 7`

  - **Example Calculation:**
    If `tm_yday = 249` (which is the 250th day) and `wday = 3` (Wednesday),

  - ```
    weekno = (9 + 249 - 3) / 7 = 255 / 7 ≈ 36
    ```

- ```C
  // If the calculated week number is 0, it implies that the date belongs to the last week of the previous year
  // Thus, we adjust it to week 52
  // Example: For January 1st, weekno might be calculated as 0, so we set it to 52
  if (weekno == 0)
  {
      weekno = 52;
  }
  ```

- **Purpose:**
  Ensures that week numbers are valid within the range `[1, 52]`. If the calculation results in `0`, it adjusts the week number to `52`, which typically represents the last week of the previous year.

- **Rationale:**
  Dates at the very beginning of the year might fall into the last week of the previous year based on how week numbers are calculated. This adjustment prevents displaying a week number of `0`.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
  November
 - Week 48
Sun Mon Tue Wed Thu Fri Sat
 24  25 [26] 27  28  29  30 

# when hardcoding the day to 30
chan@CMA:~/C_Programming/practice$ ./practice
  November / December
 - Week 48
Sun Mon Tue Wed Thu Fri Sat
 28  29 [30]  1   2   3   4 
 
```



```C
month = date->tm_mon;
    pmonth = month - 1;
    if (pmonth < 0)
    {
        pmonth = 11;
    }

// Manually set day to the first day of the month to test the code
    day = 1;
    weekday = date->tm_wday;
    sunday = day - weekday;
```

```shell
chan@CMA:~/C_Programming/practice$ ./practice
 October / November
 - Week 48
Sun Mon Tue Wed Thu Fri Sat
 30  31 [ 1]  2   3   4   5 

```



### Showing a month

```C
int main(){
    int mdays, today, first, day, d;
    
    mdays = 30; // Presets the number of days in the month (for November) 
    today = 26; // Sets today as the 26th
    first = 5; // The first day of the month is on Friday
    
    printf("November 2024\n");
    printf("Sun Mon Tue Wed Thu Fri Sat\n");
    
    // Starts with the day counter at 1, the first day of the month
    day = 1;
    
    // Loop thru the days of the month
    while(day <= mdays){
        
        // Loop thru a week, Sunday(0) thru Saturday(6)
        for(d = 0; d < 7; d++){
            
            // Check for the first week of the month
            if(d < first && day == 1){
                printf("    "); // Outputs 4 spaces blank and do not increment the day counter!
            }else{ // Outputs days, now that the first week/day has passed.
                if(day == today){
                    // highlight today
                    printf("[%2d]", day);
                }else{
                    // Regular day output
                    printf(" %2d ", day);
                }
                day++;
                
                // Exit the loop after the last day of the month
                if(day > mdays){
                    break;
                }
            }
        }
        putchar('\n');
    }
    
    return 0;
    
}
```



```shell
chan@CMA:~/C_Programming/practice$ ./practice
November 2024
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25 [26] 27  28  29  30 
 
chan@CMA:~/C_Programming/practice$ cal
   November 2024      
Su Mo Tu We Th Fr Sa  
                1  2  
 3  4  5  6  7  8  9  
10 11 12 13 14 15 16  
17 18 19 20 21 22 23  
24 25 26 27 28 29 30
```



#### Using the current date for the above program

```C
int thefirst(int wday, int mday)
{
    // Calculate the starting day of the week for the first date to display
    // Subtract the remainder of the current day divided by 7 from the current weekday
    // Then add 1 to align the days correctly
    int first = wday - (mday % 7) + 1;

    // If the calculated first day is negative, adjust it by adding 7 to wrap around the week
    if (first < 0)
    {
        first += 7;
    }

    // Return the adjusted first day of the week
    return first;
}

int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

int main()
{
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    time_t now;
    struct tm *date;
    int month, today, weekday, year, first, day, d;

    time(&now);
    date = localtime(&now);

    month = date->tm_mon;
    today = date->tm_mday;
    weekday = date->tm_wday;
    year = date->tm_year + 1900;
    mdays[1] = february(year);
    
    // set to the day of the week upon which the first of the month falls
    first = thefirst(weekday, today);
	
    
    // OUtput the current month and year (E.g. November 2024)
    printf("%s %d\n", months[month], year);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");

    day = 1;
    while (day <= mdays[month])
    {
        for (d = 0; d < 7; d++)
        {
            if (d < first && day == 1)
            {
                printf("    ");
            }
            else
            {
                if (day == today)
                {
                    printf("[%2d]", day);
                }
                else
                {
                    printf(" %2d ", day);
                }
                day++;
                if (day > mdays[month])
                {
                    break;
                }
            }
        }
        putchar('\n');
    }

    return 0;
}

```



**Exercise 13.3 & 13.4**

Update the code so that the function output the top heading centered within a certain width. Then modify the `main()` function so that any command-line arguments are parsed as a month-and-year value. Both values must be present and valid; otherwise, the current month is output.



`practice.h`

```C
int thefirst(int wday, int mday);

int february(int year);

void center(char *text, int width);
```

`functions.c`

```C
int thefirst(int wday, int mday)
{
    // Calculate the starting day of the week for the first date to display
    // Subtract the remainder of the current day divided by 7 from the current weekday
    // Then add 1 to align the days correctly
    int first = wday - (mday % 7) + 1;

    // If the calculated first day is negative, adjust it by adding 7 to wrap around the week
    if (first < 0)
    {
        first += 7;
    }

    // Return the adjusted first day of the week
    return first;
}

int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;

    length = strlen(text);
    if (length < width)
    {
        indent = (width - length) / 2;
        for (s = 0; s < indent; s++)
        {
            putchar(' ');
        }
        puts(text);
    }
    else
    {
        for (s = 0; s < width; s++)
        {
            putchar(*text++);
        }
        putchar('\n');
    }
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[])
{
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    time_t now;
    struct tm *date;
    int month, today, weekday, year, first, day, d;

    int a_month, a_year; /* arguments from the command line */
    const int output_width = 27;
    char title[output_width];

    time(&now);
    date = localtime(&now);

    if (argc == 3)
    {
        a_month = strtol(argv[1], NULL, 10);
        a_year = strtol(argv[2], NULL, 10);

        /* check month range */
        if (a_month > 0 && a_month < 13)
        {
            // Set the month in the 'date' structure (0-based indexing)
            date->tm_mon = a_month - 1;    // Jan is zero
            
            // Set the year in the 'date' structure (years since 1900)
            date->tm_year = a_year - 1900; // account for 1900
            date->tm_mday = 1;             // start on the first
            mktime(date);                  // update the date structure
        }
    }

    month = date->tm_mon;
    today = date->tm_mday;
    weekday = date->tm_wday;
    year = date->tm_year + 1900;
    mdays[1] = february(year);
    first = thefirst(weekday, today);

    sprintf(title, "%s %d\n", months[month], year);
    center(title, output_width);
    printf("Sun Mon Tue Wed Thu Fri Sat\n");

    day = 1;
    
    // Loop through each day of the month to display the calendar
    while (day <= mdays[month])
    {
        // Iterate over each day of the week (Sunday to Saturday)
        for (d = 0; d < 7; d++)
        {
            // If it's the first week and the current day hasn't started yet, print spaces
            if (d < first && day == 1)
            {
                printf("    "); // 4 spaces for alignment
            }
            else
            {
                if (day == today)
                {
                    printf("[%2d]", day);
                }
                else
                {
                    printf(" %2d ", day);
                }
                day++;
                if (day > mdays[month])
                {
                    break;
                }
            }
        }
        putchar('\n');
    }

    return 0;
}

```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
      November 2024

Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25 [26] 27  28  29  30 
chan@CMA:~/C_Programming/practice$ ./practice 11 2024
      November 2024

Sun Mon Tue Wed Thu Fri Sat
                    [ 1]  2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
chan@CMA:~/C_Programming/practice$ ./practice 12 2024
      December 2024

Sun Mon Tue Wed Thu Fri Sat
[ 1]  2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 

```



### Displaying a full year

The following listing shows the initialization portion of the `main()` function.

`practice.h`

```C
int february(int year);

void center(char *text, int width);
```



`functions.c`

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;

    length = strlen(text);
    if (length < width)
    {
        // Calculate the number of spaces needed on the left to center the text
        indent = (width - length) / 2;
        
        // Loop to print the indentation spaces
        for (s = 0; s < indent; s++)
        {
            putchar(' '); // Print a single space
        }
        puts(text);
    }
    else
    {
        // If the text length exceeds the desired width, truncate the text to fit the width
        for (s = 0; s < width; s++)
        {
            putchar(*text++); // Print each character and increment the pointer
        }
        putchar('\n');
    }
}
```



```C
int main(int argc, char *argv[])
{
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    struct tm date;
    int month, weekday, year, day, dow;
    const int output_width = 27;
    char title[output_width];
 
    // Initialize the date structure to January 1
    date.tm_year = 2000 - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;

    // Set the timezone to GMT (Greenwich Mean Time)
    putenv("TZ=GMT");
    tzset(); // Apply the timezone setting
    
    // Normalize the date structure and compute the time value
    // mktime modifies the struct tm based on the fields set above
    mktime(&date);

    weekday = date.tm_wday;
    year = date.tm_year + 1900;
    mdays[1] = february(year);

    // dow is updated manually as opposed in a loop because the first weekday of the month isn't the same for every month
    dow = 0; // The weekday loop variable, day-of-the-week (it counts weekdays)
    
    // The outer loop pages thru months of the year
    for (month = 0; month < 12; month++)
    {
        
        // Outputs the month & year, centered and the weekday header row
        sprintf(title, "%s %d", months[month], year);
        center(title, output_width);
        printf("Sun Mon Tue Wed Thu Fri Sat\n");
	
        // Initialize the day of the month, the 1st
        day = 1;
        
        // Loop thru days of the month
        while (day <= mdays[month])
        {
            
            // The first week is special; variable weekday holds the first weekday of the month. Outputs blanks before then.
            if (dow < weekday && day == 1)
            {
                printf("    ");
                
                // Increment the day of the week, Sunday (0) thru Saturday (6)
                dow++;
            }
            else
            {
                printf(" %2d ", day);
                dow++;
                
                // Check for the weekday overflow
                if (dow > 6)
                {
                    // Reset the day of the week back to Sunday (0)
                    dow = 0;
                    putchar('\n');
                }
                day++;
                if (day > mdays[month])
                {
                    break;
                }
            }
        }
        
        // Set the first day of the month for next month
        weekday = dow;
        
        // Reset the day of the week back to Sunday for the next month
        dow = 0;
        printf("\n\n");
    }

    return 0;
}

```

- Variable `dow` works with variable `weekday` to output the first week of January.
- Afterwards, variables `weekday` and `dow` are updated so that the following month's start day is properly set.

```shell
chan@CMA:~/C_Programming/practice$ ./practice
       January 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       February 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28 

        March 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

        April 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30 

         May 1999
Sun Mon Tue Wed Thu Fri Sat
                          1 
  2   3   4   5   6   7   8 
  9  10  11  12  13  14  15 
 16  17  18  19  20  21  22 
 23  24  25  26  27  28  29 
 30  31 

         June 1999
Sun Mon Tue Wed Thu Fri Sat
          1   2   3   4   5 
  6   7   8   9  10  11  12 
 13  14  15  16  17  18  19 
 20  21  22  23  24  25  26 
 27  28  29  30 

         July 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30  31 


        August 1999
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 

      September 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30 

       October 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       November 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30 

       December 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 

```



**Exercise 13.5**

Modify the code so that it accepts a command-lien argument for the year to output. When a command-line argument isn't available, the current year is output. 



**Solution**

`practice.h`

```C
int february(int year);

void center(char *text, int width);
```

`functions.c`

```C
int february(int year){
    if(year % 400 == 0){
        return 29;
    }
    if(year % 100 == 0){
        return 28;
    }
    if(year % 4 != 0){
        return 28;
    }
    return 29;
}

void center(char *text, int width){
    int s, length, indent;
    length = strlen(text);
    
    if(length < width){
        indent = (width - length) / 2;
        for(s = 0; s < indent; s++){
            putchar(' ');
        }
        puts(text);
    }else{
        for(s = 0; s < width; s++){
            putchar(*text++);
        }
        putchar('\n');
    }
}
```

`practice.c (main)`

```C
int main(int argc, char *argv[]){
    const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    time_t now;
    struct tm date = {0};
    int month, weekday, year, day, dow;
    const int output_width = 27;
    char title[output_width];
    
    if(argc < 2){ // No year provided
        time(&now);
        struct tm *today = localtime(&now);
        year = today->tm_year + 1900;
    }else{ // convert argv[1] to year
        year = strtol(argv[1], NULL, 10);
    }
    
    // Set January 1 of the given year
    date.tm_year = year - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1; // Allow mktime to determine dst
    
    putenv("TZ=GMT");
    tzset();
    
    // Normalize the date
    mktime(&date);
    weekday = date.tm_wday;
    
    mdays[1] = february(year);
    
    dow = 0;
    
    for(month = 0; month < 12; month++){
        sprintf(title, "%s %d", months[month], year);
        center(title, output_width);
        printf("Sun Mon Tue Wed Thu Fri Sat\n");
        
        day = 1;
        while(day <= mdays[month]){
            if(dow < weekday && day == 1){
                printf("    ");
                dow++;
            }else{
                printf(" %2d ", day);
                dow++;
                if(dow > 6){
                    dow = 0;
                    putchar('\n');
                }
                day++;
            }
        }
        weekday = dow;
        dow = 0;
        printf("\n\n");
    }
    return 0;
}
```

- **`mktime` requires a fully initialized `struct tm`:** The `mktime` function depends on all fields in the `struct tm` being set correctly. If we don't initialize fields like `tm_isdst`, unexpected results can occur.

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
       January 2024
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

       February 2024
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29 

        March 2024
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

        April 2024
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30 

         May 2024
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 

         June 2024
Sun Mon Tue Wed Thu Fri Sat
                          1 
  2   3   4   5   6   7   8 
  9  10  11  12  13  14  15 
 16  17  18  19  20  21  22 
 23  24  25  26  27  28  29 
 30 

         July 2024
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

        August 2024
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30  31 


      September 2024
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30 

       October 2024
Sun Mon Tue Wed Thu Fri Sat
          1   2   3   4   5 
  6   7   8   9  10  11  12 
 13  14  15  16  17  18  19 
 20  21  22  23  24  25  26 
 27  28  29  30  31 

       November 2024
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 


       December 2024
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 
 
 chan@CMA:~/C_Programming/practice$ ./practice 1999
       January 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       February 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28 

        March 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30  31 

        April 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30 

         May 1999
Sun Mon Tue Wed Thu Fri Sat
                          1 
  2   3   4   5   6   7   8 
  9  10  11  12  13  14  15 
 16  17  18  19  20  21  22 
 23  24  25  26  27  28  29 
 30  31 

         June 1999
Sun Mon Tue Wed Thu Fri Sat
          1   2   3   4   5 
  6   7   8   9  10  11  12 
 13  14  15  16  17  18  19 
 20  21  22  23  24  25  26 
 27  28  29  30 

         July 1999
Sun Mon Tue Wed Thu Fri Sat
                  1   2   3 
  4   5   6   7   8   9  10 
 11  12  13  14  15  16  17 
 18  19  20  21  22  23  24 
 25  26  27  28  29  30  31 


        August 1999
Sun Mon Tue Wed Thu Fri Sat
  1   2   3   4   5   6   7 
  8   9  10  11  12  13  14 
 15  16  17  18  19  20  21 
 22  23  24  25  26  27  28 
 29  30  31 

      September 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30 

       October 1999
Sun Mon Tue Wed Thu Fri Sat
                      1   2 
  3   4   5   6   7   8   9 
 10  11  12  13  14  15  16 
 17  18  19  20  21  22  23 
 24  25  26  27  28  29  30 
 31 

       November 1999
Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6 
  7   8   9  10  11  12  13 
 14  15  16  17  18  19  20 
 21  22  23  24  25  26  27 
 28  29  30 

       December 1999
Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4 
  5   6   7   8   9  10  11 
 12  13  14  15  16  17  18 
 19  20  21  22  23  24  25 
 26  27  28  29  30  31 

```



### Putting the full year into a grid

- The required update is to the `center()` function.
- The function centers the month and year within a given width but doesn't pad out the rest of the row of text.
- To line up the months in a grid, the header row one must be output at a consistent size.
- The next listing shows the required updates to the `center()` function for row-by-row output.
- The `width` argument centers the text and sets the number of spaces to pad on both sides.

```C
void center(char *text, int width){
    int s, length, indent;
    
    length = strlen(text);
    
    if(length < width){
        indent = (width - length) / 2;
        for(s = 0; s < indent; s++){
            puthcar('\n');
        }
        
        // instead of a puts() function, outputs the string one character at a time
        while(*text){
            putchar(*text);
            text++;
            s++; // tracks s to determine the final output width
        }
        // Output spaces to match the width value
        for(; s < width; s++){
            putchar(' ');
        }
    }else{
        for(s = 0; s < width; s++){
            putchar(*text++);
        }
    }
}
```



#### Full Program to output a full year in a grid

`practice.h`

```C
enum
{
    COLUMNS = 3
};

int february(int year);

void center(char *text, int width);
```

`functions.c`

```C
int february(int year)
{
    if (year % 400 == 0)
    {
        return 29;
    }
    if (year % 100 == 0)
    {
        return 28;
    }
    if (year % 4 != 0)
    {
        return 28;
    }

    return 29;
}

void center(char *text, int width)
{
    int s, length, indent;
    length = strlen(text);

    if (length < width)
    {
        indent = (width - length) / 2;
        for (s = 0; s < indent; s++)
        {
            putchar(' ');
        }
        
        // instead of a puts() function, outputs the string one character at a time
        while (*text)
        {
            putchar(*text);
            text++;
            s++;
        }
        
        // Output spaces to match the width value
        for (; s < width; s++)
        {
            putchar(' ');
        }
    }
    else
    {
        for (s = 0; s < width; s++)
        {
            putchar(*text++);
        }
    }
}
```

`practice.c (main)`

- `int dotm[12]`:  The `dotm[]` (day of the month) array holds the starting day for each month in the year.
  - Its values are the same as the `weekday` variable, 0 through 6.
  - The `weekday` variable already holds the day of the week for January 1.
  - It's stored in element 0 of the `dotm[]` array.

```C
int main(int argc, char *argv[]){
     const char *months[] = {
        "January", "February", "March", "April",
        "May", "June", "July", "August",
        "September", "October", "November", "December"};

    // Array with the number of days in each month
    int mdays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int dotm[12]; // Array to hold the starting day for each month in the year
    int month, weekday, year, day, dow, c, week;
    char int output_width = 27;
    char title[output_width];
    
    // Check if a year is provided as a command-line arg
    if(argc < 2){ // If no argument is provided,use the current year
        time(&now); // Get the current time
        struct tm *today = localtime(&now); // Convert to local time
        year = today->tm_year + 1900; // Extract the year
    }else // If a year is provided
    {
        year = strtol(argv[1], NULL, 10); // Convert argument to an integer year
    }

    // Initialize the date structure for January 1st of the given year
    date.tm_year = year - 1900;
    date.tm_mon = 0;
    date.tm_mday = 1;
    date.tm_hour = 0;
    date.tm_min = 0;
    date.tm_sec = 0;
    date.tm_isdst = -1; // Let `mktime` determine daylight savings time
    putenv("TZ=GMT"); // Set time zone to GMT
    tzset(); // Apply time zone settings
    mktime(&date); // Normalize the date

    weekday = date.tm_wday; // Get the day of the week for January 1
    mdays[1] = february(year); // Adjust February days for leap years
    dotm[0] = weekday; // First day of the year

    // Calculate the first day of each month
    for (month = 1; month < 12; month++)
    {
        dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
    }

    // Loop through the months in sets of `COLUMNS` (3 months per row)
    for (month = 0; month < 12; month += COLUMNS)
    {
        // Print the titles for each month in the row
        for (c = 0; c < COLUMNS; c++)
        {
            sprintf(title, "%s %d", months[month + c], year); // Format the title
            center(title, output_width); // Center the title
            printf("   "); // Spacing between columns
        }
        putchar('\n'); // New line after titles

        // Print the weekday headers for each month
        for (c = 0; c < COLUMNS; c++)
        {
            printf("Sun Mon Tue Wed Thu Fri Sat    "); // Weekday names
        }
        putchar('\n'); // New line after headers

        // Print the first week of each month
        for (c = 0; c < COLUMNS; c++)
        {
            day = 1;
            for (dow = 0; dow < 7; dow++) // Loop through the days of the week
            {
                
                // If the first of the month weekday hasn't happened, outputs spaces
                if (dow < dotm[month + c]) // Print spaces for days before the 1st
                {
                    printf("    ");
                }
                else // Print the days starting from the 1st
                {
                    printf(" %2d ", day++);
                }
            }
            printf("  ");
            dotm[month + c] = day; // Update the first day of the next week
        }
        putchar('\n'); // New line after the first week

        // Print the remaining weeks
        for (week = 1; week < 6; week++) // Up to 6 weeks per month
        {
            for (c = 0; c < COLUMNS; c++) // Loop through each column (month)
            {
                day = dotm[month + c]; // Start with the current day
                for (dow = 0; dow < 7; dow++) // Loop through the days of the week
                {
                    if (day <= mdays[month + c]) // Print the day if within range
                    {
                        printf(" %2d ", day);
                    }
                    else // Print spaces if out of range
                    {
                        printf("    ");
                    }
                    day++; // Move to the next day
                }
                printf("  ");
                dotm[month + c] = day; // Update the first day of the next week
            }
            putchar('\n'); // New line after each week
        }
        putchar('\n'); // New line between rows of months
    }

    return (0); // Successful execution
}

}
```

- ```C
  dotm[0] = weekday;
  
  for(month = 1; month < 12; month++){
      dotm[month] = (mdays[month - 1] + dotm[month - 1]) % 7;
  }
  ```

- The statement in the `for` loop totals the values of the number of days in the previous month, `mdays[month - 1]`, with the starting day of the week for the previous month, `dotm[month - 1]`.

- The total is modulo 7, which yields the starting day of the week for the month represented by variable `month`.

  - **`% 7`:** The modulus operation ensures that the result wraps around to stay within the range of valid days of the week (0–6).

- When the loop is complete, the `dotm[]` array holds the starting weekday for the first of each month in a given year.

- Assume the year is 2024 (a leap year) and January 1 is a Monday (`weekday = 1`). The `mdays` array contains the number of days in each month:

```C
mdays = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

```

- **January (`dotm[0]`):** Starts on Monday (`dotm[0] = 1`).
- February (`dotm[1]`):
  - Days in January: 31 (`mdays[0]`).
  - Starting day of February: `(31 + 1) % 7 = 32 % 7 = 4` (Thursday).
  - `dotm[1] = 4`.
- March (`dotm[2]`):
  - Days in February: 29 (`mdays[1]`).
  - Starting day of March: `(29 + 4) % 7 = 33 % 7 = 5` (Friday).
  - `dotm[2] = 5`.
- April (`dotm[3]`):
  - Days in March: 31 (`mdays[2]`).
  - Starting day of April: `(31 + 5) % 7 = 36 % 7 = 1` (Monday).
  - `dotm[3] = 1`.

This process continues for all months, correctly calculating the starting day of the week for each one.

`Output`

![Screenshot from 2024-11-27 22-36-58](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-27 22-36-58.png)



### A calendar in color

- An ANSI escape sequence is a series of characters, the first of which is the escape character, ASCII 27, hex 1B.
- This character must be output directly.

```C
#define RESET "\x1b[0m"
#define BOLD "\x1b[1m"
#define FAINT "\x1b[2m"
#define UNDERLINE "\x1b[4m"
#define BLINK "\x1b[5m"
#define INVERSE "\x1b[7m"

int main(int argc, char *argv[])
{
    printf("%sBold text%s\n", BOLD, RESET);
    printf("%sFaint text%s\n", FAINT, RESET);
    printf("%sUnderlined text%s\n", UNDERLINE, RESET);
    printf("%sBlinking text%s\n", BLINK, RESET);
    printf("%sInverted text%s\n", INVERSE, RESET);
    return (0);
}
```

`Output`

```shell
chan@CMA:~/C_Programming/practice$ ./practice
Bold text
Faint text
Underlined text
Blinking text
Inverted text
```

![Screenshot from 2024-11-27 22-45-53](/home/chan/Pictures/Screenshots/Screenshot from 2024-11-27 22-45-53.png)



```C
```

`Output`

```shell
```

