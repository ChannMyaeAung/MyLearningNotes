# Tiny C Projects

- I have decided to put all the contents and projects from the book called "Tiny C Projects" written by Dan Gookin to later review and revise what I have learnt from the book as well as related information or improvements from external sources.
- We are going to be building upon the program's idea, often presenting a simple version and then expanding the program to offer more features.
- Sometimes other programs are introduced along the way, each of which follows the main theme or otherwise assists the primary program in its goal.

---

## 1. Daily greetings

### Instructions

- Write a simple greetings program.
- Modify your grettings program to add the time of day.
- Update the timestamp with the current moon phase.
- Enhance your grettings message with a `bon mot`.

### Solution 

#### Things to Keep in mind

- The C library is rife with time functions, all defined in the `time.h` header file.
- The `time_t` data type is also defined in the header.
- This positive integer value (long data type, `printf()` placeholder `%ld`) stores the Unix epoch, the number of seconds ticking away since midnight January 1, 1970.
- The Unix epoch is a great value to use in our grettings program.
- However, the `time_t` value must be manipulated into something a bit more useful.
- Be aware that many time functions, such as `time()` and `ctime()` used in the code for our program solution require the address of the `time_t` variable. 
- Yup, they are pointers.

```C
int main(){
    time_t now;
    
    // The time() function requires the time_t variable's address, prefixed here with the & address-of operator.
    time(&now);
    printf("The computer think it's %ld\n", now);
    
    // The ctime() function requires a pointer argument and returns a string appended with a newline.
    printf("%s", ctime(&now));
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
The computer thinks it's 1726504705
Tue Sep 17 00:38:25 2024
```

- The output shows the number of seconds tick-tocking since 1970.
- This same value is swallowed by the `ctime()` function to output a formatted time string.
- This result may be acceptable, but time data can be customized further.
- The key to unlocking specific time details is found in the `localtime()` function, as the following code here demonstrates.

```C
int main()
{
    time_t now;
    
    // because localtime() returns a pointer, it's best to declare the structure as a pointer
    struct tm *clock;
    time(&now);

    clock = localtime(&now);
    puts("Time details: ");
    printf("Day of the year: %d\n", clock->tm_year);
    
    // The first day of the week is 0 for Sunday
    printf("Day of the week: %d\n", clock->tm_wday);
    
    // We must add 1900 to the tm_year member to get the current year
    printf("Year %d\n", clock->tm_year + 1900);
    
    // The tm_mon member ranges from 0 to 11
    printf("Month: %d\n", clock->tm_mon + 1);
    printf("Day of the month: %d\n", clock->tm_mday);
    printf("Hour: %d\n", clock->tm_hour);
    printf("Minutes: %d\n", clock->tm_min);
    printf("Seconds: %d\n", clock->tm_sec);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Time details: 
Day of the year: 124
Day of the week: 2
Year 2024
Month: 9
Day of the month: 17
Hour: 0
Minutes: 46
Seconds: 7
```

- Based on the output, we can conclude that my machine at the time of practicing this is:
  - It's 124 day of the year 2024. 
  - It's Tuesday (as Day of the week is 2)
  - The month is September (Month: 9)
  - Hour, Minutes, Seconds (12:46:07 AM)
  - **Conclusion:** It is written at 12 AM midnight, on September 17th 2024, Tuesday.



**The code fetches the current hour of the day and outputs an appropriate time-of-day greeting**

```C
int main(int argc, char *argv[]){
    time_t now;
    struct tm *clock;
    int hour;
    
    time(&now);
    clock = localtime(&now);
    
    // This statement is a convenience to avoid using clock->tm_hour over and over
    hour = clock->tm_hour;
    
    printf("Good ");
    if(hour < 12){
        printf("morning");
    }else if(hour > 12){
        printf("afternoon");
    }else{
        printf("evening");
    }
    
    if(argc > 1){
        printf(", %s", argv[1]);
    }
    
    putchar('\n');
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Good morning
chan@CMA:~/C_Programming/test$ ./final Chan
Good morning, Chan
```



#### Adding specific time info

- A simple way to output a detailed time string is to output a greeting followed by a time string generated by the `ctime()` function.

```C
printf("Good day, %s\n", argv[1]);
printf("It's %s", ctime(&now));
```

- Still the program is lazy. Better to incorporate the `strftime()` function, which formats a timestamp string according to our specifications.
- The `strftime()` function works like `printf()`, with a special string that formats time information.
- The function's output is saved in a buffer, which our code can use later.

```C
int main(int argc, char *argv[]){
    time_t now;
    struct tm *clock;
    
    // Storage for the string filled by the strftime() function
    char time_string[64];
    
    time(&now);
    
    // We must fill a localtime() tm structure to make the strftime() function work
    clock = localtime(&now);
    
    strftime(time_string, 64, "Today is %A, %B %d, %Y%nIt is %r%n", clock);
    
    printf("Greetings");
    if(argc > 1){
        printf(", %s", argv[1]);
    }
    
    printf("!\n%s", time_string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final Chan
Greetings, Chan!
Today is Tuesday, September 17, 2024
It is 02:15:40 AM
chan@CMA:~/C_Programming/test$ ./final
Greetings!
Today is Tuesday, September 17, 2024
It is 02:15:44 AM
```

- `man strftime` in terminal to discover all the fun placeholders and what they do.
- Like the `printf()` function, the placeholders are prefixed by a % character.
- Any other text in the formatting string is output as is.
- `%A` - Full name for the current day of the week.
- `%B` - Full name for the current month.
- `%d` - Day of the month, 01 to 31.
- `%Y` - 4-digit year
- `%n` - Newline
- `%r` - Time with AM/PM
- The output reflects the time string generated and stored in the `time_string[]` buffer.
- The time string appears after the general greeting.



#### Writing the moon phase algorithm

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-09-19 01-33-14.png)

- Regardless of the time, the moon has a current phase.
- To determine the moon phase without looking outside or in a reference, we use an algorithm.
- The degree of accuracy of the algorithm depends on a lot of things such as our location.

```C
int moon_phase(int year, int month, int day)
{
    int d, g, e;

    d = day;
    if (month == 2)
    {
        d += 31;
    }
    else if (month > 2)
    {
        d += 59 + (month - 3) * 30.6 + 0.5;
    }

    g = (year - 1900) % 19;
    e = (11 * g + 29) % 30;

    if (e == 25 || e == 24)
    {
        ++e;
    }

    return ((((e + d) * 6 + 5) % 177) / 22 & 7);
}
```

##### Function Definition

```C
int moon_phase(int year, int month, int day)
```

- **Purpose**: This function calculates the moon phase for a given date.
- Parameters:
  - `year`: The year of the date.
  - `month`: The month of the date.
  - `day`: The day of the date.
- **Return Value**: An integer representing the moon phase.

##### Variable Declarations

int d, g, e;

- **d**: This variable will hold the day of the year.
- **g**: This variable will hold the golden number of the year in the Metonic cycle.
- **e**: This variable will hold an intermediate calculation used to determine the moon phase.

### Calculate Day of the Year

```C
d = day;
if (month == 2)
{
    d += 31;
}
else if (month > 2)
{
    d += 59 + (month - 3) * 30.6 + 0.5;
}
```

- **d = day**: Initialize `d` with the day of the month.
- **if (month == 2)**: If the month is February, add 31 to `d` to account for the days in January.
- **else if (month > 2):** If the month is after February:
  - **d += 59 + (month - 3) \* 30.6 + 0.5**: Add 59 to `d` to account for the days in January and February. Then, add the number of days in the months from March to the given month. The expression `(month - 3) * 30.6 + 0.5` approximates the number of days in these months.

##### Calculate Golden Number and Epact

```C
g = (year - 1900) % 19;
e = (11 * g + 29) % 30;
```

- **g = (year - 1900) % 19**: Calculate the golden number of the year in the Metonic cycle. The Metonic cycle is a period of 19 years after which the phases of the moon repeat on the same days of the year.
- **e = (11 \* g + 29) % 30**: Calculate the epact, which is the age of the moon in days on January 1st of the given year.

##### Adjust Epact for Special Cases

```C
if (e == 25 || e == 24)
{
    ++e;
}
```

- **if (e == 25 || e == 24)**: If the epact is 24 or 25, increment it by 1. This adjustment is made to correct the epact for certain years.

##### Calculate Moon Phase

```C
return ((((e + d) * 6 + 5) % 177) / 22 & 7);
```

- **(e + d)**: Add the epact to the day of the year.
- **(e + d) \* 6 + 5**: Multiply the sum by 6 and add 5. This scales the value to fit within a certain range.
- **((e + d) \* 6 + 5) % 177**: Take the result modulo 177 to wrap the value within a specific range.
- **(((e + d) \* 6 + 5) % 177) / 22**: Divide the result by 22 to get a value between 0 and 7.
- **(((e + d) \* 6 + 5) % 177) / 22 & 7**: Use bitwise AND with 7 to ensure the result is within the range 0 to 7, representing the moon phase.

##### Summary

- **0**: New Moon
- **1**: Waxing Crescent
- **2**: First Quarter
- **3**: Waxing Gibbous
- **4**: Full Moon
- **5**: Waning Gibbous
- **6**: Last Quarter
- **7**: Waning Crescent

This function uses a combination of calendar calculations and lunar cycle approximations to determine the moon phase for a given date.



#### Adding the moon phase to our greeting program

- We need to fetch time-based data, which the `moon_phase()` function requires to make its calculation.
- We also need an array of strings to output the current moon phase text based on the value the function returns.

```C
int mp;
```

- Variable `mp` to hold the value returned from the `moon_phase()` function.

`hello.h`

```C
int moon_phase(int year, int month, int day);
```

`hello.c`

```C
int moon_phase(int year, int month, int day)
{
    int d, g, e;

    d = day;
    if (month == 2)
    {
        d += 31;
    }
    else if (month > 2)
    {
        d += 59 + (month - 3) * 30.6 + 0.5;
    }

    g = (year - 1900) % 19;
    e = (11 * g + 29) % 30;

    if (e == 25 || e == 24)
    {
        ++e;
    }

    return ((((e + d) * 6 + 5) % 177) / 22 & 7);
}
```



`main.c`

```C

char *phase[8] = {
    "waxing crescent", "at first quarter", "waxing gibbous", "full", "waning gibbous", "at last quarter", "waning crescent", "new"};

int main(int argc, char *argv[])
{
    time_t now;
    struct tm *clock;
    int mp;

    char time_string[64];

    time(&now);
    clock = localtime(&now);

    mp = moon_phase(clock->tm_year + 1900, clock->tm_mon, clock->tm_mday);

    strftime(time_string, 64, "Today is %A, %B %d, %Y%nIt is %r%n", clock);

    printf("Greetings");
    if (argc > 1)
    {
        printf(", %s", argv[1]);
    }

    printf("!\n%s", time_string);
    
    printf("The moon is %s\n", phase[mp]);
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
Greetings!
Today is Thursday, September 19, 2024
It is 01:56:15 AM
The moon is waning gibbous
```



#### Randomly reading a pithy phrase

`pitchy.txt`

```
Politics exists so that uncoordinated people can play sports.
Water alone doesn't get you clean. You must use soap. That's because dirt and crud loves soap and sticks to it really well. The water then washes away the soap, along with the dirt, and the result is that you are clean.
You buy popcorn, soda, and candy so that you have something to eat before the movie starts.
Just wait until Starbucks figures out that you can snort coffee.
Nothing instills more doubt in the curious than the sign "Wet Paint."
You might dislike texting, but it certainly does get annoying people to shut up.
You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"
The middle of nowhere is equidistant from everywhere else.
Marketing wizards are looking for the human equivalent of what a dog feels at the sound of a can opener.
Having a pet ensures that you don't freak out over every noise in the house. Loud bang? It's the cat. So what if the cat is in the room with me. It's the cat.
The true experience at an amusement park is waiting in lines.
There is no logic in the computer industry.
The car's manual calls it the "check engine" lamp, but I call it the "This is going to cost at least $200" light.
You drive on a parkway and park on a driveway.
Do I take a break from work to play a video game, or take a break from a video game to get work done?
```

- In C, `feof` is a function that checks whether the end-of-file indicator associated with a given file stream is set. It is defined in the `<stdio.h>` header file.
- The `feof` function returns a non-zero value (true) if the end-of-file indicator is set for the specified stream.
- It returns zero (false) otherwise.
- The `feof` function is typically used in a loop to determine when the end of a file has been reached while reading from the file. 
- However, it is important to note that `feof` only returns true after an attempt to read past the end of the file has been made. Therefore, it is often used in conjunction with other file reading functions like `fgets`, `fscanf`, or `fread`.

```C
int main()
{
    const char filename[] = "pithy.txt";
    FILE *fp;

    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }

    // Loop as long as the file isn't empty
    while (!feof(fp))
    {
        // The variable r ensures that fgets() doesn't mess up and read beyond the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);

        if (r == NULL)
        {
            break;
        }

        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);

        if (entry == NULL)
        {
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }

        strcpy(entry, buffer);
        printf("%d: %s\n", items, entry);
        items++;
        // Outputs all the lines in the file
    }

    fclose(fp);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
0: Politics exists so that uncoordinated people can play sports.

1: Water alone doesn't get you clean. You must use soap. That's because dirt and crud loves soap and sticks to it really well. The water then washes away the soap, along with the dirt, and the result is that you are clean.

2: You buy popcorn, soda, and candy so that you have something to eat before the movie starts.

3: Just wait until Starbucks figures out that you can snort coffee.

4: Nothing instills more doubt in the curious than the sign "Wet Paint."

5: You might dislike texting, but it certainly does get annoying people to shut up.

6: You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"

7: The middle of nowhere is equidistant from everywhere else.

8: Marketing wizards are looking for the human equivalent of what a dog feels at the sound of a can opener.

9: Having a pet ensures that you don't freak out over every noise in the house. Loud bang? It's the cat. So what if the cat is in the room with me. It's the cat.

10: The true experience at an amusement park is waiting in lines.

11: There is no logic in the computer industry.

12: The car's manual calls it the "check engine" lamp, but I call it the "This is going to cost at least $200" light.

13: You drive on a parkway and park on a driveway.

14: Do I take a break from work to play a video game, or take a break from a video game to get work done?

```



- As the program sits now, it allocates a series of buffers to store the strings read.
- Yet the addresses for these buffers are lost in memory.
- To resolve this issue, a pointer-pointer is required.
- The pointer-pointer, or address of a pointer, keeps track of all the string's memory locations.

```C
#define BSIZE 256

int main(){
    const char filename[] = "pithy.txt";
    FILE *fp;
    
    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;
    int saying;
    char **list_base;
    
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }
    
    list_base = (char **)malloc(sizeof(char *) * 100);
    
    if(list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Loop as long as the file isn't empty
    while(!feof(fp)){
        // The variable r ensures that fgets() doesn't mess up and read beyong the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);
        
        if(r == NULL){
            break;
        }
        
        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);
        
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        // Copy the string from the buffer into the newly allocated memory pointed to by entry
        strcpy(entry, buffer);
        
        // Stores the pointer entry in the array list_base at the position indicated by items.
        // same as list_base[items] = entry;
        *(list_base + items) = entry;
        item++;
        
        // Every time items is exactly divisible by 100
        // means the file read contains more than 100 lines of text, reallocate memory to prevent memory overflow
        if(items % 100 == 0){
            // Existing storage is increased by 100 pointer-size chunks.
            lisst_base = (char **)realloc(list_base, sizeof(char *) * (items + 100));
            if(list_base == NULL){
                fprintf(stderr, "Unable to reallocate memory\n");
                exit(1);
            }
        }
    }
    
    fclose(fp);
    
    // Output a random line of text
    srand((unsigned)time(NULL));
    saying = rand() % (items - 1);
    printf("%s", *(list_base + saying));
}
```

1. **Line 67: `*(list_base + items) = entry;`**
   - **Purpose**: This line stores the pointer `entry` in the array `list_base` at the position indicated by `items`.
   - **Details:**
     - `list_base` is a pointer to an array of character pointers (`char **`), which is used to store the lines read from the file.
     - `items` is an integer that keeps track of the number of lines read so far.
     - `*(list_base + items)` is equivalent to `list_base[items]`, which accesses the `items`-th element of the array.
     - This line effectively stores the pointer to the copied string in the `items`-th position of `list_base`.
2. **Line 68: `items++;`**
   - **Purpose**: This line increments the `items` counter by 1.
   - **Details:**
     - After storing the pointer to the copied string in `list_base`, the `items` counter is incremented to reflect that another line has been read and stored.
     - This ensures that the next line read from the file will be stored in the next position in the `list_base` array.

Summary

- **Line 66** copies the content of the `buffer` into the newly allocated memory pointed to by `entry`.
- **Line 67** stores the pointer to the copied string in the `list_base` array at the position indicated by `items`.
- **Line 68** increments the `items` counter to keep track of the number of lines read and stored.

#### Purpose of `strcpy(entry, buffer)`

- **Function**: Copies the string from `buffer` to the memory location pointed to by `entry`.
- **Reason**: `entry` is a newly allocated memory block that will hold the string read from the file.

#### Purpose of `*(list_base + items) = entry`

- **Function**: Stores the pointer `entry` in the array `list_base` at the position indicated by `items`.
- **Reason**: `list_base` is an array of pointers (`char **`) that keeps track of all the lines read from the file. By storing `entry` in `list_base`, you are effectively saving the location of the copied string so that you can access it later.

#### Why Both are Needed

1. **Copying the String**: `strcpy(entry, buffer)` ensures that the content of the buffer is copied to a new memory location (`entry`). This is necessary because `buffer` will be reused in the next iteration of the loop to read the next line from the file.
2. **Storing the Pointer**: `*(list_base + items) = entry` (or equivalently `list_base[items] = entry`) stores the pointer to the newly copied string in the `list_base` array. This allows you to keep track of all the lines read from the file. Without this step, you would lose the reference to the copied string, and it would be impossible to access it later.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Nothing instills more doubt in the curious than the sign "Wet Paint."

chan@CMA:~/C_Programming/practice$ ./practice
You might dislike texting, but it certainly does get annoying people to shut up.

chan@CMA:~/C_Programming/practice$ ./practice
You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"
```

### Important Note regarding the pithy program

- The program doesn't release any memory directly. 
- Normally, the end of a function would be dotted with `free()` statements, one for each memory chunk allocated.
- Because the entire code dwells within the `main()` function, freeing memory isn't necessary.
- The memory allocated is freed when the program quits.
- Had the allocation taken place in a function, however, it's necessary to release the allocation or risk losing the memory chunk and potentially causing a memory overflow.
- However, we should always explicitly free the memory allocated in our program even if it is in the `main` function.
- While the operating system will reclaim the memory when the program exits, it is good practice to free all dynamically allocated memory to avoid memory leaks and to ensure that your program is well-behaved, especially in more complex applications where memory management is critical.

```C
#define BSIZE 256

int main()
{
    const char filename[] = "pithy.txt";
    FILE *fp;

    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;
    int saying;
    char **list_base;

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }

    list_base = (char **)malloc(sizeof(char *) * 100);

    if (list_base == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    // Loop as long as the file isn't empty
    while (!feof(fp))
    {
        // The variable r ensures that fgets() doesn't mess up and read beyond the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);

        if (r == NULL)
        {
            break;
        }

        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);

        if (entry == NULL)
        {
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }

        // Copy the string from the buffer into the newly allocated memory pointed to by entry
        strcpy(entry, buffer);

        // Stores the pointer entry in the array list_base at the position indicated by items.
        *(list_base + items) = entry;
        items++;

        // Every time items is exactly divisible by 100
        // means the file read contains more than 100 lines of text, reallocate memory to prevent memory overflow
        if (items % 100 == 0)
        {
            // Existing storage is increased by 100 pointer-size chunks.
            list_base = (char **)realloc(list_base, sizeof(char *) * (items + 100));

            if (list_base == NULL)
            {
                fprintf(stderr, "Unable to reallocate memory\n");
                exit(1);
            }
        }
    }
    fclose(fp);

    // Outputs a random line of text
    srand((unsigned)time(NULL));
    saying = rand() % (items - 1);
    printf("%s", *(list_base + saying));

    // Free the allocated memory
    for (int i = 0; i < items; i++)
    {
        free(list_base[i]);
    }

    free(list_base);
    return 0;
}
```



### Similar Small Program

```C
int main(){
    char *buffer = "Hello, World!";
    char *entry = (char*)malloc(strlen(buffer) + 1);
    // Outline: For each string in buffers, memory is allocated, the string is copied, and the pointer is stored in list_base.
    strcpy(entry, buffer);
    
    
    // Now entry points to a memory location containing "Hello, World!"
    // But we need to store this pointer somewhere to access it later
    char **list_base = (char**)malloc(10 * sizeof(char *));
    int items = 0;
    
    list_base[items] = entry; // Store the pointer in the array
    
    items++;
    
    printf("%s", list_base[0]); // Prints "Hello, World!"
    printf("%s", list_base[items]); // Prints (null)
    
    // Free allocated memory
    // We don't need a loop to free the memory like the pithy program because we are only allocating and storing a single string.
    free(entry);
    free(list_base);
    return 0;
}
```

##### Explanation

1. **Initialization**:
   - `buffer` is initialized to `"Hello, World!"`.
   - `entry` is allocated enough memory to hold the string in `buffer` plus the null terminator.
   - `strcpy(entry, buffer)` copies the string from `buffer` to `entry`.
2. **Array Allocation**:
   - `list_base` is allocated memory for 10 pointers to `char`.
   - `items` is initialized to 0.
3. **Storing the Pointer**:
   - `list_base[items] = entry;` stores the pointer `entry` in `list_base[0]`.
   - `items` is incremented to 1.
4. **Printing**:
   - `printf("%s", list_base[0]);` prints the string pointed to by `list_base[0]`, which is `"Hello, World!"`.
   - `printf("%s", list_base[items]);` prints the string pointed to by `list_base[1]`, which is `NULL` because `list_base[1]` has not been initialized.

##### Why `list_base[items]` is `NULL`

- After `items` is incremented to 1, `list_base[1]` is not assigned any value. Therefore, it contains `NULL` or an undefined value.
- When you try to print `list_base[1]`, it prints `(null)` because it points to `NULL`.

##### Important Notes

If we have multiple strings like we did in the pithy program, the `list_base[items] = entry;` would be like this:

let's say our entry will have the following strings:

"Hello, World!", "John Doe", the last item is "Prince Ali"

`n` here means the last element of entry.

| list_base[0] (items = 0) | list_base[1] (items = 1) | list_base[n] (items  = n) |
| ------------------------ | ------------------------ | ------------------------- |
| memory chunk [0]         | memory chunk [1]         | memory chunk [n]          |
| "Hello, World!"          | "John Doe"               | "Prince Ali"              |
|                          |                          |                           |



###### Memory Layout

| Index (`items`) | `list_base` Pointer              | Memory Chunk Content |
| --------------- | -------------------------------- | -------------------- |
| 0               | `list_base[0]`                   | "Hello, World!"      |
| 1               | `list_base[1]`                   | "John Doe"           |
| 2               | `list_base[2]` or `list_base[n]` | "Prince Ali"         |



---

## 2. NATO output

```C
const char *nato[] = {
    "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"
};
```

- The array's notation, `*nato[]` , implies an array of pointers, which is how the compiler builds this construction in memory.
- The array's data type is `char`, so the pointers reference character arrays - strings - stored in memory.
- The `nato[]` array is filled with the memory locations of the strings as illustrated below.

Figure: How an array of pointers references strings as they sit in memory

```
char *nato[] = {
	0x404020, 0x404025, 0x40402b, 
	...
	0x4040b8, 0x4040bf
}
```

```
What the array stores

Addresses		Strings in memory
0x404020 --> "A" "l" "f" "a" "\0"
0x404025 --> "B" "r" "a" "v" "o" "\0"
0x40402b --> "C" "h" "a" "r" "l" "i" "e" "\0"
...
0x4040b8 --> "Y" "a" "n" "k" "e" "e" "\0"
0x4040bf --> "Z" "u" "l" "u" "\0"
```

- The string `Alfa` (terminated with a null character, `\0`) is stored at address `0x404020`.
- This memory location is stored in the `nato[]` array, not the string itself.
- Yes, the string appears in the array's declaration, but it is stored elsewhere in memory at runtime.

### Nato Translator Program

```C
#include <stdio.h>
#include <ctype.h>
int main()
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    char phrase[64];
    char ch;
    int i = 0;

    printf("Enter a word or phrase: ");

    // stores into location phrase 63 characters + null character from stdin, standard input.
    fgets(phrase, 64, stdin);

    // Loop until the null character is found in the string
    while (phrase[i])
    {
        ch = toupper(phrase[i]);

        // True when character ch is alphabetic
        if (isalpha(ch))
        {

            // ch-'A' transforms the letters to values 0 through 25, matching the corresponding array element.
            printf("%s ", nato[ch - 'A']);
        }
        i++;
        if (i == 64)
        {
            break;
        }
    }

    putchar('\n');
    return 0;
}
```

- Any alphabetic characters are detected by the `isalpha()` function.

- If found, the letter is used as a reference into the `nato[]` array.

- ```C
  nato[ch - 'A']
  ```

  - `ch - 'A'` calculates the index for the `nato` array.
  - For example, if `ch` is 'A', then `ch - 'A'` is `0`, so `nato[0]` is "Alfa".
  - If `ch` is 'B', then `ch - 'A'` is `1`, so `nato[1]` is "Bravo".
  - This works because the ASCII value of 'A' is 65, 'B' is 66, and so on. Subtracting 'A' (65) from any uppercase letter gives a zero-based index corresponding to that letter.
  - Let's say the input is "ABZ":
    - **First Character ('A')**:
      - `toupper('A')` is 'A'.
      - `isalpha('A')` is true.
      - `ch - 'A'` is `0`.
      - `nato[0]` is "Alfa".
      - Output: "Alfa".
    - **Second Character ('B')**:
      - `toupper('B')` is 'B'.
      - `isalpha('B')` is true.
      - `ch - 'A'` is `1`.
      - `nato[1]` is "Bravo".
      - Output: "Bravo".
    - **Third Character ('Z')**:
      - `toupper('Z')` is 'Z'.
      - `isalpha('Z')` is true.
      - `ch - 'A'` is `25`.
      - `nato[25]` is "Zulu".
      - Output: "Zulu".

**So, if we say "Howdy"**

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word or phrase: Howdy
Hotel Oscar Whiskey Delta Yankee 
```

- This basically means H for "Hotel", o for "Oscar", w for "Whiskey", d for "Delta", and y for "Yankee".
- **First Character ('H')**:
  - `toupper('H')` is 'H'.
  - `isalpha('H')` is true.
  - `ch - 'A'` is `7` (ASCII value of 'H' is 72, 'A' is 65, so 72 - 65 = 7).
  - `nato[7]` is "Hotel".
  - Output: "Hotel ".
- **Second Character ('o')**:
  - `toupper('o')` is 'O'.
  - `isalpha('O')` is true.
  - `ch - 'A'` is `14` (ASCII value of 'O' is 79, 'A' is 65, so 79 - 65 = 14).
  - `nato[14]` is "Oscar".
  - Output: "Oscar ".
- **Third Character ('w')**:
  - `toupper('w')` is 'W'.
  - `isalpha('W')` is true.
  - `ch - 'A'` is `22` (ASCII value of 'W' is 87, 'A' is 65, so 87 - 65 = 22).
  - `nato[22]` is "Whiskey".
  - Output: "Whiskey ".
- **Fourth Character ('d')**:
  - `toupper('d')` is 'D'.
  - `isalpha('D')` is true.
  - `ch - 'A'` is `3` (ASCII value of 'D' is 68, 'A' is 65, so 68 - 65 = 3).
  - `nato[3]` is "Delta".
  - Output: "Delta ".
- **Fifth Character ('y')**:
  - `toupper('y')` is 'Y'.
  - `isalpha('Y')` is true.
  - `ch - 'A'` is `24` (ASCII value of 'Y' is 89, 'A' is 65, so 89 - 65 = 24).
  - `nato[24]` is "Yankee".
  - Output: "Yankee ".
- **Sixth Character ('\n')**:
  - `toupper('\n')` is '\n'.
  - `isalpha('\n')` is false.
  - The loop continues to the next character.
- **End of String**:
  - The loop terminates when it encounters the null character (`\0`).

**If we type a longer phrase such as "Hello, World!"**

```sh 
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word or phrase: Hello, World!
Hotel Echo Lima Lima Oscar Whiskey Oscar Romeo Lima Delta
```

- As we can see , and ! are ignored because nonalpha characters are ignored in the code, no output for them is generated.

### Reading and converting a file

```C
int main(int argc, char *argv[]){
    	const char *nato[] = {
        	"Alfa", "Bravo", "Charlie", "Delta", 			"Echo", "Foxtrot", "Golf", "Hotel", 			"India", "Juliett", "Kilo", "Lima", 			"Mike", "November", "Oscar", "Papa", 			"Quebec", "Romeo", "Sierra", "Tango", 			"Uniform", "Victor", "Whiskey", "X-ray", 			"Yankee", "Zulu"};
    FILE *n;
    int ch;
    
    if(argc < 2){
        fprintf(stderr, "Please supply a text file argument\n");
        exit(1);
    }
    
    // Open the filename supplied at the command prompt, referenced as argv[1]
    n = fopen(argv[1], "r");
    if(n == NULL){
        fprintf(stderr, "Unable to open %s\n", argv[1]);
        exit(1);
    }
    
    // Reads one character at a time from the file, storing it in variable ch. The EOF marks the ned of the file.
    while((ch = fgetc(n)) != EOF){
        // Process only text characters
        if(isalpha(ch)){
            // Uses the uppercase version of the character, minus the value of 'A' to index the nato[] array
            printf("%s ", nato[toupper(ch) - 'A']);
        }
    }
    
    putchar('\n');
    fclose(n);
    return 0;
    
}
```

`Output` (Opening our pithy.txt)

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Please supply a text file argument

chan@CMA:~/C_Programming/practice$ ./practice pithy.txt
Papa Oscar Lima India Tango India Charlie Sierra Echo X-ray India Sierra Tango Sierra Sierra Oscar Tango Hotel Alfa Tango Uniform November Charlie Oscar Oscar Romeo Delta India November Alfa Tango Echo Delta Papa Echo Oscar Papa Lima Echo C......
```

### Converting NATO input to character output

- We will be using `strtok()` function to parse words in a stream of text.
- `strtok()` can be assumed to be translated as "string tokenizer".
- The `strtok()` function parses a string into chunks based on one or more separator characters. Defined in `string.h` header file.

```C
char *strtok(char *str, const char *delim);
```

- The first argument `str` is the string to scan.
- The second argument `delim` (delimiter) is a string containing the individual characters that can separate or delimit, the character chunks we want to parse.
- The value returned is a `char` pointer referencing **the character chunk found.**

```C
match = strtok(string, " ");
```

- This statement scans characters held in buffer `string`, stopping when the space character is encountered.
- The `char` pointer `match` holds the address of the word (or text chunk) found, terminated with a null character where the space or another delimiter would otherwise be.
- The `NULL` constant is returned when nothing is found.
- To continue scanning the same string, the first argument is replaced with the `NULL` constant:

```C
match = strtok(NULL, " ");
```

- The `NULL` argument informs the function to use the string passed earlier and continue the tokenizing operation.

```C
int main(){
    char sometext[64];
    char *match;
    
    printf("Type some text: ");
    fgets(sometext, 64, stdin);
    
    // The initial call to strtok(), with the string to search.
    match = strtok(sometext, " ");
    
    // Loop as long as the return value is not NULL
    while(match){
        printf("%s\n", match);
        
        // In the second  call to strtok(), NULL is used to keep searching the same string which is our sometext string.
        match = strtok(NULL, " ");
    }
    
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Type some text: This is some text
This
is
some
text

chan@CMA:~/C_Programming/practice$ ./practice
Type some text: Hello, World!
Hello,
World!

```

- To avoid capturing the punctuation characters, we can set this delimiter string:

```C
match = strtok(sometext, " ,.!?:;\"'')
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Type some text: Hello, World!
Hello
World
```



`practice.h`

```C
char isterm(char *term);
```



`functions.c`

```C
char isterm(char *term)
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    int x;
    const char *n;
    char *t;

    for (x = 0; x < 26; x++)
    {
        // Set pointer n to the current nato word
        n = nato[x];
        // Pointer t references the term passed.
        t = term;

        // Loop until the NATO term ends
        while (*n != '\0')
        {
            // Logically converts each letter to uppercase and compares
            if ((*n | 0x20) != (*t | 0x20))
            {

                // For no match, the loop breaks and the next term in nato[] is compared.
                break;
            }
            // Increment through each letter
            n++;
            t++;
        }

        // When pointer n is the null character, the terms have matched.
        if (*n == '\0')
        {
            // Returns the first letter of the NATO term
            return (*nato[x]);
        }
    }
    return ('\0');
}
```

1. **`char isterm(char \*term)`**: Defines the `isterm` function that takes a string `term` and returns a character.
2. **`const char *nato[] = { ... }`**: Declares an array of strings containing the NATO phonetic alphabet.
3. **`int x;`**: Declares an integer `x` for looping through the NATO array.
4. **`const char *n;`**: Declares a pointer `n` to iterate through the NATO words.
5. **`char *t;`**: Declares a pointer `t` to iterate through the input term.
6. **`for (x = 0; x < 26; x++)`**: Loops through each NATO word.
7. **`n = nato[x];`**: Sets `n` to the current NATO word.
8. **`t = term;`**: Sets `t` to the input term.
9. **`while (*n != '\0')`**: Loops through each character of the NATO word.
10. **`if ((*n | 0x20) != (*t | 0x20))`**: Compares characters case-insensitively.
    - `*n | 0x20 ` and `*t | 0x20`:
      - The bitwise OR operation with `0x20` converts uppercase alphabetic characters to their lowercase equivalents.
      - In ASCII, the difference between uppercase and lowercase letters is the 6th bit (0x20). For example, the ASCII value of 'A' is 65 (0x41) and 'a' is 97 (0x61). The bitwise OR with `0x20` sets this bit, converting 'A' to 'a'.
      - This operation does not affect lowercase letters or non-alphabetic characters.
11. **`break;`**: Breaks the loop if characters don't match.
12. **`n++; t++;`**: Moves to the next character in both strings.
13. **`if (*n == '\0')`**: Checks if the end of the NATO word is reached.
14. **`return (*nato[x]);`**: Returns the first letter of the matching NATO word.
15. **`return ('\0');`**: Returns null character if no match is found.

###### Comparison:

- Bitwise OR with `0x20`:
  - Faster as it involves a single bitwise operation.
  - Works only for ASCII characters.
  - Does not handle locale-specific case conversions.
- `tolower`/`toupper`:
  - More readable and explicit.
  - Handles locale-specific case conversions.
  - Slightly slower due to function call overhead.

`practice.c` (Main)

```C
int main()
{

    char phrase[64];
    char *match;
    char ch;

    printf("NATO word or phrase: ");
    fgets(phrase, 64, stdin);

    match = strtok(phrase, " ");
    while (match)
    {
        if ((ch = isterm(match)) != '\0')
        {
            putchar(ch);
        }
        match = strtok(NULL, " ");
    }

    putchar('\n');
    return 0;
}
```

1. **`char phrase[64];`**: Declares a character array `phrase` with a size of 64 to store the input string.
2. **`char *match;`**: Declares a pointer `match` to hold tokens from the input string.
3. **`char ch;`**: Declares a character variable `ch` to store the result from `isterm`.
4. **`fgets(phrase, 64, stdin);`**: Reads a line of input from the standard input (keyboard) and stores it in `phrase`.
5. **`match = strtok(phrase, " ");`**: Tokenizes the input string `phrase` using space as the delimiter and stores the first token in `match`.
6. **`while (match)`**: Starts a loop that continues as long as `match` is not `NULL`.
7. **`if ((ch = isterm(match)) != '\0')`**: Calls the `isterm` function with `match` and checks if the result is not the null character.
8. **`putchar(ch);`**: If `isterm` returns a valid character, it prints that character.
9. **`match = strtok(NULL, " ");`**: Gets the next token from the input string.
10. **`putchar('\n');`**: Prints a newline character after the loop ends.



`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: india whiskey sierra bravo
IWSB
```

##### Input: "india whiskey sierra bravo"

1. Main Function Execution:
   - The input string is read and tokenized into words: "india", "whiskey", "sierra", "bravo".
   - Each word is passed to the `isterm` function.

##### Processing "india":

1. **Initialization**:
   - `term` = "india"
   - `x` starts at 0, iterating through the NATO phonetic alphabet.
2. **First Iteration (x = 0)**:
   - `n`= "Alfa"
   - `t`= "india"
   - Compare 'A' with 'i' (case-insensitive): no match, break.
3. **Second Iteration (x = 1)**:
   - `n` = "Bravo"
   - `t` = "india"
   - Compare 'B' with 'i': no match, break.
4. **Continue Iterations**:
   - This process continues until `x = 8`.
5. **Ninth Iteration (x = 8)**:
   - `n` = "India"
   - `t` = "india"
   - Compare 'I' with 'i': match.
   - Compare 'n' with 'n': match.
   - Compare 'd' with 'd': match.
   - Compare 'i' with 'i': match.
   - Compare 'a' with 'a': match.
   - `n` reaches null character, return 'I'.

##### Processing "whiskey":

1. **Initialization**:
   - `term` = "whiskey"
   - `x` starts at 0.
2. **Continue Iterations**:
   - This process continues until `x = 22`.
3. **Twenty-Third Iteration (x = 22)**:
   - `n` = "Whiskey"
   - `t` = "whiskey"
   - Compare 'W' with 'w': match.
   - Compare 'h' with 'h': match.
   - Compare 'i' with 'i': match.
   - Compare 's' with 's': match.
   - Compare 'k' with 'k': match.
   - Compare 'e' with 'e': match.
   - Compare 'y' with 'y': match.
   - `n` reaches null character, return 'W'.

##### Processing "sierra":

1. **Initialization**:
   - `term` = "sierra"
   - `x` starts at 0.
2. **Continue Iterations**:
   - This process continues until `x = 18`.
3. **Nineteenth Iteration (x = 18)**:
   - `n` = "Sierra"
   - `t` = "sierra"
   - Compare 'S' with 's': match.
   - Compare 'i' with 'i': match.
   - Compare 'e' with 'e': match.
   - Compare 'r' with 'r': match.
   - Compare 'r' with 'r': match.
   - Compare 'a' with 'a': match.
   - `n` reaches null character, return 'S'.

##### Processing "bravo":

1. **Initialization**:
   - `term` = "bravo"
   - `x` starts at 0.
2. **Second Iteration (x = 1)**:
   - `n` = "Bravo"
   - `t` = "bravo"
   - Compare 'B' with 'b': match.
   - Compare 'r' with 'r': match.
   - Compare 'a' with 'a': match.
   - Compare 'v' with 'v': match.
   - Compare 'o' with 'o': match.
   - `n` reaches null character, return 'B'.

##### Final Output:

The main function collects the results from `isterm` and prints them:

- "IWSB"

This is the step-by-step process of how the input "india whiskey sierra bravo" is processed by the code.

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: india tango whiskey oscar romeo kilo sierra
ITWORKS

```

- An input sentence with no matching characters outputs a blank line. Mixed characters are output like this:

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: Also starring Zulu as Kono
Z
```

#### Reading NATO input from a file

`practice.h`

```C
char isterm(char *term);
```

`functions.c`

```C
char isterm(char *term)
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    int x;
    const char *n;
    char *t;

    for (x = 0; x < 26; x++)
    {
        // Set pointer n to the current nato word
        n = nato[x];
        // Pointer t references the term passed.
        t = term;

        // Loop until the NATO term ends
        while (*n != '\0')
        {
            // Logically converts each letter to uppercase and compares
            if ((*n | 0x20) != (*t | 0x20))
            {

                // For no match, the loop breaks and the next term in nato[] is compared.
                break;
            }
            // Increment through each letter
            n++;
            t++;
        }

        // When pointer n is the null character, the terms have matched.
        if (*n == '\0')
        {

            // Returns the first letter of the NATO term
            return (*nato[x]);
        }
    }

    return ('\0');
}
```

- Explanations are above.

`practice.c`

```C
int main(int argc, char *argv[])
{

    FILE *n;
    char word[64];
    int ch, offset;

    if (argc < 2)
    {
        fprintf(stderr, "Please supply a text file arguments\n");
        exit(1);
    }

    n = fopen(argv[1], "r");
    if (n == NULL)
    {
        fprintf(stderr, "Unable to open '%s'\n", argv[1]);
        exit(1);
    }

    offset = 0;
    // Loop as long as the file has bytes to read
    while ((ch = fgetc(n)) != EOF)
    {
        if (isalpha(ch))
        {
            // Stores the character to build the word
            word[offset] = ch;
            offset++;
            // Checks for overflow; bails if so
            if (offset >= 64)
            {
                fprintf(stderr, "Buffer overflow\n");
                return (1);
            }
        }
        // A nonalphabetic character is found, meaning the end of a word
        else
        {
            // Confirm that the word[] buffer has some text in it
            if (offset > 0)
            {
                // Cap the strings
                word[offset] = '\0';

                // Process the word, returning a valid character or the null character (doesn't print)
                putchar(isterm(word));

                // Resets the offset to store the next word
                offset = 0;
            }
        }
    }
    putchar('\n');
    fclose(n);
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice functions.c
ABCDEFGHIJKLMNOPQRSTUVWYZ
```

---

## Caesarean cipher

- When `block buffering` mode is active, output doesn't appear until the buffer is full or when the program ends.
- Even if a newline appears in the stream, block buffering stores the character in the stream.
- Buffering for an I/O device is set by using the `setbuf()` function, defined in `stdio.h` header file.
- This function overrides the terminal's default line buffering and establishes block buffering using a specific chunk of memory.
- In effect, it disables line buffering for the given file handle ( or standard I/O device) and activates block buffering.

```C
int main()
{
    // A holding bin for standard output; BUFSIZ is defined in stdio.h
    char buffer[BUFSIZ];
    int a, b;

    // Commit standard output to block buffering
    setbuf(stdout, buffer);

    printf("Type a letter: ");
    // Read a single character from standard input
    a = getchar();
    printf("Type a letter: ");

    // Read the next single character from standard input
    b = getchar();

    printf("a='%c', b = '%c'\n", a, b);

    return 0;
}
```

- If we run this program, we see no output, instead the `getchar()` function prompts for input, so the program waits.
- The output is held back, stored in the character array `buffer`, waiting for text to fill the buffer or for the program to end.
- If we type `ab` at the blinking cursor, only after the Enter key is pressed, does the program end and the buffer is flushed, revealing standard output:

```sh
chan@CMA:~/C_Programming/practice$ ./practice
ab
Type a letter: Type a letter: a='a', b = 'b'
```

- Some C programmers use the `fflush()` function to force output or to clear the input stream which may be a workable solution but not the best.

#### Writing a simple filter

- Filters modify stream input and generate stream output.

- The `getchar()` function reads a single character from standard input.

- For most compilers, `getchar()` is a macro, equivalent to the `fgetc()` function:

  - ```C
    c = fgetc(stdin);
    ```

- The `fgetc()` function reads a single character (byte) from an open file handle. 

- On the preceding line, `stdin` is used as the standard input device. 

- The integer value returned is stored in the `int` variable `c`.

- This variable must be declared of the integer data type, not character.

- The reason is that important values, specifically the end-of-file (EOF) marker, are integer values.

- Assigning the function's return value to a `char` variable means the EOF won't be interpreted properly.

- The `putchar()` function sends a single character to standard output.

- `putchar()` is often defined as a macro that expands to the `fputc()` function.

- ```C
  r = fputc(c, stdout);
  ```

- The `fputc()` function sends an integer value `c` to the open file handle represented by `stdout`.

- The return value, `r` is the character written or EOF for an error.

- As with `fgetc()`, both variables `r` and `c` must be integers.

- In Linux, the EOF key is `Ctrl + D`.



A program to modify the input so that all vowels are detected and replaced with an asterisk.

```C
int main()
{
    // I/O deals with integers, not characters.
    int ch;

    while ((ch = getchar()) != EOF)
    {
        switch (ch)
        {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            putchar('*');
            break;
        default:
            putchar(ch);
        }
    }

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
hello
h*ll*
```

- The program will keep prompting, we just have to press `Ctrl + D` to mark the EOF thus end the program.



#### Exercise 4.1

"Now that you have the basic filter skeleton in `io_filter.c`, you can perform your own
modifications, testing your filter programming skills. Here is such a challenge you can
code on your own: write a filter that converts lowercase characters to uppercase. The
effect of such a filter is to generate output in ALL CAPS."

`practice.c`

```C
int main(){
    int ch;
    
    while((ch = getchar()) != EOF){
        if(islower(ch)){
            ch = toupper(ch);
        }
        putchar(ch);
    }
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
heLlO
HELLO
chan@CMA:~/C_Programming/practice$ ./practice
hey hey not bad
HEY HEY NOT BAD
```



#### Exercise 4.2

"Write a filter that randomizes character text, modifying standard input to generate
output in either upper- or lowercase, regardless of the original characters case."

```C
int main(){
    int ch, r;
    
    // Seed the randomizer
    srand((unsigned)time(NULL));
    
    while((ch = getchar()) != EOF){
        // Generate a random value, 0 to 1
        r = rand() % 2;
        
        // If r == 1, make the character uppercase
        if(r){
            putchar(toupper(ch));
        }
        // Otherwise, it is converted to lower
        else{
            putchar(tolower(ch));
        }
        
        // touppper() and tolower() affect only letters.
    }
}
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice
Could be worse, oh wait no it couldn't.
couLd Be WORse, OH WaIT no iT COULdN'T.

```

```sh
chan@CMA:~/C_Programming/practice$ echo "Give me all your moeny" | ./practice
gIvE mE aLl yoUr mOeny
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice < file.txt
chan@CMA:~/C_Programming/practice$ echo "Give me all your moeny" | ./practice > file.txt
```

#### Rotating 13 characters

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-09-30 22-21-23.png)

```C
int main()
{
    int ch;
    while ((ch = getchar()) != EOF)
    {
        // Only process alphabet characters
        if (isalpha(ch))
        {

            // Searches for "A" thru "M" or "a" thru "m"
            if (toupper(ch) >= 'A' && toupper(ch) <= 'M')
            {
                // Rotates(shift) up for the lower half of the alphabet
                ch += 13;
            }
            else
            {
                // Otherwise, rotates (shift) down
                ch -= 13;
            }
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ echo "Hail, Caesar!" | ./practice
UnvyPnrfne
```

- Because the `rot13` filter decodes and encodes the same text, we can put the program to the test through it twice.
- In the command-line construction below, text is echoed through the program once and then again.
- The result is the original text, thanks to the magic of the `rot13` process.

```sh
chan@CMA:~/C_Programming/practice$ echo "Hail, Caesar!" | ./practice | ./practice
HailCaesar
```

```sh
chan@CMA:~/C_Programming/practice$ echo "Why did Caesar cross the Rubicon?" | ./practice 
JulqvqPnrfnepebffgurEhovpba
```

#### Devising a more Caesarean cipher

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-01 22-01-21.png)

- When a character is detected as out of range by the if statement, its value must be reduced by 26, wrapping it back to 'A' or 'a', depending on the letter's original case.
- Due to the proximity of uppercase 'Z' to lowercase 'a', this if statement test works because this particular shift is only three characters.
- From figure 4.7, we can see that the ASCII table sets only six characters between uppercase Z and lowercase a.
- For larger character shifts, more complex testing must be performed.

```C
int main(){
    int shift,ch;
    
    //Shifts from A to D which is done backward here because math
    shift = 'D' - 'A';
    
    while((ch = getchar()) != EOF){
        // Only process alphabet characters
        if(isalpha(ch)){
            // Shift the letter
            ch += shift;
            
            // Determines whether the new character is out of range
            if((ch > 'Z' && ch < 'a') || ch > 'z'){
                // If so, adjusts its value back within range
                ch -= 26;
            }
        }
    }
    
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Now is the time for all good men...
Qrz lv wkh wlph iru doo jrrg phq...
```

- Unlike with a `rot13` filter, we can't run the same program twice to decode the A-to-D shift.
- Instead, to decode the message, we must shift from D back to A.
- Two changes are required to make this change.

```C
shift = 'A' - 'D';
```

- Second, the out-of-bounds testing must check the underside of the alphabet, so see whether a character's value has dipped below 'A' or 'a':

```C
if(ch < 'A' || (ch > 'Z' && ch < 'a')){
    ch += 26;
}
```

- If the character wraps on the underside of the alphabet, its value is increased by 26, which wraps it back up to the Z end, correcting the overflow.



```C
int main(int argc, char *argv[])
{
    int shift, ch;
    char a, b;

    // If fewer than 3 arguments are provided, default shift is 13.
    if (argc < 3)
    {
        shift = 13;
    }
    else
    {
        // Get the first characters of the second and third arguments
        a = argv[2][0];
        b = argv[1][0];

        // Check if both characters are alphabetic
        if (isalpha(a) && isalpha(b))
        {
            // Convert both to uppercase
            a = toupper(a);
            b = toupper(b);

            // calculate the shift value
            shift = a - b;

            // Ensure the shift is within the range -25 to 25
            if (shift < -25 || shift > 25)
            {
                shift = 13;
            }
        }
        else
        {
            shift = 13;
        }
    }

    // Read characters from standard input until EOF
    while ((ch = getchar()) != EOF)
    {
        //If the character is an uppercase letter
        if (isupper(ch))
        {
            // Shift the letter
            ch += shift;

            // Adjusts appropriately for overflow in either direction
            // Adjust for overflow beyond 'Z'
            if (ch > 'Z')
                ch -= 26;
            // Adjust for overflow below 'A'
            if (ch < 'A')
                ch += 26;
            putchar(ch);
        }
        // If it is a lowercase letter
        else if (islower(ch))
        {
            ch += shift;
            if (ch > 'z')
                ch -= 26;
            if (ch < 'a')
                ch += 26;
            putchar(ch);
        }
        // If the character is not a letter, print it as is
        else
        {
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}

```

- **Shift Calculation**:
  - If fewer than 3 arguments are provided, the shift is set to 13.
  - If 3 or more arguments are provided, the first characters of the second and third arguments are used to calculate the shift.
  - For example, if the arguments are `./practice A D`, `a` is 'D' and `b` is 'A'. The shift is calculated as `shift = 'D' - 'A' = 3`.
- **Processing Each Character**:
  - For each character read:
    - If it is an uppercase letter (e.g., 'T'):
      - The character is shifted by the calculated shift value.
      - Adjustments are made if the shifted character goes beyond 'Z' or below 'A'.
    - If it is a lowercase letter (e.g., 'h'):
      - The character is shifted by the calculated shift value.
      - Adjustments are made if the shifted character goes beyond 'z' or below 'a'.
    - If it is not a letter (e.g., space ' '), it is printed as is.

```sh
chan@CMA:~/C_Programming/practice$ ./practice A R
This is a test
Kyzj zj r kvjk

chan@CMA:~/C_Programming/practice$ ./practice R A
Kyzj zj r kvjk
This is a test

```

##### Example Run 1: `./practice A R`

1. **Command-Line Arguments**:
   - `argv[1] = "A"`
   - `argv[2] = "R"`
2. **Shift Calculation**:
   - `a = 'R'`
   - `b = 'A'`
   - Convert both to uppercase (they are already uppercase).
   - `shift = 'R' - 'A' = 82 - 65 = 17`
3. **Input**: "This is a test"
4. **Character Processing**:
   - 'T' (uppercase):
     - Shifted: 'T' + 17 = 'K' (adjusted for overflow)
   - 'h' (lowercase):
     - Shifted: 'h' + 17 = 'y'
   - 'i' (lowercase):
     - Shifted: 'i' + 17 = 'z'
   - 's' (lowercase):
     - Shifted: 's' + 17 = 'j'
   - ' ' (space):
     - Printed as is
   - 'i' (lowercase):
     - Shifted: 'i' + 17 = 'z'
   - 's' (lowercase):
     - Shifted: 's' + 17 = 'j'
   - ' ' (space):
     - Printed as is
   - 'a' (lowercase):
     - Shifted: 'a' + 17 = 'r'
   - ' ' (space):
     - Printed as is
   - 't' (lowercase):
     - Shifted: 't' + 17 = 'k'
   - 'e' (lowercase):
     - Shifted: 'e' + 17 = 'v'
   - 's' (lowercase):
     - Shifted: 's' + 17 = 'j'
   - 't' (lowercase):
     - Shifted: 't' + 17 = 'k'
5. **Output**: "Kyzj zj r kvjk"

##### Example Run 2: `./practice R A`

1. **Command-Line Arguments**:
   - `argv[1] = "R"`
   - `argv[2] = "A"`
2. **Shift Calculation**:
   - `a = 'A'`
   - `b = 'R'`
   - Convert both to uppercase (they are already uppercase).
   - `shift = 'A' - 'R' = 65 - 82 = -17`
3. **Input**: "Kyzj zj r kvjk"
4. **Character Processing**:
   - 'K' (uppercase):
     - Shifted: 'K' - 17 = 'T' (adjusted for underflow)
   - 'y' (lowercase):
     - Shifted: 'y' - 17 = 'h'
   - 'z' (lowercase):
     - Shifted: 'z' - 17 = 'i'
   - 'j' (lowercase):
     - Shifted: 'j' - 17 = 's'
   - ' ' (space):
     - Printed as is
   - 'z' (lowercase):
     - Shifted: 'z' - 17 = 'i'
   - 'j' (lowercase):
     - Shifted: 'j' - 17 = 's'
   - ' ' (space):
     - Printed as is
   - 'r' (lowercase):
     - Shifted: 'r' - 17 = 'a'
   - ' ' (space):
     - Printed as is
   - 'k' (lowercase):
     - Shifted: 'k' - 17 = 't'
   - 'v' (lowercase):
     - Shifted: 'v' - 17 = 'e'
   - 'j' (lowercase):
     - Shifted: 'j' - 17 = 's'
   - 'k' (lowercase):
     - Shifted: 'k' - 17 = 't'
5. **Output**: "This is a test"

##### Summary:

- The program calculates the shift based on the difference between the first characters of the second and third command-line arguments.
- It then reads input characters, shifts alphabetic characters by the calculated amount, and prints the modified characters.
- Non-alphabetic characters are printed as is.
- The shift value can be positive or negative, depending on the order of the command-line arguments.

#### Building the hex output filter

```C
int main()
{
    int ch, wrap;

    // Initialize the wrap to zero
    wrap = 0;
    while ((ch = getchar()) != EOF)
    {
        // Outputs character as two-digit hex byte, with a leading zero.
        printf("%0.2X ", ch);
        wrap += 3; // Each printf() output is 3 characters wide

        // Assume that the terminal column width is 80
        // 77 because 77 + 3 = 80
        if (wrap > 77 || ch == '\n')
        {
            // Output a newline
            putchar('\n');
            // Reset the wrap value
            wrap = 0;
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
This is a test
54 68 69 73 20 69 73 20 61 20 74 65 73 74 0A
```



#### Creating a NATO filter

```c
int main()
{

    const char *nato[] = {"Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    char ch;

    while ((ch = getchar()) != EOF)
    {
        if (isalpha(ch))
        {
            // Translates a character into an offset within the nato[] array
            printf("%s ", nato[toupper(ch) - 'A']);
        }
        // Output a newline when encountered to keep the output clean
        if (ch == '\n')
        {
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
hello
Hotel Echo Lima Lima Oscar
```



#### Filtering words

```C
#define WORDSIZE 64

int main(){
    char word[WORDSIZE];
    int ch, offset;
    
    // Initializes the offset value
    offset = 0;
    
    while((ch = getchar()) != EOF){
        // The isspace() returns TRUE for white space characters, marking the end of a word
        if(isspace(ch)){
            // Capping the string with null 
            word[offset] = '\0';
            // Ensures that the buffer has text in it to print
            if(offset > 0){
                // Output the buffer's content on a line by itself
                printf("%s\n", word);
            }
            // Reset the offset
            offset = 0;
        }
        // Printable characters are handled here, filling the buffer.
        else{
            // Stores the character
            word[offset] = ch;
            // Increment the offset
            offset++;
            
            // Checks for potential overflow, a full buffer
            if(offset == WORDSIZE - 1){
                // Cap the string!
                word[offset] = '\0';
                // Output the word, dumping the buffer
                printf("%s\n", word);
                // reset the offset
                offset = 0;
            }
        }
    }
    
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Is this still the Caesarean Cipher chapter?
Is
this
still
the
Caesarean
Cipher
chapter?
```

##### Step-by-Step Process:

1. **Initial State**:
   - `word` buffer is empty.
   - `offset` is 0.
2. **Processing "Is"**:
   - 'I' is stored in `word[0]`, `offset` becomes 1.
   - 's' is stored in `word[1]`, `offset` becomes 2.
   - Space ' ' is encountered:
     - `word[2]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "Is".
     - `offset` is reset to 0.
3. **Processing "this"**:
   - 't' is stored in `word[0]`, `offset`becomes 1.
   - 'h' is stored in `word[1]`, `offset` becomes 2.
   - 'i' is stored in `word[2]`, `offset` becomes 3.
   - 's' is stored in `word[3]`, `offset` becomes 4.
   - Space ' ' is encountered:
     - `word[4]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "this".
     - `offset` is reset to 0.
4. **Processing "still"**:
   - 's' is stored in `word[0]`, `offset` becomes 1.
   - 't' is stored in `word[1]`, `offset` becomes 2.
   - 'i' is stored in `word[2]`, `offset` becomes 3.
   - 'l' is stored in `word[3]`, `offset` becomes 4.
   - 'l' is stored in `word[4]`, `offset` becomes 5.
   - Space ' ' is encountered:
     - `word[5]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "still".
     - `offset` is reset to 0.
5. **Processing "the"**:
   - 't' is stored in `word[0]`, `offset` becomes 1.
   - 'h' is stored in `word[1]`, `offset` becomes 2.
   - 'e' is stored in `word[2]`, `offset` becomes 3.
   - Space ' ' is encountered:
     - `word[3]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "the".
     - `offset` is reset to 0.
6. **Processing "Caesarean"**:
   - 'C' is stored in `word[0]`, `offset` becomes 1.
   - 'a' is stored in `word[1]`, `offset` becomes 2.
   - 'e' is stored in `word[2]`, `offset` becomes 3.
   - 's' is stored in `word[3]`, `offset` becomes 4.
   - 'a' is stored in `word[4]`, `offset` becomes 5.
   - 'r' is stored in `word[5]`, `offset` becomes 6.
   - 'e' is stored in `word[6]`, `offset` becomes 7.
   - 'a' is stored in `word[7]`, `offset` becomes 8.
   - 'n' is stored in `word[8]`, `offset`becomes 9.
   - Space ' ' is encountered:
     - `word[9]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "Caesarean".
     - `offset` is reset to 0.
7. **Processing "Cipher"**:
   - 'C' is stored in `word[0]`, `offset` becomes 1.
   - 'i' is stored in `word[1]`, `offset` becomes 2.
   - 'p' is stored in `word[2]`, `offset` becomes 3.
   - 'h' is stored in `word[3]`, `offset` becomes 4.
   - 'e' is stored in `word[4]`, `offset`becomes 5.
   - 'r' is stored in `word[5]`, `offset` becomes 6.
   - Space ' ' is encountered:
     - `word[6]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "Cipher".
     - `offset` is reset to 0.
8. **Processing "chapter?"**:
   - 'c' is stored in `word[0]`, `offset` becomes 1.
   - 'h' is stored in `word[1]`, `offset` becomes 2.
   - 'a' is stored in `word[2]`, `offset` becomes 3.
   - 'p' is stored in `word[3]`, `offset` becomes 4.
   - 't' is stored in `word[4]`, `offset` becomes 5.
   - 'e' is stored in `word[5]`, `offset` becomes 6.
   - 'r' is stored in `word[6]`, `offset` becomes 7.
   - '?' is stored in `word[7]`, `offset` becomes 8.
   - End of input:
     - `word[8]` is set to `'\0'`.
     - `printf("%s\n", word)` prints "chapter?".



##### Notes

- It is vital that all strings in C end with the null character, `\0`, especially when we build our own strings, as done in the above program, confirm that the string that's created is capped.
- If not, we get an overflow and all kinds of ugly output and potentially bad things happening.

---

## Encoding and decoding

- To explore the concept of encoding and decoding, regardless of the thrills and dangers, we must:
  - Appreciate how characters are represented on computers
  - Learn various ASCII encoding tricks
  - Play with character representation
  - Translate plain text into hex bytes for data transfer
  - Reverse translate hex bytes back into text (or data)
  - Improve encoding techniques by adding checksums
  - Explore the URL encoding method

### The concept of plain text

- The computer doesn't know text.
- The `char` data type is merely a tiny integer, ranging in value from 0 through 255 (unsigned) or -128 to 127 (signed).
- It's only the presentation of the `char` data type that makes it look like a character.

### Understanding ASCII

![Screenshot from 2024-10-05 20-45-17](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-05 20-45-17.png)

- ASCII codes range from 0 through 127.
- These are binary values 000-0000 through 111-1111.
- For the C language `char` data type, these values are all positive whether the variable is signed or unsigned.

### Simple Program that prints ASCII value of a character

```C
int main()
{
    // Allocate memory for the input
    char *input = malloc(2 * sizeof(char));
    if (input == NULL)
    {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(1);
    }
    // Getting input from the user
    printf("Enter a word: ");
    if (fgets(input, 2, stdin) != NULL)
    {
        // Remove newline character if present
        size_t len = strlen(input);
        if (len > 0 && input[len - 1] == '\n')
        {
            input[len - 1] = '\0';
        }
    }
    printf("ASCII code for %s is %d\n", input, input[0]);
	
    // Free the memory
    free(input);
    // Assign our input pointer to NULL to avoid dangling pointer
    input = NULL;
    return 0;
}
```

### Implement the ASCII table as shown above

```C
int main()
{
    int x;

    // output the header row, all columns or "sticks"
    printf("Dec Oct Hex C \
    Dec Oct Hex C \
    Dec Oct Hex C \
    Dec Oct Hex C\n");

    // only need to process one stick, but use offsets to output the other three sticks
    for (x = 0; x < 32; x++)
    {
        // printing values in decimal %d, octal %o, hex %x wtih a minimum field width of 3 characters
        // first stick, don't output character values
        printf("%3d %3o %3x - | ", x, x, x);
        // each other stick in a 32, 64, 96 offset
        printf(" %3d %3o %3x  %c | ", x + 32, x + 32, x + 32, x + 32);

        printf(" %3d %3o %3x  %c | ", x + 64, x + 64, x + 64, x + 64);

        printf(" %3d %3o %3x  %c \n", x + 96, x + 96, x + 96, x + 96);
    }
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Dec Oct Hex C     Dec Oct Hex C     Dec Oct Hex C     Dec Oct Hex C
  0   0   0 - |   32  40  20    |   64 100  40  @ |   96 140  60  ` 
  1   1   1 - |   33  41  21  ! |   65 101  41  A |   97 141  61  a 
  2   2   2 - |   34  42  22  " |   66 102  42  B |   98 142  62  b 
  3   3   3 - |   35  43  23  # |   67 103  43  C |   99 143  63  c 
  4   4   4 - |   36  44  24  $ |   68 104  44  D |  100 144  64  d 
  5   5   5 - |   37  45  25  % |   69 105  45  E |  101 145  65  e 
  6   6   6 - |   38  46  26  & |   70 106  46  F |  102 146  66  f 
  7   7   7 - |   39  47  27  ' |   71 107  47  G |  103 147  67  g 
  8  10   8 - |   40  50  28  ( |   72 110  48  H |  104 150  68  h 
  9  11   9 - |   41  51  29  ) |   73 111  49  I |  105 151  69  i 
 10  12   a - |   42  52  2a  * |   74 112  4a  J |  106 152  6a  j 
 11  13   b - |   43  53  2b  + |   75 113  4b  K |  107 153  6b  k 
 12  14   c - |   44  54  2c  , |   76 114  4c  L |  108 154  6c  l 
 13  15   d - |   45  55  2d  - |   77 115  4d  M |  109 155  6d  m 
 14  16   e - |   46  56  2e  . |   78 116  4e  N |  110 156  6e  n 
 15  17   f - |   47  57  2f  / |   79 117  4f  O |  111 157  6f  o 
 16  20  10 - |   48  60  30  0 |   80 120  50  P |  112 160  70  p 
 17  21  11 - |   49  61  31  1 |   81 121  51  Q |  113 161  71  q 
 18  22  12 - |   50  62  32  2 |   82 122  52  R |  114 162  72  r 
 19  23  13 - |   51  63  33  3 |   83 123  53  S |  115 163  73  s 
 20  24  14 - |   52  64  34  4 |   84 124  54  T |  116 164  74  t 
 21  25  15 - |   53  65  35  5 |   85 125  55  U |  117 165  75  u 
 22  26  16 - |   54  66  36  6 |   86 126  56  V |  118 166  76  v 
 23  27  17 - |   55  67  37  7 |   87 127  57  W |  119 167  77  w 
 24  30  18 - |   56  70  38  8 |   88 130  58  X |  120 170  78  x 
 25  31  19 - |   57  71  39  9 |   89 131  59  Y |  121 171  79  y 
 26  32  1a - |   58  72  3a  : |   90 132  5a  Z |  122 172  7a  z 
 27  33  1b - |   59  73  3b  ; |   91 133  5b  [ |  123 173  7b  { 
 28  34  1c - |   60  74  3c  < |   92 134  5c  \ |  124 174  7c  | 
 29  35  1d - |   61  75  3d  = |   93 135  5d  ] |  125 175  7d  } 
 30  36  1e - |   62  76  3e  > |   94 136  5e  ^ |  126 176  7e  ~ 
 31  37  1f - |   63  77  3f  ? |   95 137  5f  _ |  127 177  7f 
```

#### Explaination:

The loop iterates from 0 to 31. For each value of `x`, it prints the ASCII values and their corresponding characters in four columns:

- **First Column**: Values from 0 to 31 (control characters, which are not printable, hence the `-`).  
  - Control characters are non-printable characters in the ASCII table that are used to control the behavior of devices such as printers or display screens. 
  - They are part of the ASCII standard and occupy the first 32 positions (0 to 31) in the ASCII table. 
  - These characters do not represent printable symbols but instead perform specific control functions.
- **Second Column**: Values from 32 to 63 (printable characters).
- **Third Column**: Values from 64 to 95 (printable characters).
- **Fourth Column**: Values from 96 to 127 (printable characters).

#### Examples of Control Characters

Here are some common control characters and their functions:

1. **NUL (Null Character)**: ASCII code 0. Used to signify the end of a string in C and other programming languages.
2. **SOH (Start of Header)**: ASCII code 1. Used to mark the beginning of a header in data transmission.
3. **STX (Start of Text)**: ASCII code 2. Used to mark the beginning of the text in data transmission.
4. **ETX (End of Text)**: ASCII code 3. Used to mark the end of the text in data transmission.
5. **EOT (End of Transmission)**: ASCII code 4. Used to indicate the end of data transmission.
6. **ENQ (Enquiry)**: ASCII code 5. Used to request a response from a remote station.
7. **ACK (Acknowledge)**: ASCII code 6. Used to acknowledge receipt of a message.
8. **BEL (Bell)**: ASCII code 7. Causes the device to emit a sound or "bell".
9. **BS (Backspace)**: ASCII code 8. Moves the cursor one position back.
10. **TAB (Horizontal Tab)**: ASCII code 9. Moves the cursor to the next tab stop.
11. **LF (Line Feed)**: ASCII code 10. Moves the cursor to the next line.
12. **VT (Vertical Tab)**: ASCII code 11. Moves the cursor to the next vertical tab stop.
13. **FF (Form Feed)**: ASCII code 12. Moves the cursor to the top of the next page.
14. **CR (Carriage Return)**: ASCII code 13. Moves the cursor to the beginning of the line.
15. **SO (Shift Out)**: ASCII code 14. Switches to an alternate character set.
16. **SI (Shift In)**: ASCII code 15. Switches back to the standard character set.
17. **DLE (Data Link Escape)**: ASCII code 16. Used to change the meaning of the following characters.
18. **DC1 (Device Control 1)**: ASCII code 17. Used for device control.
19. **DC2 (Device Control 2)**: ASCII code 18. Used for device control.
20. **DC3 (Device Control 3)**: ASCII code 19. Used for device control.
21. **DC4 (Device Control 4)**: ASCII code 20. Used for device control.
22. **NAK (Negative Acknowledge)**: ASCII code 21. Indicates a negative response to a message.
23. **SYN (Synchronous Idle)**: ASCII code 22. Used to synchronize transmission.
24. **ETB (End of Transmission Block)**: ASCII code 23. Indicates the end of a block of data.
25. **CAN (Cancel)**: ASCII code 24. Indicates that the previous data should be discarded.
26. **EM (End of Medium)**: ASCII code 25. Indicates the end of the medium.
27. **SUB (Substitute)**: ASCII code 26. Used to replace a character that is invalid or unreadable.
28. **ESC (Escape)**: ASCII code 27. Used to introduce an escape sequence.
29. **FS (File Separator)**: ASCII code 28. Used to separate files.
30. **GS (Group Separator)**: ASCII code 29. Used to separate groups of data.
31. **RS (Record Separator)**: ASCII code 30. Used to separate records.
32. **US (Unit Separator)**: ASCII code 31. Used to separate units of data.

![Screenshot from 2024-10-05 22-46-49](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-05 22-46-49.png)

![Screenshot from 2024-10-05 22-46-41](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-05 22-46-41.png)

### Generating a noncharacter output

`practice.h`

```C
char *binString(char a);
```

`functions.c`

```C
char *binString(char a)
{
    static char b[9];
    int i;

    i = 0;
    // Loops for each bit in the 8-bit byte
    while (i < 8)
    {
        // The ternary operator sets a 1 or 0 into the string, depending on the value of the far left bit in variable a.
        // The expression 'a & 0x80' checks if the most significant bit (leftmost bit) of 'a' is set. If it is, 'b[i]' is set to '1'; otherwise, it is set to '0'.
        b[i] = a & 0x80 ? '1' : '0';

        // Variable a's value is shifted one bit position to the left.
        a <<= 1;
        i++;
    }

    // At this point, i is equal to 8, so the string is capped.
    b[i] = '\0';

    return b;
}
```

`practice.c`

```C
int main()
{
    // Allocating memory
    char *testChar = malloc(2 * sizeof(char));
    if (testChar == NULL)
    {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(1);
    }
    
    // Prompting for input
    printf("Enter a word: ");
    if (fgets(testChar, 2, stdin) != NULL)
    {
        // Remove newline character
        size_t len = strlen(testChar);
        if (len > 0 && testChar[len - 1] == '\n')
        {
            testChar[len - 1] = '\0';
        }
    }
    
    char *binaryString = binString(testChar[0]);
    printf("Binary representation of '%s' is %s\n", testChar, binaryString);
    
    // Free the allocated memory and assign it to NULL to avoid dangling pointer
    free(testChar);
    testChar = NULL;
    return 0;
}
```

##### Explanation of Line 11:

```C
b[i] = a & 0x80 ? '1' : '0';
```

- `a & 0x80`: This performs a bitwise AND operation between `a`and `0x80` (which is `10000000` in binary). This operation isolates the most significant bit (MSB) of `a`.
- `a & 0x80 ? '1' : '0'`: This is a ternary operator. If the MSB of `a` is 1, the expression evaluates to `'1'`; otherwise, it evaluates to `'0'`.
- `b[i] = ...`: This assigns the result of the ternary operation to the `i`-th position in the array b.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word: A
Binary representation of 'A' is 01000001
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word: 1
Binary representation of '1' is 00110001
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word: a
Binary representation of 'a' is 01100001
```

1. **Character `'A'`**:
   - ASCII code: 65
   - Binary representation: `01000001`
2. **Character `'1'`**:
   - ASCII code: 49
   - Binary representation: `00110001`
3. **Character `'a'`**:
   - ASCII code: 97
   - Binary representation: `01100001`

#### Playing with ASCII conversion tricks

```C
printf("%d\n", '9' - '0');
```

- This `printf()` statement subtracts '0' from '9', which look like character values but are seen by the compiler as 0x39 - 0x30. 

- The result is output as decimal value nine, which is what '9' represents.

- The upper and lowercase characters differ by exactly 32 or 0x20. 

  - ```
    A  65  0x41   0010-0001
    		    
    a   97  0x61   0110-0001
    
    /How the sixth bit in a byte affects letter case
    ```

  - To convert an uppercase letter to lowercase, you reset the sixth bit in the byte.

  - To convert a lowercase letter to uppercase, you set the sixth bit in the byte.

```C
char c = 'A';
c = c | 0x20; // or c |= 0x20;
```

- Above, the uppercase letter in `char` variable `c` is converted to its lowercase equivalent.

- To convert a lowercase letter to uppercase, we must reset (change to zero) the sixth bit in the byte.

- To handle this operation, use the & operator, which masks out bits:

  - ```C
    c = c & 0xdf; // c &= 0xdf;
    ```

  - ```C
    int main()
    {
        char c = 'a';
        c &= 0xdf;
        printf("%c\n", c);
        return 0;
    }
    ```

  - ```sh
    chan@CMA:~/C_Programming/test$ ./final
    A
    ```

- The binary representation of `0x20` is `01000000`. The binary representation of `0xdf` is `10111111`.



```C
int main()
{
    char sentence[] = "ASCII makes my heart beat faster\n";
    char *s;

    s = sentence;
    while (*s)
    {
        // Filters out uppercase text
        if (*s >= 'A' && *s <= 'Z')
        {
            // outputs the lowercase character
            putchar(*s | 0x20);
        }
        else
        {
            putchar(*s);
        }
        s++;
    }

    s = sentence;
    while (*s)
    {
        // filters out lowercase text
        if (*s >= 'a' && *s <= 'z')
        {
            // output the uppercase character
            putchar(*s & 0xdf);
        }
        else
        {
            putchar(*s);
        }
        s++;
    }
    return 0;
}
```

- The same string `sentence[]` is processed twice.
- The first time, a while loop plucks uppercase characters from the string, converting them to lowercase by the bitwise `| 0x20` operation.
- The second while loop targets lowercase letters, converting them to uppercase with `& 0xdf` operation.
- Pointer `s` is used to work through the `sentence[]` array one character at a time.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
ascii makes my heart beat faster
ASCII MAKES MY HEART BEAT FASTER
```

#### A simple hex encoder/decoder

```C

int main()
{
    int ch;
    while ((ch = getchar()) != EOF)
    {
        printf("%02X", ch);
    }
    putchar('\n');
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice
Hello there, hex!
48656C6C6F2074686572652C20686578210A
```

![Screenshot from 2024-10-07 23-22-47](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-07 23-22-47.png)

Figure 5.4 illustrates what's going on with the output, how each character of input is translated into the hex bytes.



#### Hexdefilter

```C

int tohex(c)
{
    // Eliminates the digits 0 thru 9
    if (c >= '0' && c <= '9')
    {
        // Returns the digit's integer value
        return (c - '0');
    }
    // Eliminates the letters A thru F
    if (c >= 'A' && c <= 'F')
    {
        // Returns the character's hex value: 'A' == 0x0A
        return (c - 'A' + 0xA);
    }

    // Anything out of range returns -1
    return -1;
}

int main()
{
    int ch, a, b;

    // The endless loop relies upon the presence of an EOF to terminate
    while (1)
    {
        // Reads a character
        ch = getchar();
        // check for EOF and breaks the loop if found
        if (ch == EOF)
            break;
        // convert the character to a hex value
        a = tohex(ch);

        // Exit if the character isn't hex
        if (a < 0)
            break;

        // Shifts value a four bits to represent the upperhalf of the byte in value
        a <<= 4;

        // Repeat the process for the next character, but without the shift
        ch = getchar();
        if (ch == EOF)
            break;
        b = tohex(ch);
        if (b < 0)
            break;

        // Outputs the resulting byte
        putchar(a + b);
    }
    putchar('\n');
    return 0;
}
```

### Explanation of Each Line

1. **Function `tohex`**:
   - `int tohex(c)`: Defines a function `tohex` that takes a single character `c` and returns its hexadecimal value.
   - `if (c >= '0' && c <= '9')`: Checks if `c` is a digit between '0' and '9'.
   - `return (c - '0');`: Converts the character digit to its integer value.
   - `if (c >= 'A' && c <= 'F')`: Checks if `c` is an uppercase letter between 'A' and 'F'.
   - `return (c - 'A' + 0xA);`: Converts the character letter to its hexadecimal value.
   - `return -1;`: Returns -1 if `c` is not a valid hexadecimal character.
2. The program stops when it encounters a nonhex digit or when the EOF is encountered.

##### Explanation

1. **Hexadecimal Values**:
   - `0x40` is the hexadecimal representation of the decimal number 64.
   - `0x08` is the hexadecimal representation of the decimal number 8.
2. **Addition**:
   - Adding these two values: `0x40 + 0x08` is equivalent to `64 + 8` in decimal, which equals 72.
3. **ASCII Character**:
   - The ASCII value 72 corresponds to the character 'H'.

##### Step-by-Step Execution with Input `48656C6C6F2C20776F726C64210A`

Let's break down the input `48656C6C6F2C20776F726C64210A` step by step:

1. **Input**: "48"
   - `a = tohex('4')`: `a = 4`
   - `a <<= 4`: `a = 4 << 4 = 64` (0x40)
   - `b = tohex('8')`: `b = 8`
   - `putchar(a + b)`: `putchar(0x40 + 0x08)`: Prints 'H'
2. **Input**: "65"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('5')`: `b = 5`
   - `putchar(a + b)`: `putchar(0x60 + 0x05)`: Prints 'e'
3. **Input**: "6C"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('C')`: `b = 12`
   - `putchar(a + b)`: `putchar(0x60 + 0x0C)`: Prints 'l'
4. **Input**: "6C"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('C')`: `b = 12`
   - `putchar(a + b)`: `putchar(0x60 + 0x0C)`: Prints 'l'
5. **Input**: "6F"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('F')`: `b = 15`
   - `putchar(a + b)`: `putchar(0x60 + 0x0F)`: Prints 'o'
6. **Input**: "2C"
   - `a = tohex('2')`: `a = 2`
   - `a <<= 4`: `a = 2 << 4 = 32` (0x20)
   - `b = tohex('C')`: `b = 12`
   - `putchar(a + b)`: `putchar(0x20 + 0x0C)`: Prints ','
7. **Input**: "20"
   - `a = tohex('2')`: `a = 2`
   - `a <<= 4`: `a = 2 << 4 = 32` (0x20)
   - `b = tohex('0')`: `b = 0`
   - `putchar(a + b)`: `putchar(0x20 + 0x00)`: Prints ' '
8. **Input**: "77"
   - `a = tohex('7')`: `a = 7`
   - `a <<= 4`: `a = 7 << 4 = 112` (0x70)
   - `b = tohex('7')`: `b = 7`
   - `putchar(a + b)`: `putchar(0x70 + 0x07)`: Prints 'w'
9. **Input**: "6F"
   - `a = tohex('6')`: `a = 6`
   - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
   - `b = tohex('F')`: `b = 15`
   - `putchar(a + b)`: `putchar(0x60 + 0x0F)`: Prints 'o'
10. **Input**: "72"
    - `a = tohex('7')`: `a = 7`
    - `a <<= 4`: `a = 7 << 4 = 112` (0x70)
    - `b = tohex('2')`: `b = 2`
    - `putchar(a + b)`: `putchar(0x70 + 0x02)`: Prints 'r'
11. **Input**: "6C"
    - `a = tohex('6')`: `a = 6`
    - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
    - `b = tohex('C')`: `b = 12`
    - `putchar(a + b)`: `putchar(0x60 + 0x0C)`: Prints 'l'
12. **Input**: "64"
    - `a = tohex('6')`: `a = 6`
    - `a <<= 4`: `a = 6 << 4 = 96` (0x60)
    - `b = tohex('4')`: `b = 4`
    - `putchar(a + b)`: `putchar(0x60 + 0x04)`: Prints 'd'
13. **Input**: "21"
    - `a = tohex('2')`: `a = 2`
    - `a <<= 4`: `a = 2 << 4 = 32` (0x20)
    - `b = tohex('1')`: `b = 1`
    - `putchar(a + b)`: `putchar(0x20 + 0x01)`: Prints '!'
14. **Input**: "0A"
    - `a = tohex('0')`: `a = 0`
    - `a <<= 4`: `a = 0 << 4 = 0` (0x00)
    - `b = tohex('A')`: `b = 10`
    - `putchar(a + b)`: `putchar(0x00 + 0x0A)`: Prints newline '\n'

##### Final Output

The input `48656C6C6F2C20776F726C64210A` is converted to "Hello, world!\n".

```sh
chan@CMA:~/C_Programming/practice$ ./practice
48656C6C6F2C20776F726C64210A
Hello, world!
```

- In fact, the true test of encoding and decoding, we can pump output through both filters and end up with the original data.

#### Updated encoding & decoding program

`practice.h`

```C
int tohex(char c);
int is_hex_input();

void encode();
void decode();
```

`functions.c`

```C
// Function to convert a single character to its hexadecimal value
int tohex(char c){
    // for digits '0' to '9'
    if(c >= '0' && c <= '9'){
        return (c - '0');
    }

    // For uppercase letters 'A' to 'F'
    if(c >= 'A' && c <= 'F'){
        return (c - 'A' + 0xA);
    }

    // For lowercase letters 'a' to 'f'
    if(c >= 'a' && c <= 'f'){
        return (c - 'a' + 0xA);
    }

    // Anything else is invalid
    return -1;
}

// function to check if a string is in hex format
int is_hex_input(){
    int ch1 = getchar();
    int ch2 = getchar();
    ungetc(ch2, stdin); // push back second character
    ungetc(ch1, stdin); // push back first character

    // check if both characters are hex digits
    return isxdigit(ch1) && isxdigit(ch2);
}

// Function to encode input to hex
void encode(){
    int ch;

    // read each character and convert it to two hex digits
    while((ch = getchar()) != EOF){
        printf("%02X", ch);
    }
    printf("\n");
}

// function to decode hex input back to original characters
void decode(){
    int ch, a, b;

    // Loop until EOF or invalid hex input
    while(1){
        ch = getchar();
        if(ch == EOF){
            break;
        }


        // Convert the first hex character
        a = tohex(ch);
        if(a<0){
            break;
        }

        // Shift value to upper half of the byte
        a <<= 4;

        // Read the next hex character
        ch = getchar();
        if(ch == EOF){
            break;
        }
        b = tohex(ch);
        if(b < 0){
            break;
        }

        // combine the two hex digits and output the result
        putchar(a + b);
    }

    putchar('\n');
}
```

`practice.c`

```C
int main() {
    // Check if the input is hex-encoded
    if (is_hex_input()) {
        decode();  // If input is hex, decode it
    } else {
        encode();  // Otherwise, encode the input
    }
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/practice$ echo "48656C6C6F2C20776F726C64210A" | ./practice 
Hello, world!

chan@CMA:~/C_Programming/practice$ echo "48656C6C6F2C20776F726C64210A" | ./practice | ./practice
48656C6C6F2C20776F726C64210A0A

```



#### Hex Encode Program

```C
// set this value as a defined constant so that it can be updated easily
#define BYTES_PER_LINE 18

int main(){
    int ch, bytes;
    bytes = 0;
    printf("HEX ENCODE v1.0\n");
    
    while((ch = getchar()) != EOF){
        printf(" %02X", ch);
        bytes++;
        //check for the end of the line
        if(bytes == BYTES_PER_LINE){
            putchar("\n");
            bytes = 0;
        }
    }
    
    printf("\nHEX ENCODE END\n");
    return 0;
}
```

##### Example with Input "Hello, World!"

Let's break down the input "Hello, World!" step by step:

1. **Input**: "H"
   - `ch = 'H'` (ASCII 72)
   - `printf(" %02X", 72)`: Prints " 48"
   - `bytes = 1`
2. **Input**: "e"
   - `ch = 'e'` (ASCII 101)
   - `printf(" %02X", 101)`: Prints " 65"
   - `bytes = 2`
3. **Input**: "l"
   - `ch = 'l'` (ASCII 108)
   - `printf(" %02X", 108)`: Prints " 6C"
   - `bytes = 3`
4. **Input**: "l"
   - `ch = 'l'` (ASCII 108)
   - `printf(" %02X", 108)`: Prints " 6C"
   - `bytes = 4`
5. **Input**: "o"
   - `ch = 'o'` (ASCII 111)
   - `printf(" %02X", 111)`: Prints " 6F"
   - `bytes = 5`
6. **Input**: ","
   - `ch = ','` (ASCII 44)
   - `printf(" %02X", 44)`: Prints " 2C"
   - `bytes = 6`
7. **Input**: " "
   - `ch = ' '` (ASCII 32)
   - `printf(" %02X", 32)`: Prints " 20"
   - `bytes = 7`
8. **Input**: "W"
   - `ch = 'W'` (ASCII 87)
   - `printf(" %02X", 87)`: Prints " 57"
   - `bytes = 8`
9. **Input**: "o"
   - `ch = 'o'` (ASCII 111)
   - `printf(" %02X", 111)`: Prints " 6F"
   - `bytes = 9`
10. **Input**: "r"
    - `ch = 'r'` (ASCII 114)
    - `printf(" %02X", 114)`: Prints " 72"
    - `bytes = 10`
11. **Input**: "l"
    - `ch = 'l'` (ASCII 108)
    - `printf(" %02X", 108)`: Prints " 6C"
    - `bytes = 11`
12. **Input**: "d"
    - `ch = 'd'` (ASCII 100)
    - `printf(" %02X", 100)`: Prints " 64"
    - `bytes = 12`
13. **Input**: "!"
    - `ch = '!'` (ASCII 33)
    - `printf(" %02X", 33)`: Prints " 21"
    - `bytes = 13`
14. **Input**: "\n"
    - `ch = '\n'` (ASCII 10)
    - `printf(" %02X", 10)`: Prints " 0A"
    - `bytes = 14`

Since the input "Hello, World!" has 14 characters, it does not reach the `BYTES_PER_LINE` limit of 18, so no newline is printed within the loop.

##### Final Output

The final output is:

```sh
chan@CMA:~/C_Programming/test$ echo "Hello, World!" | ./final
HEX ENCODE v1.0
 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
HEX ENCODE END

```

This output shows the hexadecimal representation of each character in the input string "Hello, World!" followed by the header and footer messages.



#### Decoding Program

```C
// set this value as a defined constant so that it can be updated easily
#define BYTES_PER_LINE 18

// Calculates the buffer size for the num of bytes times the number of spaces used, plus one for the null character
#define LENGTH (BYTES_PER_LINE * 3 + 1)

int main()
{
    // buffer of size LENGTH to store input lines
    char line[LENGTH];

    // x = index for the buffer
    // ch = to store each char read from input
    // hex - to store the parsed hexadecimal value.
    int x, ch, hex;

    // This pointer holds the return value from the fgets() which is used to determine whether input is valid.
    char *r;

    r = fgets(line, LENGTH, stdin);
    // fgets() returns NULL on invalid input; otherwise, the strncmp() performs an exact comparison on the first line of text vs the required text
    if(r == NULL || strncmp(line, "HEX ENCODE", 10) != 0){
        fprintf(stderr, "Invalid HEX ENCODE data\n");
        exit(1);
    }

    x = 0;

    while((ch = getchar()) != EOF){
        // Stores incoming characters in the buffer
        line[x] = ch;

        // increment the offset
        x++;
        
        // Checks for newline (as the decoded file is formatted) or if the buffer is full
        if(ch == '\n' || x == LENGTH){
            // Replaces the newline with a null character; otherwise, caps the string
            if(line[x-1] == '\n'){
                line[x-1] = '\0';
            }else{
                line[x] = '\0';
            }

            // Checks if the line matches the string "HEX ENCODE END"
            // If true, it breaks out of the loop
            if(strncmp(line, "HEX ENCODE END", 13) == 0){
                break;
            }

            // Parses the string (input line of text), separating its content by spaces
            r = strtok(line, " ");

            // As long as the strtok() returns a non-NULL value, loop
            while(r){
                // Translate the 2-character hex string into an integer value
                sscanf(r, "%02X", &hex);

                // Output the integer value (which can be non-ASCII)
                printf("%c", hex);

                // Keeps scanning the same string
                r = strtok(NULL, " ");
            }
            x = 0;
        }

    }
    
    return 0;
}

```

- The difference between `scanf()` and `sscanf()` is that `scanf()` reads formatted input from the standard input usually from the user while `sscanf()` reads from a string rather than directly from the user input.

`sample.txt`

```
HEX ENCODE v1.0
54 68 69 73 20 69 73 20 61 6E 20 65 78 61 6D 70 6C 65
20 6F 66 20 68 65 78 20 65 6E 63 6F 64 69 6E 67 20 69
6E 20 61 20 66 6F 72 6D 61 74 74 65 64 20 6D 61 6E 6E
65 72 2E 20 49 20 61 70 70 6C 61 75 64 20 79 6F 75 20
66 6F 72 20 62 65 69 6E 67 20 61 20 6E 65 72 64 20 61
6E 64 20 64 65 63 6F 64 69 6E 67 20 74 68 69 73 20 65
78 61 6D 70 6C 65 2E 0A
HEX ENCODE END
```

```sh
chan@CMA:~/C_Programming/test$ ./final < sample.txt
This is an example of hex encoding in a formatted manner. I applaud you for being a nerd and decoding this example.

chan@CMA:~/C_Programming/test$ echo -e "HEX ENCODE v1.0\n48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A\nHEX ENCODE END" | ./final
Hello, World!
```

##### Test Run Explanation

Let's walk through the test run step by step:

1. **Command**:

   ```sh
   echo -e "HEX ENCODE v1.0\n48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A\nHEX ENCODE END" | ./final
   ```

2. **Input**:

   - The input provided to the program is:

     ```
     HEX ENCODE v1.0
     
     48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A
     
     HEX ENCODE END
     ```

3. **Execution**:

   - The program starts and reads the first line using `fgets`.
   - It checks if the first line is "HEX ENCODE v1.0". Since it matches, the program continues.
   - The program initializes `x` to 0 and enters the `while` loop to read characters using `getchar`.

4. **Processing Each Line**:

   - The program reads the characters `48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21 0A` and stores them in the buffer `line`.
   - When it encounters the newline character, it replaces it with a null character and processes the line.
   - It tokenizes the line using `strtok` and parses each token as a hexadecimal value using `sscanf`.
   - The parsed hexadecimal values are:
     - `48` -> `H`
     - `65` -> `e`
     - `6C` -> `l`
     - `6C` -> `l`
     - `6F` -> `o`
     - `2C` -> `,`
     - `20` ->
     - `57` -> `W`
     - `6F` -> `o`
     - `72` -> `r`
     - `6C` -> `l`
     - `64` -> `d`
     - `21` -> `!`
     - `0A` -> `\n`
   - It prints the characters, resulting in "Hello, World!\n".

5. **End of Input**:

   - The program reads the next line "HEX ENCODE END".
   - It checks if the line matches "HEX ENCODE END". Since it matches, the program breaks out of the loop and exits.



