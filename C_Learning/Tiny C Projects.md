# Tiny C Projects

- I have decided to put all the contents and projects from the book called "Tiny C Projects" written by Dan Gookin to later review and revise what I have learnt from the book as well as related information or improvements from external sources.
- We are going to be building upon the program's idea, often presenting a simple version and then expanding the program to offer more features.
- Sometimes other programs are introduced along the way, each of which follows the main theme or otherwise assists the primary program in its goal.

---

## 1. Daily greetings

### Instructions

- Write a simple greetings program.
- Modify your grettings program to add the time of day.
- Update the timestamp with the current moon phase.
- Enhance your grettings message with a `bon mot`.

### Solution 

#### Things to Keep in mind

- The C library is rife with time functions, all defined in the `time.h` header file.
- The `time_t` data type is also defined in the header.
- This positive integer value (long data type, `printf()` placeholder `%ld`) stores the Unix epoch, the number of seconds ticking away since midnight January 1, 1970.
- The Unix epoch is a great value to use in our grettings program.
- However, the `time_t` value must be manipulated into something a bit more useful.
- Be aware that many time functions, such as `time()` and `ctime()` used in the code for our program solution require the address of the `time_t` variable. 
- Yup, they are pointers.

```C
int main(){
    time_t now;
    
    // The time() function requires the time_t variable's address, prefixed here with the & address-of operator.
    time(&now);
    printf("The computer think it's %ld\n", now);
    
    // The ctime() function requires a pointer argument and returns a string appended with a newline.
    printf("%s", ctime(&now));
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
The computer thinks it's 1726504705
Tue Sep 17 00:38:25 2024
```

- The output shows the number of seconds tick-tocking since 1970.
- This same value is swallowed by the `ctime()` function to output a formatted time string.
- This result may be acceptable, but time data can be customized further.
- The key to unlocking specific time details is found in the `localtime()` function, as the following code here demonstrates.

```C
int main()
{
    time_t now;
    
    // because localtime() returns a pointer, it's best to declare the structure as a pointer
    struct tm *clock;
    time(&now);

    clock = localtime(&now);
    puts("Time details: ");
    printf("Day of the year: %d\n", clock->tm_year);
    
    // The first day of the week is 0 for Sunday
    printf("Day of the week: %d\n", clock->tm_wday);
    
    // We must add 1900 to the tm_year member to get the current year
    printf("Year %d\n", clock->tm_year + 1900);
    
    // The tm_mon member ranges from 0 to 11
    printf("Month: %d\n", clock->tm_mon + 1);
    printf("Day of the month: %d\n", clock->tm_mday);
    printf("Hour: %d\n", clock->tm_hour);
    printf("Minutes: %d\n", clock->tm_min);
    printf("Seconds: %d\n", clock->tm_sec);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Time details: 
Day of the year: 124
Day of the week: 2
Year 2024
Month: 9
Day of the month: 17
Hour: 0
Minutes: 46
Seconds: 7
```

- Based on the output, we can conclude that my machine at the time of practicing this is:
  - It's 124 day of the year 2024. 
  - It's Tuesday (as Day of the week is 2)
  - The month is September (Month: 9)
  - Hour, Minutes, Seconds (12:46:07 AM)
  - **Conclusion:** It is written at 12 AM midnight, on September 17th 2024, Tuesday.



**The code fetches the current hour of the day and outputs an appropriate time-of-day greeting**

```C
int main(int argc, char *argv[]){
    time_t now;
    struct tm *clock;
    int hour;
    
    time(&now);
    clock = localtime(&now);
    
    // This statement is a convenience to avoid using clock->tm_hour over and over
    hour = clock->tm_hour;
    
    printf("Good ");
    if(hour < 12){
        printf("morning");
    }else if(hour > 12){
        printf("afternoon");
    }else{
        printf("evening");
    }
    
    if(argc > 1){
        printf(", %s", argv[1]);
    }
    
    putchar('\n');
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final
Good morning
chan@CMA:~/C_Programming/test$ ./final Chan
Good morning, Chan
```



#### Adding specific time info

- A simple way to output a detailed time string is to output a greeting followed by a time string generated by the `ctime()` function.

```C
printf("Good day, %s\n", argv[1]);
printf("It's %s", ctime(&now));
```

- Still the program is lazy. Better to incorporate the `strftime()` function, which formats a timestamp string according to our specifications.
- The `strftime()` function works like `printf()`, with a special string that formats time information.
- The function's output is saved in a buffer, which our code can use later.

```C
int main(int argc, char *argv[]){
    time_t now;
    struct tm *clock;
    
    // Storage for the string filled by the strftime() function
    char time_string[64];
    
    time(&now);
    
    // We must fill a localtime() tm structure to make the strftime() function work
    clock = localtime(&now);
    
    strftime(time_string, 64, "Today is %A, %B %d, %Y%nIt is %r%n", clock);
    
    printf("Greetings");
    if(argc > 1){
        printf(", %s", argv[1]);
    }
    
    printf("!\n%s", time_string);
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/test$ ./final Chan
Greetings, Chan!
Today is Tuesday, September 17, 2024
It is 02:15:40 AM
chan@CMA:~/C_Programming/test$ ./final
Greetings!
Today is Tuesday, September 17, 2024
It is 02:15:44 AM
```

- `man strftime` in terminal to discover all the fun placeholders and what they do.
- Like the `printf()` function, the placeholders are prefixed by a % character.
- Any other text in the formatting string is output as is.
- `%A` - Full name for the current day of the week.
- `%B` - Full name for the current month.
- `%d` - Day of the month, 01 to 31.
- `%Y` - 4-digit year
- `%n` - Newline
- `%r` - Time with AM/PM
- The output reflects the time string generated and stored in the `time_string[]` buffer.
- The time string appears after the general greeting.



#### Writing the moon phase algorithm

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-09-19 01-33-14.png)

- Regardless of the time, the moon has a current phase.
- To determine the moon phase without looking outside or in a reference, we use an algorithm.
- The degree of accuracy of the algorithm depends on a lot of things such as our location.

```C
int moon_phase(int year, int month, int day)
{
    int d, g, e;

    d = day;
    if (month == 2)
    {
        d += 31;
    }
    else if (month > 2)
    {
        d += 59 + (month - 3) * 30.6 + 0.5;
    }

    g = (year - 1900) % 19;
    e = (11 * g + 29) % 30;

    if (e == 25 || e == 24)
    {
        ++e;
    }

    return ((((e + d) * 6 + 5) % 177) / 22 & 7);
}
```

##### Function Definition

```C
int moon_phase(int year, int month, int day)
```

- **Purpose**: This function calculates the moon phase for a given date.
- Parameters:
  - `year`: The year of the date.
  - `month`: The month of the date.
  - `day`: The day of the date.
- **Return Value**: An integer representing the moon phase.

##### Variable Declarations

int d, g, e;

- **d**: This variable will hold the day of the year.
- **g**: This variable will hold the golden number of the year in the Metonic cycle.
- **e**: This variable will hold an intermediate calculation used to determine the moon phase.

### Calculate Day of the Year

```C
d = day;
if (month == 2)
{
    d += 31;
}
else if (month > 2)
{
    d += 59 + (month - 3) * 30.6 + 0.5;
}
```

- **d = day**: Initialize `d` with the day of the month.
- **if (month == 2)**: If the month is February, add 31 to `d` to account for the days in January.
- **else if (month > 2):** If the month is after February:
  - **d += 59 + (month - 3) \* 30.6 + 0.5**: Add 59 to `d` to account for the days in January and February. Then, add the number of days in the months from March to the given month. The expression `(month - 3) * 30.6 + 0.5` approximates the number of days in these months.

##### Calculate Golden Number and Epact

```C
g = (year - 1900) % 19;
e = (11 * g + 29) % 30;
```

- **g = (year - 1900) % 19**: Calculate the golden number of the year in the Metonic cycle. The Metonic cycle is a period of 19 years after which the phases of the moon repeat on the same days of the year.
- **e = (11 \* g + 29) % 30**: Calculate the epact, which is the age of the moon in days on January 1st of the given year.

##### Adjust Epact for Special Cases

```C
if (e == 25 || e == 24)
{
    ++e;
}
```

- **if (e == 25 || e == 24)**: If the epact is 24 or 25, increment it by 1. This adjustment is made to correct the epact for certain years.

##### Calculate Moon Phase

```C
return ((((e + d) * 6 + 5) % 177) / 22 & 7);
```

- **(e + d)**: Add the epact to the day of the year.
- **(e + d) \* 6 + 5**: Multiply the sum by 6 and add 5. This scales the value to fit within a certain range.
- **((e + d) \* 6 + 5) % 177**: Take the result modulo 177 to wrap the value within a specific range.
- **(((e + d) \* 6 + 5) % 177) / 22**: Divide the result by 22 to get a value between 0 and 7.
- **(((e + d) \* 6 + 5) % 177) / 22 & 7**: Use bitwise AND with 7 to ensure the result is within the range 0 to 7, representing the moon phase.

##### Summary

- **0**: New Moon
- **1**: Waxing Crescent
- **2**: First Quarter
- **3**: Waxing Gibbous
- **4**: Full Moon
- **5**: Waning Gibbous
- **6**: Last Quarter
- **7**: Waning Crescent

This function uses a combination of calendar calculations and lunar cycle approximations to determine the moon phase for a given date.



#### Adding the moon phase to our greeting program

- We need to fetch time-based data, which the `moon_phase()` function requires to make its calculation.
- We also need an array of strings to output the current moon phase text based on the value the function returns.

```C
int mp;
```

- Variable `mp` to hold the value returned from the `moon_phase()` function.

`hello.h`

```C
int moon_phase(int year, int month, int day);
```

`hello.c`

```C
int moon_phase(int year, int month, int day)
{
    int d, g, e;

    d = day;
    if (month == 2)
    {
        d += 31;
    }
    else if (month > 2)
    {
        d += 59 + (month - 3) * 30.6 + 0.5;
    }

    g = (year - 1900) % 19;
    e = (11 * g + 29) % 30;

    if (e == 25 || e == 24)
    {
        ++e;
    }

    return ((((e + d) * 6 + 5) % 177) / 22 & 7);
}
```



`main.c`

```C

char *phase[8] = {
    "waxing crescent", "at first quarter", "waxing gibbous", "full", "waning gibbous", "at last quarter", "waning crescent", "new"};

int main(int argc, char *argv[])
{
    time_t now;
    struct tm *clock;
    int mp;

    char time_string[64];

    time(&now);
    clock = localtime(&now);

    mp = moon_phase(clock->tm_year + 1900, clock->tm_mon, clock->tm_mday);

    strftime(time_string, 64, "Today is %A, %B %d, %Y%nIt is %r%n", clock);

    printf("Greetings");
    if (argc > 1)
    {
        printf(", %s", argv[1]);
    }

    printf("!\n%s", time_string);
    
    printf("The moon is %s\n", phase[mp]);
    return 0;
}
```



```sh
chan@CMA:~/C_Programming/test$ ./final
Greetings!
Today is Thursday, September 19, 2024
It is 01:56:15 AM
The moon is waning gibbous
```



#### Randomly reading a pithy phrase

`pitchy.txt`

```
Politics exists so that uncoordinated people can play sports.
Water alone doesn't get you clean. You must use soap. That's because dirt and crud loves soap and sticks to it really well. The water then washes away the soap, along with the dirt, and the result is that you are clean.
You buy popcorn, soda, and candy so that you have something to eat before the movie starts.
Just wait until Starbucks figures out that you can snort coffee.
Nothing instills more doubt in the curious than the sign "Wet Paint."
You might dislike texting, but it certainly does get annoying people to shut up.
You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"
The middle of nowhere is equidistant from everywhere else.
Marketing wizards are looking for the human equivalent of what a dog feels at the sound of a can opener.
Having a pet ensures that you don't freak out over every noise in the house. Loud bang? It's the cat. So what if the cat is in the room with me. It's the cat.
The true experience at an amusement park is waiting in lines.
There is no logic in the computer industry.
The car's manual calls it the "check engine" lamp, but I call it the "This is going to cost at least $200" light.
You drive on a parkway and park on a driveway.
Do I take a break from work to play a video game, or take a break from a video game to get work done?
```

- In C, `feof` is a function that checks whether the end-of-file indicator associated with a given file stream is set. It is defined in the `<stdio.h>` header file.
- The `feof` function returns a non-zero value (true) if the end-of-file indicator is set for the specified stream.
- It returns zero (false) otherwise.
- The `feof` function is typically used in a loop to determine when the end of a file has been reached while reading from the file. 
- However, it is important to note that `feof` only returns true after an attempt to read past the end of the file has been made. Therefore, it is often used in conjunction with other file reading functions like `fgets`, `fscanf`, or `fread`.

```C
int main()
{
    const char filename[] = "pithy.txt";
    FILE *fp;

    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }

    // Loop as long as the file isn't empty
    while (!feof(fp))
    {
        // The variable r ensures that fgets() doesn't mess up and read beyond the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);

        if (r == NULL)
        {
            break;
        }

        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);

        if (entry == NULL)
        {
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }

        strcpy(entry, buffer);
        printf("%d: %s\n", items, entry);
        items++;
        // Outputs all the lines in the file
    }

    fclose(fp);
    return 0;
}

```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
0: Politics exists so that uncoordinated people can play sports.

1: Water alone doesn't get you clean. You must use soap. That's because dirt and crud loves soap and sticks to it really well. The water then washes away the soap, along with the dirt, and the result is that you are clean.

2: You buy popcorn, soda, and candy so that you have something to eat before the movie starts.

3: Just wait until Starbucks figures out that you can snort coffee.

4: Nothing instills more doubt in the curious than the sign "Wet Paint."

5: You might dislike texting, but it certainly does get annoying people to shut up.

6: You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"

7: The middle of nowhere is equidistant from everywhere else.

8: Marketing wizards are looking for the human equivalent of what a dog feels at the sound of a can opener.

9: Having a pet ensures that you don't freak out over every noise in the house. Loud bang? It's the cat. So what if the cat is in the room with me. It's the cat.

10: The true experience at an amusement park is waiting in lines.

11: There is no logic in the computer industry.

12: The car's manual calls it the "check engine" lamp, but I call it the "This is going to cost at least $200" light.

13: You drive on a parkway and park on a driveway.

14: Do I take a break from work to play a video game, or take a break from a video game to get work done?

```



- As the program sits now, it allocates a series of buffers to store the strings read.
- Yet the addresses for these buffers are lost in memory.
- To resolve this issue, a pointer-pointer is required.
- The pointer-pointer, or address of a pointer, keeps track of all the string's memory locations.

```C
#define BSIZE 256

int main(){
    const char filename[] = "pithy.txt";
    FILE *fp;
    
    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;
    int saying;
    char **list_base;
    
    fp = fopen(filename, "r");
    if(fp == NULL){
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }
    
    list_base = (char **)malloc(sizeof(char *) * 100);
    
    if(list_base == NULL){
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }
    
    // Loop as long as the file isn't empty
    while(!feof(fp)){
        // The variable r ensures that fgets() doesn't mess up and read beyong the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);
        
        if(r == NULL){
            break;
        }
        
        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);
        
        if(entry == NULL){
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }
        
        // Copy the string from the buffer into the newly allocated memory pointed to by entry
        strcpy(entry, buffer);
        
        // Stores the pointer entry in the array list_base at the position indicated by items.
        // same as list_base[items] = entry;
        *(list_base + items) = entry;
        item++;
        
        // Every time items is exactly divisible by 100
        // means the file read contains more than 100 lines of text, reallocate memory to prevent memory overflow
        if(items % 100 == 0){
            // Existing storage is increased by 100 pointer-size chunks.
            lisst_base = (char **)realloc(list_base, sizeof(char *) * (items + 100));
            if(list_base == NULL){
                fprintf(stderr, "Unable to reallocate memory\n");
                exit(1);
            }
        }
    }
    
    fclose(fp);
    
    // Output a random line of text
    srand((unsigned)time(NULL));
    saying = rand() % (items - 1);
    printf("%s", *(list_base + saying));
}
```

1. **Line 67: `*(list_base + items) = entry;`**
   - **Purpose**: This line stores the pointer `entry` in the array `list_base` at the position indicated by `items`.
   - **Details:**
     - `list_base` is a pointer to an array of character pointers (`char **`), which is used to store the lines read from the file.
     - `items` is an integer that keeps track of the number of lines read so far.
     - `*(list_base + items)` is equivalent to `list_base[items]`, which accesses the `items`-th element of the array.
     - This line effectively stores the pointer to the copied string in the `items`-th position of `list_base`.
2. **Line 68: `items++;`**
   - **Purpose**: This line increments the `items` counter by 1.
   - **Details:**
     - After storing the pointer to the copied string in `list_base`, the `items` counter is incremented to reflect that another line has been read and stored.
     - This ensures that the next line read from the file will be stored in the next position in the `list_base` array.

Summary

- **Line 66** copies the content of the `buffer` into the newly allocated memory pointed to by `entry`.
- **Line 67** stores the pointer to the copied string in the `list_base` array at the position indicated by `items`.
- **Line 68** increments the `items` counter to keep track of the number of lines read and stored.

#### Purpose of `strcpy(entry, buffer)`

- **Function**: Copies the string from `buffer` to the memory location pointed to by `entry`.
- **Reason**: `entry` is a newly allocated memory block that will hold the string read from the file.

#### Purpose of `*(list_base + items) = entry`

- **Function**: Stores the pointer `entry` in the array `list_base` at the position indicated by `items`.
- **Reason**: `list_base` is an array of pointers (`char **`) that keeps track of all the lines read from the file. By storing `entry` in `list_base`, you are effectively saving the location of the copied string so that you can access it later.

#### Why Both are Needed

1. **Copying the String**: `strcpy(entry, buffer)` ensures that the content of the buffer is copied to a new memory location (`entry`). This is necessary because `buffer` will be reused in the next iteration of the loop to read the next line from the file.
2. **Storing the Pointer**: `*(list_base + items) = entry` (or equivalently `list_base[items] = entry`) stores the pointer to the newly copied string in the `list_base` array. This allows you to keep track of all the lines read from the file. Without this step, you would lose the reference to the copied string, and it would be impossible to access it later.

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Nothing instills more doubt in the curious than the sign "Wet Paint."

chan@CMA:~/C_Programming/practice$ ./practice
You might dislike texting, but it certainly does get annoying people to shut up.

chan@CMA:~/C_Programming/practice$ ./practice
You know you have an eating problem when you finish a meal and think, "Boy! When can I do that again?"
```

### Important Note regarding the pithy program

- The program doesn't release any memory directly. 
- Normally, the end of a function would be dotted with `free()` statements, one for each memory chunk allocated.
- Because the entire code dwells within the `main()` function, freeing memory isn't necessary.
- The memory allocated is freed when the program quits.
- Had the allocation taken place in a function, however, it's necessary to release the allocation or risk losing the memory chunk and potentially causing a memory overflow.
- However, we should always explicitly free the memory allocated in our program even if it is in the `main` function.
- While the operating system will reclaim the memory when the program exits, it is good practice to free all dynamically allocated memory to avoid memory leaks and to ensure that your program is well-behaved, especially in more complex applications where memory management is critical.

```C
#define BSIZE 256

int main()
{
    const char filename[] = "pithy.txt";
    FILE *fp;

    // The buffer is used to read text from the file; the size is a guess, set as defined constant BSIZE (line 4).
    char buffer[BSIZE];
    char *r, *entry;
    int items = 0;
    int saying;
    char **list_base;

    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        fprintf(stderr, "Error opening file %s\n", filename);
        exit(1);
    }

    list_base = (char **)malloc(sizeof(char *) * 100);

    if (list_base == NULL)
    {
        fprintf(stderr, "Unable to allocate memory\n");
        exit(1);
    }

    // Loop as long as the file isn't empty
    while (!feof(fp))
    {
        // The variable r ensures that fgets() doesn't mess up and read beyond the end of the file; if so, the loop stops
        r = fgets(buffer, BSIZE, fp);

        if (r == NULL)
        {
            break;
        }

        // Enough storage for the string, plus one for the null character
        entry = (char *)malloc(sizeof(char) * strlen(buffer) + 1);

        if (entry == NULL)
        {
            fprintf(stderr, "Unable to allocate memory\n");
            exit(1);
        }

        // Copy the string from the buffer into the newly allocated memory pointed to by entry
        strcpy(entry, buffer);

        // Stores the pointer entry in the array list_base at the position indicated by items.
        *(list_base + items) = entry;
        items++;

        // Every time items is exactly divisible by 100
        // means the file read contains more than 100 lines of text, reallocate memory to prevent memory overflow
        if (items % 100 == 0)
        {
            // Existing storage is increased by 100 pointer-size chunks.
            list_base = (char **)realloc(list_base, sizeof(char *) * (items + 100));

            if (list_base == NULL)
            {
                fprintf(stderr, "Unable to reallocate memory\n");
                exit(1);
            }
        }
    }
    fclose(fp);

    // Outputs a random line of text
    srand((unsigned)time(NULL));
    saying = rand() % (items - 1);
    printf("%s", *(list_base + saying));

    // Free the allocated memory
    for (int i = 0; i < items; i++)
    {
        free(list_base[i]);
    }

    free(list_base);
    return 0;
}
```



### Similar Small Program

```C
int main(){
    char *buffer = "Hello, World!";
    char *entry = (char*)malloc(strlen(buffer) + 1);
    // Outline: For each string in buffers, memory is allocated, the string is copied, and the pointer is stored in list_base.
    strcpy(entry, buffer);
    
    
    // Now entry points to a memory location containing "Hello, World!"
    // But we need to store this pointer somewhere to access it later
    char **list_base = (char**)malloc(10 * sizeof(char *));
    int items = 0;
    
    list_base[items] = entry; // Store the pointer in the array
    
    items++;
    
    printf("%s", list_base[0]); // Prints "Hello, World!"
    printf("%s", list_base[items]); // Prints (null)
    
    // Free allocated memory
    // We don't need a loop to free the memory like the pithy program because we are only allocating and storing a single string.
    free(entry);
    free(list_base);
    return 0;
}
```

##### Explanation

1. **Initialization**:
   - `buffer` is initialized to `"Hello, World!"`.
   - `entry` is allocated enough memory to hold the string in `buffer` plus the null terminator.
   - `strcpy(entry, buffer)` copies the string from `buffer` to `entry`.
2. **Array Allocation**:
   - `list_base` is allocated memory for 10 pointers to `char`.
   - `items` is initialized to 0.
3. **Storing the Pointer**:
   - `list_base[items] = entry;` stores the pointer `entry` in `list_base[0]`.
   - `items` is incremented to 1.
4. **Printing**:
   - `printf("%s", list_base[0]);` prints the string pointed to by `list_base[0]`, which is `"Hello, World!"`.
   - `printf("%s", list_base[items]);` prints the string pointed to by `list_base[1]`, which is `NULL` because `list_base[1]` has not been initialized.

##### Why `list_base[items]` is `NULL`

- After `items` is incremented to 1, `list_base[1]` is not assigned any value. Therefore, it contains `NULL` or an undefined value.
- When you try to print `list_base[1]`, it prints `(null)` because it points to `NULL`.

##### Important Notes

If we have multiple strings like we did in the pithy program, the `list_base[items] = entry;` would be like this:

let's say our entry will have the following strings:

"Hello, World!", "John Doe", the last item is "Prince Ali"

`n` here means the last element of entry.

| list_base[0] (items = 0) | list_base[1] (items = 1) | list_base[n] (items  = n) |
| ------------------------ | ------------------------ | ------------------------- |
| memory chunk [0]         | memory chunk [1]         | memory chunk [n]          |
| "Hello, World!"          | "John Doe"               | "Prince Ali"              |
|                          |                          |                           |



###### Memory Layout

| Index (`items`) | `list_base` Pointer              | Memory Chunk Content |
| --------------- | -------------------------------- | -------------------- |
| 0               | `list_base[0]`                   | "Hello, World!"      |
| 1               | `list_base[1]`                   | "John Doe"           |
| 2               | `list_base[2]` or `list_base[n]` | "Prince Ali"         |



---

## 2. NATO output

```C
const char *nato[] = {
    "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"
};
```

- The array's notation, `*nato[]` , implies an array of pointers, which is how the compiler builds this construction in memory.
- The array's data type is `char`, so the pointers reference character arrays - strings - stored in memory.
- The `nato[]` array is filled with the memory locations of the strings as illustrated below.

Figure: How an array of pointers references strings as they sit in memory

```
char *nato[] = {
	0x404020, 0x404025, 0x40402b, 
	...
	0x4040b8, 0x4040bf
}
```

```
What the array stores

Addresses		Strings in memory
0x404020 --> "A" "l" "f" "a" "\0"
0x404025 --> "B" "r" "a" "v" "o" "\0"
0x40402b --> "C" "h" "a" "r" "l" "i" "e" "\0"
...
0x4040b8 --> "Y" "a" "n" "k" "e" "e" "\0"
0x4040bf --> "Z" "u" "l" "u" "\0"
```

- The string `Alfa` (terminated with a null character, `\0`) is stored at address `0x404020`.
- This memory location is stored in the `nato[]` array, not the string itself.
- Yes, the string appears in the array's declaration, but it is stored elsewhere in memory at runtime.

### Nato Translator Program

```C
#include <stdio.h>
#include <ctype.h>
int main()
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    char phrase[64];
    char ch;
    int i = 0;

    printf("Enter a word or phrase: ");

    // stores into location phrase 63 characters + null character from stdin, standard input.
    fgets(phrase, 64, stdin);

    // Loop until the null character is found in the string
    while (phrase[i])
    {
        ch = toupper(phrase[i]);

        // True when character ch is alphabetic
        if (isalpha(ch))
        {

            // ch-'A' transforms the letters to values 0 through 25, matching the corresponding array element.
            printf("%s ", nato[ch - 'A']);
        }
        i++;
        if (i == 64)
        {
            break;
        }
    }

    putchar('\n');
    return 0;
}
```

- Any alphabetic characters are detected by the `isalpha()` function.

- If found, the letter is used as a reference into the `nato[]` array.

- ```C
  nato[ch - 'A']
  ```

  - `ch - 'A'` calculates the index for the `nato` array.
  - For example, if `ch` is 'A', then `ch - 'A'` is `0`, so `nato[0]` is "Alfa".
  - If `ch` is 'B', then `ch - 'A'` is `1`, so `nato[1]` is "Bravo".
  - This works because the ASCII value of 'A' is 65, 'B' is 66, and so on. Subtracting 'A' (65) from any uppercase letter gives a zero-based index corresponding to that letter.
  - Let's say the input is "ABZ":
    - **First Character ('A')**:
      - `toupper('A')` is 'A'.
      - `isalpha('A')` is true.
      - `ch - 'A'` is `0`.
      - `nato[0]` is "Alfa".
      - Output: "Alfa".
    - **Second Character ('B')**:
      - `toupper('B')` is 'B'.
      - `isalpha('B')` is true.
      - `ch - 'A'` is `1`.
      - `nato[1]` is "Bravo".
      - Output: "Bravo".
    - **Third Character ('Z')**:
      - `toupper('Z')` is 'Z'.
      - `isalpha('Z')` is true.
      - `ch - 'A'` is `25`.
      - `nato[25]` is "Zulu".
      - Output: "Zulu".

**So, if we say "Howdy"**

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word or phrase: Howdy
Hotel Oscar Whiskey Delta Yankee 
```

- This basically means H for "Hotel", o for "Oscar", w for "Whiskey", d for "Delta", and y for "Yankee".
- **First Character ('H')**:
  - `toupper('H')` is 'H'.
  - `isalpha('H')` is true.
  - `ch - 'A'` is `7` (ASCII value of 'H' is 72, 'A' is 65, so 72 - 65 = 7).
  - `nato[7]` is "Hotel".
  - Output: "Hotel ".
- **Second Character ('o')**:
  - `toupper('o')` is 'O'.
  - `isalpha('O')` is true.
  - `ch - 'A'` is `14` (ASCII value of 'O' is 79, 'A' is 65, so 79 - 65 = 14).
  - `nato[14]` is "Oscar".
  - Output: "Oscar ".
- **Third Character ('w')**:
  - `toupper('w')` is 'W'.
  - `isalpha('W')` is true.
  - `ch - 'A'` is `22` (ASCII value of 'W' is 87, 'A' is 65, so 87 - 65 = 22).
  - `nato[22]` is "Whiskey".
  - Output: "Whiskey ".
- **Fourth Character ('d')**:
  - `toupper('d')` is 'D'.
  - `isalpha('D')` is true.
  - `ch - 'A'` is `3` (ASCII value of 'D' is 68, 'A' is 65, so 68 - 65 = 3).
  - `nato[3]` is "Delta".
  - Output: "Delta ".
- **Fifth Character ('y')**:
  - `toupper('y')` is 'Y'.
  - `isalpha('Y')` is true.
  - `ch - 'A'` is `24` (ASCII value of 'Y' is 89, 'A' is 65, so 89 - 65 = 24).
  - `nato[24]` is "Yankee".
  - Output: "Yankee ".
- **Sixth Character ('\n')**:
  - `toupper('\n')` is '\n'.
  - `isalpha('\n')` is false.
  - The loop continues to the next character.
- **End of String**:
  - The loop terminates when it encounters the null character (`\0`).

**If we type a longer phrase such as "Hello, World!"**

```sh 
chan@CMA:~/C_Programming/practice$ ./practice
Enter a word or phrase: Hello, World!
Hotel Echo Lima Lima Oscar Whiskey Oscar Romeo Lima Delta
```

- As we can see , and ! are ignored because nonalpha characters are ignored in the code, no output for them is generated.

### Reading and converting a file

```C
int main(int argc, char *argv[]){
    	const char *nato[] = {
        	"Alfa", "Bravo", "Charlie", "Delta", 			"Echo", "Foxtrot", "Golf", "Hotel", 			"India", "Juliett", "Kilo", "Lima", 			"Mike", "November", "Oscar", "Papa", 			"Quebec", "Romeo", "Sierra", "Tango", 			"Uniform", "Victor", "Whiskey", "X-ray", 			"Yankee", "Zulu"};
    FILE *n;
    int ch;
    
    if(argc < 2){
        fprintf(stderr, "Please supply a text file argument\n");
        exit(1);
    }
    
    // Open the filename supplied at the command prompt, referenced as argv[1]
    n = fopen(argv[1], "r");
    if(n == NULL){
        fprintf(stderr, "Unable to open %s\n", argv[1]);
        exit(1);
    }
    
    // Reads one character at a time from the file, storing it in variable ch. The EOF marks the ned of the file.
    while((ch = fgetc(n)) != EOF){
        // Process only text characters
        if(isalpha(ch)){
            // Uses the uppercase version of the character, minus the value of 'A' to index the nato[] array
            printf("%s ", nato[toupper(ch) - 'A']);
        }
    }
    
    putchar('\n');
    fclose(n);
    return 0;
    
}
```

`Output` (Opening our pithy.txt)

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Please supply a text file argument

chan@CMA:~/C_Programming/practice$ ./practice pithy.txt
Papa Oscar Lima India Tango India Charlie Sierra Echo X-ray India Sierra Tango Sierra Sierra Oscar Tango Hotel Alfa Tango Uniform November Charlie Oscar Oscar Romeo Delta India November Alfa Tango Echo Delta Papa Echo Oscar Papa Lima Echo C......
```

### Converting NATO input to character output

- We will be using `strtok()` function to parse words in a stream of text.
- `strtok()` can be assumed to be translated as "string tokenizer".
- The `strtok()` function parses a string into chunks based on one or more separator characters. Defined in `string.h` header file.

```C
char *strtok(char *str, const char *delim);
```

- The first argument `str` is the string to scan.
- The second argument `delim` (delimiter) is a string containing the individual characters that can separate or delimit, the character chunks we want to parse.
- The value returned is a `char` pointer referencing **the character chunk found.**

```C
match = strtok(string, " ");
```

- This statement scans characters held in buffer `string`, stopping when the space character is encountered.
- The `char` pointer `match` holds the address of the word (or text chunk) found, terminated with a null character where the space or another delimiter would otherwise be.
- The `NULL` constant is returned when nothing is found.
- To continue scanning the same string, the first argument is replaced with the `NULL` constant:

```C
match = strtok(NULL, " ");
```

- The `NULL` argument informs the function to use the string passed earlier and continue the tokenizing operation.

```C
int main(){
    char sometext[64];
    char *match;
    
    printf("Type some text: ");
    fgets(sometext, 64, stdin);
    
    // The initial call to strtok(), with the string to search.
    match = strtok(sometext, " ");
    
    // Loop as long as the return value is not NULL
    while(match){
        printf("%s\n", match);
        
        // In the second  call to strtok(), NULL is used to keep searching the same string which is our sometext string.
        match = strtok(NULL, " ");
    }
    
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Type some text: This is some text
This
is
some
text

chan@CMA:~/C_Programming/practice$ ./practice
Type some text: Hello, World!
Hello,
World!

```

- To avoid capturing the punctuation characters, we can set this delimiter string:

```C
match = strtok(sometext, " ,.!?:;\"'')
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Type some text: Hello, World!
Hello
World
```



`practice.h`

```C
char isterm(char *term);
```



`functions.c`

```C
char isterm(char *term)
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    int x;
    const char *n;
    char *t;

    for (x = 0; x < 26; x++)
    {
        // Set pointer n to the current nato word
        n = nato[x];
        // Pointer t references the term passed.
        t = term;

        // Loop until the NATO term ends
        while (*n != '\0')
        {
            // Logically converts each letter to uppercase and compares
            if ((*n | 0x20) != (*t | 0x20))
            {

                // For no match, the loop breaks and the next term in nato[] is compared.
                break;
            }
            // Increment through each letter
            n++;
            t++;
        }

        // When pointer n is the null character, the terms have matched.
        if (*n == '\0')
        {
            // Returns the first letter of the NATO term
            return (*nato[x]);
        }
    }
    return ('\0');
}
```

1. **`char isterm(char \*term)`**: Defines the `isterm` function that takes a string `term` and returns a character.
2. **`const char *nato[] = { ... }`**: Declares an array of strings containing the NATO phonetic alphabet.
3. **`int x;`**: Declares an integer `x` for looping through the NATO array.
4. **`const char *n;`**: Declares a pointer `n` to iterate through the NATO words.
5. **`char *t;`**: Declares a pointer `t` to iterate through the input term.
6. **`for (x = 0; x < 26; x++)`**: Loops through each NATO word.
7. **`n = nato[x];`**: Sets `n` to the current NATO word.
8. **`t = term;`**: Sets `t` to the input term.
9. **`while (*n != '\0')`**: Loops through each character of the NATO word.
10. **`if ((*n | 0x20) != (*t | 0x20))`**: Compares characters case-insensitively.
    - `*n | 0x20 ` and `*t | 0x20`:
      - The bitwise OR operation with `0x20` converts uppercase alphabetic characters to their lowercase equivalents.
      - In ASCII, the difference between uppercase and lowercase letters is the 6th bit (0x20). For example, the ASCII value of 'A' is 65 (0x41) and 'a' is 97 (0x61). The bitwise OR with `0x20` sets this bit, converting 'A' to 'a'.
      - This operation does not affect lowercase letters or non-alphabetic characters.
11. **`break;`**: Breaks the loop if characters don't match.
12. **`n++; t++;`**: Moves to the next character in both strings.
13. **`if (*n == '\0')`**: Checks if the end of the NATO word is reached.
14. **`return (*nato[x]);`**: Returns the first letter of the matching NATO word.
15. **`return ('\0');`**: Returns null character if no match is found.

###### Comparison:

- Bitwise OR with `0x20`:
  - Faster as it involves a single bitwise operation.
  - Works only for ASCII characters.
  - Does not handle locale-specific case conversions.
- `tolower`/`toupper`:
  - More readable and explicit.
  - Handles locale-specific case conversions.
  - Slightly slower due to function call overhead.

`practice.c` (Main)

```C
int main()
{

    char phrase[64];
    char *match;
    char ch;

    printf("NATO word or phrase: ");
    fgets(phrase, 64, stdin);

    match = strtok(phrase, " ");
    while (match)
    {
        if ((ch = isterm(match)) != '\0')
        {
            putchar(ch);
        }
        match = strtok(NULL, " ");
    }

    putchar('\n');
    return 0;
}
```

1. **`char phrase[64];`**: Declares a character array `phrase` with a size of 64 to store the input string.
2. **`char *match;`**: Declares a pointer `match` to hold tokens from the input string.
3. **`char ch;`**: Declares a character variable `ch` to store the result from `isterm`.
4. **`fgets(phrase, 64, stdin);`**: Reads a line of input from the standard input (keyboard) and stores it in `phrase`.
5. **`match = strtok(phrase, " ");`**: Tokenizes the input string `phrase` using space as the delimiter and stores the first token in `match`.
6. **`while (match)`**: Starts a loop that continues as long as `match` is not `NULL`.
7. **`if ((ch = isterm(match)) != '\0')`**: Calls the `isterm` function with `match` and checks if the result is not the null character.
8. **`putchar(ch);`**: If `isterm` returns a valid character, it prints that character.
9. **`match = strtok(NULL, " ");`**: Gets the next token from the input string.
10. **`putchar('\n');`**: Prints a newline character after the loop ends.



`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: india whiskey sierra bravo
IWSB
```

##### Input: "india whiskey sierra bravo"

1. Main Function Execution:
   - The input string is read and tokenized into words: "india", "whiskey", "sierra", "bravo".
   - Each word is passed to the `isterm` function.

##### Processing "india":

1. **Initialization**:
   - `term` = "india"
   - `x` starts at 0, iterating through the NATO phonetic alphabet.
2. **First Iteration (x = 0)**:
   - `n`= "Alfa"
   - `t`= "india"
   - Compare 'A' with 'i' (case-insensitive): no match, break.
3. **Second Iteration (x = 1)**:
   - `n` = "Bravo"
   - `t` = "india"
   - Compare 'B' with 'i': no match, break.
4. **Continue Iterations**:
   - This process continues until `x = 8`.
5. **Ninth Iteration (x = 8)**:
   - `n` = "India"
   - `t` = "india"
   - Compare 'I' with 'i': match.
   - Compare 'n' with 'n': match.
   - Compare 'd' with 'd': match.
   - Compare 'i' with 'i': match.
   - Compare 'a' with 'a': match.
   - `n` reaches null character, return 'I'.

##### Processing "whiskey":

1. **Initialization**:
   - `term` = "whiskey"
   - `x` starts at 0.
2. **Continue Iterations**:
   - This process continues until `x = 22`.
3. **Twenty-Third Iteration (x = 22)**:
   - `n` = "Whiskey"
   - `t` = "whiskey"
   - Compare 'W' with 'w': match.
   - Compare 'h' with 'h': match.
   - Compare 'i' with 'i': match.
   - Compare 's' with 's': match.
   - Compare 'k' with 'k': match.
   - Compare 'e' with 'e': match.
   - Compare 'y' with 'y': match.
   - `n` reaches null character, return 'W'.

##### Processing "sierra":

1. **Initialization**:
   - `term` = "sierra"
   - `x` starts at 0.
2. **Continue Iterations**:
   - This process continues until `x = 18`.
3. **Nineteenth Iteration (x = 18)**:
   - `n` = "Sierra"
   - `t` = "sierra"
   - Compare 'S' with 's': match.
   - Compare 'i' with 'i': match.
   - Compare 'e' with 'e': match.
   - Compare 'r' with 'r': match.
   - Compare 'r' with 'r': match.
   - Compare 'a' with 'a': match.
   - `n` reaches null character, return 'S'.

##### Processing "bravo":

1. **Initialization**:
   - `term` = "bravo"
   - `x` starts at 0.
2. **Second Iteration (x = 1)**:
   - `n` = "Bravo"
   - `t` = "bravo"
   - Compare 'B' with 'b': match.
   - Compare 'r' with 'r': match.
   - Compare 'a' with 'a': match.
   - Compare 'v' with 'v': match.
   - Compare 'o' with 'o': match.
   - `n` reaches null character, return 'B'.

##### Final Output:

The main function collects the results from `isterm` and prints them:

- "IWSB"

This is the step-by-step process of how the input "india whiskey sierra bravo" is processed by the code.

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: india tango whiskey oscar romeo kilo sierra
ITWORKS

```

- An input sentence with no matching characters outputs a blank line. Mixed characters are output like this:

```sh
chan@CMA:~/C_Programming/practice$ ./practice
NATO word or phrase: Also starring Zulu as Kono
Z
```

#### Reading NATO input from a file

`practice.h`

```C
char isterm(char *term);
```

`functions.c`

```C
char isterm(char *term)
{
    const char *nato[] = {
        "Alfa", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Golf", "Hotel", "India", "Juliett", "Kilo", "Lima", "Mike", "November", "Oscar", "Papa", "Quebec", "Romeo", "Sierra", "Tango", "Uniform", "Victor", "Whiskey", "X-ray", "Yankee", "Zulu"};

    int x;
    const char *n;
    char *t;

    for (x = 0; x < 26; x++)
    {
        // Set pointer n to the current nato word
        n = nato[x];
        // Pointer t references the term passed.
        t = term;

        // Loop until the NATO term ends
        while (*n != '\0')
        {
            // Logically converts each letter to uppercase and compares
            if ((*n | 0x20) != (*t | 0x20))
            {

                // For no match, the loop breaks and the next term in nato[] is compared.
                break;
            }
            // Increment through each letter
            n++;
            t++;
        }

        // When pointer n is the null character, the terms have matched.
        if (*n == '\0')
        {

            // Returns the first letter of the NATO term
            return (*nato[x]);
        }
    }

    return ('\0');
}
```

- Explanations are above.

`practice.c`

```C
int main(int argc, char *argv[])
{

    FILE *n;
    char word[64];
    int ch, offset;

    if (argc < 2)
    {
        fprintf(stderr, "Please supply a text file arguments\n");
        exit(1);
    }

    n = fopen(argv[1], "r");
    if (n == NULL)
    {
        fprintf(stderr, "Unable to open '%s'\n", argv[1]);
        exit(1);
    }

    offset = 0;
    // Loop as long as the file has bytes to read
    while ((ch = fgetc(n)) != EOF)
    {
        if (isalpha(ch))
        {
            // Stores the character to build the word
            word[offset] = ch;
            offset++;
            // Checks for overflow; bails if so
            if (offset >= 64)
            {
                fprintf(stderr, "Buffer overflow\n");
                return (1);
            }
        }
        // A nonalphabetic character is found, meaning the end of a word
        else
        {
            // Confirm that the word[] buffer has some text in it
            if (offset > 0)
            {
                // Cap the strings
                word[offset] = '\0';

                // Process the word, returning a valid character or the null character (doesn't print)
                putchar(isterm(word));

                // Resets the offset to store the next word
                offset = 0;
            }
        }
    }
    putchar('\n');
    fclose(n);
    return 0;
}
```

`Output`

```sh
chan@CMA:~/C_Programming/practice$ ./practice functions.c
ABCDEFGHIJKLMNOPQRSTUVWYZ
```

---

## Caesarean cipher

- When `block buffering` mode is active, output doesn't appear until the buffer is full or when the program ends.
- Even if a newline appears in the stream, block buffering stores the character in the stream.
- Buffering for an I/O device is set by using the `setbuf()` function, defined in `stdio.h` header file.
- This function overrides the terminal's default line buffering and establishes block buffering using a specific chunk of memory.
- In effect, it disables line buffering for the given file handle ( or standard I/O device) and activates block buffering.

```C
int main()
{
    // A holding bin for standard output; BUFSIZ is defined in stdio.h
    char buffer[BUFSIZ];
    int a, b;

    // Commit standard output to block buffering
    setbuf(stdout, buffer);

    printf("Type a letter: ");
    // Read a single character from standard input
    a = getchar();
    printf("Type a letter: ");

    // Read the next single character from standard input
    b = getchar();

    printf("a='%c', b = '%c'\n", a, b);

    return 0;
}
```

- If we run this program, we see no output, instead the `getchar()` function prompts for input, so the program waits.
- The output is held back, stored in the character array `buffer`, waiting for text to fill the buffer or for the program to end.
- If we type `ab` at the blinking cursor, only after the Enter key is pressed, does the program end and the buffer is flushed, revealing standard output:

```sh
chan@CMA:~/C_Programming/practice$ ./practice
ab
Type a letter: Type a letter: a='a', b = 'b'
```

- Some C programmers use the `fflush()` function to force output or to clear the input stream which may be a workable solution but not the best.

#### Writing a simple filter

- Filters modify stream input and generate stream output.

- The `getchar()` function reads a single character from standard input.

- For most compilers, `getchar()` is a macro, equivalent to the `fgetc()` function:

  - ```C
    c = fgetc(stdin);
    ```

- The `fgetc()` function reads a single character (byte) from an open file handle. 

- On the preceding line, `stdin` is used as the standard input device. 

- The integer value returned is stored in the `int` variable `c`.

- This variable must be declared of the integer data type, not character.

- The reason is that important values, specifically the end-of-file (EOF) marker, are integer values.

- Assigning the function's return value to a `char` variable means the EOF won't be interpreted properly.

- The `putchar()` function sends a single character to standard output.

- `putchar()` is often defined as a macro that expands to the `fputc()` function.

- ```C
  r = fputc(c, stdout);
  ```

- The `fputc()` function sends an integer value `c` to the open file handle represented by `stdout`.

- The return value, `r` is the character written or EOF for an error.

- As with `fgetc()`, both variables `r` and `c` must be integers.

- In Linux, the EOF key is `Ctrl + D`.



A program to modify the input so that all vowels are detected and replaced with an asterisk.

```C
int main()
{
    // I/O deals with integers, not characters.
    int ch;

    while ((ch = getchar()) != EOF)
    {
        switch (ch)
        {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            putchar('*');
            break;
        default:
            putchar(ch);
        }
    }

    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
hello
h*ll*
```

- The program will keep prompting, we just have to press `Ctrl + D` to mark the EOF thus end the program.



#### Exercise 4.1

"Now that you have the basic filter skeleton in `io_filter.c`, you can perform your own
modifications, testing your filter programming skills. Here is such a challenge you can
code on your own: write a filter that converts lowercase characters to uppercase. The
effect of such a filter is to generate output in ALL CAPS."

`practice.c`

```C
int main(){
    int ch;
    
    while((ch = getchar()) != EOF){
        if(islower(ch)){
            ch = toupper(ch);
        }
        putchar(ch);
    }
    
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
heLlO
HELLO
chan@CMA:~/C_Programming/practice$ ./practice
hey hey not bad
HEY HEY NOT BAD
```



#### Exercise 4.2

"Write a filter that randomizes character text, modifying standard input to generate
output in either upper- or lowercase, regardless of the original characters case."

```C
int main(){
    int ch, r;
    
    // Seed the randomizer
    srand((unsigned)time(NULL));
    
    while((ch = getchar()) != EOF){
        // Generate a random value, 0 to 1
        r = rand() % 2;
        
        // If r == 1, make the character uppercase
        if(r){
            putchar(toupper(ch));
        }
        // Otherwise, it is converted to lower
        else{
            putchar(tolower(ch));
        }
        
        // touppper() and tolower() affect only letters.
    }
}
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice
Could be worse, oh wait no it couldn't.
couLd Be WORse, OH WaIT no iT COULdN'T.

```

```sh
chan@CMA:~/C_Programming/practice$ echo "Give me all your moeny" | ./practice
gIvE mE aLl yoUr mOeny
```



```sh
chan@CMA:~/C_Programming/practice$ ./practice < file.txt
chan@CMA:~/C_Programming/practice$ echo "Give me all your moeny" | ./practice > file.txt
```

#### Rotating 13 characters

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-09-30 22-21-23.png)

```C
int main()
{
    int ch;
    while ((ch = getchar()) != EOF)
    {
        // Only process alphabet characters
        if (isalpha(ch))
        {

            // Searches for "A" thru "M" or "a" thru "m"
            if (toupper(ch) >= 'A' && toupper(ch) <= 'M')
            {
                // Rotates(shift) up for the lower half of the alphabet
                ch += 13;
            }
            else
            {
                // Otherwise, rotates (shift) down
                ch -= 13;
            }
            putchar(ch);
        }
    }
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ echo "Hail, Caesar!" | ./practice
UnvyPnrfne
```

- Because the `rot13` filter decodes and encodes the same text, we can put the program to the test through it twice.
- In the command-line construction below, text is echoed through the program once and then again.
- The result is the original text, thanks to the magic of the `rot13` process.

```sh
chan@CMA:~/C_Programming/practice$ echo "Hail, Caesar!" | ./practice | ./practice
HailCaesar
```

```sh
chan@CMA:~/C_Programming/practice$ echo "Why did Caesar cross the Rubicon?" | ./practice 
JulqvqPnrfnepebffgurEhovpba
```

#### Devising a more Caesarean cipher

![](/home/chan/Pictures/Screenshots/Screenshot from 2024-10-01 22-01-21.png)

- When a character is detected as out of range by the if statement, its value must be reduced by 26, wrapping it back to 'A' or 'a', depending on the letter's original case.
- Due to the proximity of uppercase 'Z' to lowercase 'a', this if statement test works because this particular shift is only three characters.
- From figure 4.7, we can see that the ASCII table sets only six characters between uppercase Z and lowercase a.
- For larger character shifts, more complex testing must be performed.

```C
int main(){
    int shift,ch;
    
    //Shifts from A to D which is done backward here because math
    shift = 'D' - 'A';
    
    while((ch = getchar()) != EOF){
        // Only process alphabet characters
        if(isalpha(ch)){
            // Shift the letter
            ch += shift;
            
            // Determines whether the new character is out of range
            if((ch > 'Z' && ch < 'a') || ch > 'z'){
                // If so, adjusts its value back within range
                ch -= 26;
            }
        }
    }
    
    printf("\n");
    return 0;
}
```

```sh
chan@CMA:~/C_Programming/practice$ ./practice
Now is the time for all good men...
Qrz lv wkh wlph iru doo jrrg phq...
```

- Unlike with a `rot13` filter, we can't run the same program twice to decode the A-to-D shift.
- Instead, to decode the message, we must shift from D back to A.
- Two changes are required to make this change.

```C
shift = 'A' - 'D';
```

- Second, the out-of-bounds testing must check the underside of the alphabet, so see whether a character's value has dipped below 'A' or 'a':

```C
if(ch < 'A' || (ch > 'Z' && ch < 'a')){
    ch += 26;
}
```

